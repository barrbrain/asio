<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title> Custom Memory Allocation</title>
<link rel="stylesheet" href="../../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.68.1">
<link rel="start" href="../../index.html" title="Asio">
<link rel="up" href="../design.html" title=" Design Notes">
<link rel="prev" href="async.html" title=" Asynchronous Operations">
<link rel="next" href="buffers.html" title=" Buffers">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="asio C++ library" width="250" height="60" src="../../asio.png"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="async.html"><img src="../../prev.png" alt="Prev"></a><a accesskey="u" href="../design.html"><img src="../../up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../home.png" alt="Home"></a><a accesskey="n" href="buffers.html"><img src="../../next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="asio.design.allocation"></a><a href="allocation.html" title=" Custom Memory Allocation"> Custom Memory Allocation</a></h3></div></div></div>
<p>
        Many asynchronous operations need to allocate an object to store state associated
        with the operation. For example, a Win32 implementation needs <code class="computeroutput"><span class="identifier">OVERLAPPED</span></code>-derived objects to pass to Win32
        API functions.
      </p>
<p>
        Furthermore, programs typically contain easily identifiable chains of asynchronous
        operations. A half duplex protocol implementation (e.g. an HTTP server) would
        have a single chain of operations per client (receives followed by sends).
        A full duplex protocol implementation would have two chains executing in
        parallel. Programs should be able to leverage this knowledge to reuse memory
        for all asynchronous operations in a chain.
      </p>
<p>
        Given a copy of a user-defined <code class="computeroutput"><span class="identifier">Handler</span></code>
        object <code class="computeroutput"><span class="identifier">h</span></code>, if the implementation
        needs to allocate memory associated with that handler it will execute the
        code:
      </p>
<pre class="programlisting">
<span class="keyword">void</span><span class="special">*</span> <span class="identifier">pointer</span> <span class="special">=</span> <span class="identifier">asio_handler_allocate</span><span class="special">(</span><span class="identifier">size</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">h</span><span class="special">);</span>
</pre>
<p>
        Similarly, to deallocate the memory it will execute:
      </p>
<pre class="programlisting">
<span class="identifier">asio_handler_deallocate</span><span class="special">(</span><span class="identifier">pointer</span><span class="special">,</span> <span class="identifier">size</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">h</span><span class="special">);</span>
</pre>
<p>
        These functions are located using argument-dependent lookup. The implementation
        provides default implementations of the above functions in the <code class="computeroutput"><span class="identifier">asio</span></code> namespace:
      </p>
<pre class="programlisting">
<span class="keyword">void</span><span class="special">*</span> <span class="identifier">asio_handler_allocate</span><span class="special">(</span><span class="identifier">size_t</span><span class="special">,</span> <span class="special">...);</span>
<span class="keyword">void</span> <span class="identifier">asio_handler_deallocate</span><span class="special">(</span><span class="keyword">void</span><span class="special">*,</span> <span class="identifier">size_t</span><span class="special">,</span> <span class="special">...);</span>
</pre>
<p>
        which are implemented in terms of <code class="computeroutput"><span class="special">::</span><span class="keyword">operator</span> <span class="keyword">new</span><span class="special">()</span></code> and <code class="computeroutput"><span class="special">::</span><span class="keyword">operator</span> <span class="keyword">delete</span><span class="special">()</span></code> respectively.
      </p>
<p>
        The implementation guarantees that the deallocation will occur before the
        associated handler is invoked, which means the memory is ready to be reused
        for any new asynchronous operations started by the handler.
      </p>
<p>
        The custom memory allocation functions may be called from any user-created
        thread that is calling a library function. The implementation guarantees
        that, for the asynchronous operations included the library, the implementation
        will not make concurrent calls to the memory allocation functions for that
        handler. The implementation will insert appropriate memory barriers to ensure
        correct memory visibility should allocation functions need to be called from
        different threads.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><small>Copyright © 2003 - 2007 Christopher M. Kohlhoff</small></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="async.html"><img src="../../prev.png" alt="Prev"></a><a accesskey="u" href="../design.html"><img src="../../up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../home.png" alt="Home"></a><a accesskey="n" href="buffers.html"><img src="../../next.png" alt="Next"></a>
</div>
</body>
</html>
