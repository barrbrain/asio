<HTML>
  <HEAD>
    <TITLE>asio Design: Buffers</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Design</B>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1><a class="anchor" name="designbuffers">Buffers</a></h1>To allow the development of efficient network applications, the asio library provides support for scatter-gather operations. These operations involve one or more buffers (where each buffer is a contiguous region of memory):<p>
<ul>
<li>A <b>scatter-read</b> receives data into multiple buffers. </li>
<li>A <b>gather-write</b> transmits multiple buffers.</li>
</ul>
Therefore we require an abstraction to represent a collection of buffers. The approach asio uses is to define a type (actually two types) to represent a single buffer. These can be stored in a container, which may be passed to the scatter-gather operations.<p>
A buffer, as a contiguous region of memory, can be represented by an address and size in bytes. There is a distinction between modifiable memory (called mutable in asio) and non-modifiable memory (where the latter is created from the storage for a const-qualified variable). These two types could therefore be defined as follows:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> std::pair&lt;void*, std::size_t&gt; mutable_buffer;
<span class="keyword">typedef</span> std::pair&lt;const void*, std::size_t&gt; const_buffer;
</pre></div><p>
Here, a mutable_buffer would be convertible to a const_buffer, but conversion in the opposite direction is not valid.<p>
However, the asio library does not use the above definitions, but instead defines two classes: <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00148.html">asio::mutable_buffer</a> and <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00125.html">asio::const_buffer</a>. The goal of these is to provide an opaque representation of contiguous memory, where:<p>
<ul>
<li>Types behave as std::pair would in conversions. That is, a mutable_buffer is convertible to a const_buffer, but the opposite conversion is disallowed. </li>
<li>There is protection against buffer overruns. Given a buffer instance, a user can only create another buffer representing the same range of memory or a sub-range of it. To provide further safety, the library also includes mechanisms for automatically determining the size of a buffer from an array, boost::array or std::vector of POD elements. </li>
<li>Type safety violations must be explicitly requested using the asio::buffer_cast function. In general an application should never need to do this, but it is required by the asio implementation to pass the raw memory to the underlying operating system functions.</li>
</ul>
Finally, multiple buffers can be passed to scatter-gather operations (such as <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00273.html">asio::read</a> or <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00277.html">asio::write</a>) by putting the buffer objects into a container. The <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00150.html">Mutable_Buffers</a> and <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00127.html">Const_Buffers</a> concepts have been defined so that containers such as std::vector, std::list, std::vector or boost::array can be used. See the documentation for <a class="elRef" doxygen="asio.doxytags:../reference/" href="../reference/a00270.html">asio::buffer</a> for examples.     <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
