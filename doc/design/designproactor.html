<HTML>
  <HEAD>
    <TITLE>asio Design: Proactor</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.5</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Design</B>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.5 -->
<h1><a class="anchor" name="designproactor">Proactor</a></h1>The asio library is based on the Proactor pattern [1]. This design note outlines the advantages and disadvantages of this approach.<h2><a class="anchor" name="designproactoradv">
Advantages</a></h2>
<dl compact><dt><b>Portability</b></dt><dd></dd></dl>
The library interface can be reused independently of the operating system's underlying demultiplexing mechanism [1]. The Proactor interface may be implemented using a range of event sources, including the synchronous event demultiplexers that typify the Reactor pattern, such as select.<p>
<dl compact><dt><b>Decoupling threading from concurrency</b></dt><dd></dd></dl>
Long-duration operations are performed asynchronously by the Proactor on behalf of the application. Consequently applications do not need to spawn many threads in order to increase concurrency [1].<p>
<dl compact><dt><b>Performance</b></dt><dd></dd></dl>
Implementation strategies such as thread-per-connection can degrade system performance, due to increased context switching, synchronization and data movement among CPUs [1]. The Proactor pattern can avoid the cost of context switching by minimising the number of operating system threads, and only activating the logical threads of control that have events to process.<p>
<dl compact><dt><b>Simplified application synchronisation</b></dt><dd></dd></dl>
Asynchronous operation completion handlers can be written as though they exist in a single-threaded environment, and so application logic can be developed with little or no concern for synchronisation issues [1].<p>
<dl compact><dt><b>Function composition</b></dt><dd></dd></dl>
Function composition refers to the implementation of functions to provide a higher-level operation, such as sending a message in a particular format. Each function is implemented in terms of multiple calls to lower-level read or write operations.<p>
For example, consider a protocol where each message consists of a fixed-length header followed by a variable length body, where the length of the body is specified in the header. A hypothetical read_message operation could be implemented using two lower-level reads, the first to receive the header and, once the length is known, the second to receive the body.<p>
To compose functions in a Proactor model, asynchronous operations can be chained together. That is, a completion handler for one operation can initiate the next. Starting the first call in the chain can be encapsulated so that the caller need not be aware that the higher-level operation is implemented as a chain of asynchronous operations.<p>
The ability to compose new operations in this way simplifies the development of higher levels of abstraction above a networking library, such as functions to support a specific protocol.<h2><a class="anchor" name="designproactordisadv">
Disadvantages</a></h2>
<dl compact><dt><b>Program complexity</b></dt><dd></dd></dl>
It is more difficult to develop applications using asynchronous mechanisms due to the separation in time and space between operation initiation and completion [1]. Applications may also be harder to debug due to the inverted flow of control.<p>
<dl compact><dt><b>Memory usage</b></dt><dd></dd></dl>
Buffer space must be committed for the duration of a read or write operation, which may continue indefinitely, and a separate buffer is required for each concurrent operation. The Reactor pattern, on the other hand, does not require buffer space until a socket is ready for reading or writing.<h2><a class="anchor" name="designproactorrefs">
References</a></h2>
[1] D. Schmidt et al, <em>Pattern Oriented Software Architecture, Volume 2</em>. Wiley, 2000.     <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.5</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
