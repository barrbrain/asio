<HTML>
  <HEAD>
    <TITLE>asio 0.3.3 - Services</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="index.html">Reference</A> |
            <A CLASS="qindex" HREF="tutindex.html">Tutorials</A> |
            <A CLASS="qindex" HREF="designindex.html">Design</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.3.3 -->
<h1><a name="designservices">Services</a>
</h1>The abstractions asio publishes for sockets (and other resources) are divided into three parts:<p>
<ul>
<li>A service that provides a wrapper around a platform's implementation of the resource:</li>
</ul>
<div class="fragment"><pre><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Allocator = std::allocator&lt;<span class="keywordtype">void</span>&gt; &gt;
<span class="keyword">class </span>stream_socket_service
{
<span class="keyword">public</span>:
  <span class="comment">// ...</span>

  <span class="keyword">typedef</span> implementation_defined impl_type;

  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;
  <span class="keywordtype">void</span> async_receive(impl_type&amp; impl, <span class="keywordtype">void</span>* data, size_t max_length,
      socket_base::message_flags flags, Handler handler);

  <span class="comment">// ...</span>
};
</pre></div><p>
<ul>
<li>A class template providing an object-oriented interface, where the template parameter is the service:</li>
</ul>
<div class="fragment"><pre><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Service&gt;
<span class="keyword">class </span>basic_stream_socket
{
<span class="keyword">public</span>:
  <span class="keyword">typedef</span> Service service_type;
  <span class="keyword">typedef</span> <span class="keyword">typename</span> service_type::impl_type impl_type;

  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;
  <span class="keywordtype">void</span> async_receive(<span class="keywordtype">void</span>* data, size_t max_length,
      socket_base::message_flags flags, Handler handler)
  {
    service_.async_receive(impl_, data, max_length, flags, handler);
  }

  <span class="comment">// ...</span>

<span class="keyword">private</span>:
  service_type&amp; service_;
  impl_type impl_;
};
</pre></div><p>
<ul>
<li>A typedef for the typical usage:</li>
</ul>
<div class="fragment"><pre><span class="keyword">typedef</span> basic_stream_socket&lt;stream_socket_service&lt;&gt; &gt; <a class="code" href="a00236.html#a6">stream_socket</a>;
</pre></div><p>
This design attempts meet the following goals:<p>
<ul>
<li>To efficiently encapsulate the operating system's interface for the corresponding resource. On most operating systems a socket is represented by an integer, and so the service class wraps that facility portably and without adding a "heavyweight" class around it.</li>
</ul>
<ul>
<li>To allow the implementation of the socket to be customised. Some developers may need to use a different allocator, or perhaps a completely different implementation for sockets. This can be done by supplying a different argument to the basic_stream_socket template.</li>
</ul>
<ul>
<li>To make the most common usage appear no different to a class (in a similar fashion to std::string vs std::basic_string).</li>
</ul>
<h2><a name="designservicesanddemuxer"></a>
Services and the Demuxer</h2>
The <a class="el" href="a00236.html#a2">asio::demuxer</a> object acts as an extensible collection of services, not dissimilar to the way a std::locale object is composed of facets. The demuxer contains one service object for each service type, and the service objects are accessed by their types (see <a class="el" href="a00097.html#a10">asio::basic_demuxer::get_service</a>).<p>
However, unlike std::locale, services are loaded by the demuxer only when first used. This means that you do not pay for the resources associated with a service unless you instantiate the corresponding class. For example, the deadline_timer_service implementation for Win32 uses a background thread, but this thread will not be created if there are no deadline_timer objects in a program.<p>
This design also allows the demuxer to be extended by user-defined services. As an example, a user may want to simulate asynchronous database access using a pool of background threads. A database_connection_service class can be defined to create and manage the thread pool, and each database_connection object uses this service.     <DIV CLASS="footer">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="index.html">Reference</A> |
            <A CLASS="qindex" HREF="tutindex.html">Tutorials</A> |
            <A CLASS="qindex" HREF="designindex.html">Design</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
