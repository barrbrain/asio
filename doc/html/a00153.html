<HTML>
  <HEAD>
    <TITLE>asio 0.3.3 - Sync_Read_Stream class Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="index.html">Reference</A> |
            <A CLASS="qindex" HREF="tutindex.html">Tutorials</A> |
            <A CLASS="qindex" HREF="designindex.html">Design</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.3.3 -->
<h1>Sync_Read_Stream Class Reference</h1>Inheritance diagram for Sync_Read_Stream:<p><center><img src="a00261.png" border="0" usemap="#a00262" alt="Inheritance graph"></center>
<map name="a00262">
<area href="a00151.html" shape="rect" coords="21,206,135,281" alt="">
</map>
<a href="a00076.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Synchronous read stream concept. 
<p>
<dl compact><dt><b>Implemented By:</b></dt><dd><a class="el" href="a00101.html">asio::basic_stream_socket</a> <br>
 <a class="el" href="a00105.html">asio::buffered_read_stream</a> <br>
 <a class="el" href="a00109.html">asio::buffered_write_stream</a> <br>
 <a class="el" href="a00108.html">asio::buffered_stream</a> </dd></dl>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00153.html#a0">read</a> (void *data, size_t max_length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00153.html#a1">read</a> (void *data, size_t max_length, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00153.html#a2">peek</a> (void *data, size_t max_length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00153.html#a3">peek</a> (void *data, size_t max_length, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream. </em> <a href="#a3"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00153.html#a4">in_avail</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00153.html#a5">in_avail</a> (Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking. </em> <a href="#a5"></a><em><br><br></td></tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a0" doxytag="Sync_Read_Stream::read"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t Sync_Read_Stream::read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>implementation_defined</em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a1" doxytag="Sync_Read_Stream::read"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t Sync_Read_Stream::read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> implementation_defined&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a name="a2" doxytag="Sync_Read_Stream::peek"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t Sync_Read_Stream::peek </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>implementation_defined</em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a3" doxytag="Sync_Read_Stream::peek"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t Sync_Read_Stream::peek </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> implementation_defined&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a name="a4" doxytag="Sync_Read_Stream::in_avail"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t Sync_Read_Stream::in_avail </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the amount of data that may be read without blocking. 
<p>
The function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>implementation_defined</em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a5" doxytag="Sync_Read_Stream::in_avail"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t Sync_Read_Stream::in_avail </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Error_Handler&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>error_handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the amount of data that may be read without blocking. 
<p>
The function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> implementation_defined&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking. </dd></dl>
    </td>
  </tr>
</table>
    <DIV CLASS="footer">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="index.html">Reference</A> |
            <A CLASS="qindex" HREF="tutindex.html">Tutorials</A> |
            <A CLASS="qindex" HREF="designindex.html">Design</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
