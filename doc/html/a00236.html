<HTML>
  <HEAD>
    <TITLE>asio 0.3.3 - asio Namespace Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="index.html">Reference</A> |
            <A CLASS="qindex" HREF="tutindex.html">Tutorials</A> |
            <A CLASS="qindex" HREF="designindex.html">Design</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.3.3 -->
<h1>asio Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The asio namespace defines all user-accessible classes and templates. 
<p>

<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00095.html">basic_datagram_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides datagram-oriented socket functionality. </em> <a href="a00095.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00096.html">basic_deadline_timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides waitable timer functionality. </em> <a href="a00096.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00097.html">basic_demuxer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides core event demultiplexing functionality. </em> <a href="a00097.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00099.html">basic_locking_dispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides serialised handler execution. </em> <a href="a00099.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00100.html">basic_socket_acceptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides the ability to accept new connections. </em> <a href="a00100.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00101.html">basic_stream_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides stream-oriented socket functionality. </em> <a href="a00101.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00105.html">buffered_read_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the read-related operations of a stream. </em> <a href="a00105.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00108.html">buffered_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the read- and write-related operations of a stream. </em> <a href="a00108.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00109.html">buffered_write_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the write-related operations of a stream. </em> <a href="a00109.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00112.html">datagram_socket_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a datagram socket. </em> <a href="a00112.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00113.html">deadline_timer_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a timer. </em> <a href="a00113.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00114.html">default_error_handler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default error handler. Always throws the error as an exception. </em> <a href="a00114.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00115.html">demuxer_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a demuxer. </em> <a href="a00115.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00144.html">service_factory&lt; demuxer_service&lt; Allocator &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialisation of <a class="el" href="a00143.html">service_factory</a> to allow an allocator to be specified. </em> <a href="a00144.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00118.html">error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The error class is used to encapsulate system error codes. </em> <a href="a00118.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00119.html">error_placeholder_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used to indicate a placeholder for the actual error value. </em> <a href="a00119.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00122.html">expression</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The expression class template is used to allow expressions in an error handler template to be distinguished for the purposes of overloading the || and &amp;&amp; operators. </em> <a href="a00122.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00163.html">value_eq_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to compare the error for equality with a given value. </em> <a href="a00163.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00164.html">value_neq_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to compare the error for inequality with a given value. </em> <a href="a00164.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00121.html">expr_or_expr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to perform logical or on two expressions. </em> <a href="a00121.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00120.html">expr_and_expr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to perform logical and on two expressions. </em> <a href="a00120.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00159.html">throw_error_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to always throw an error. </em> <a href="a00159.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00158.html">throw_error_if_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to throw an error if an expression is true. </em> <a href="a00158.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00146.html">set_error_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to always set a variable to the error. </em> <a href="a00146.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00145.html">set_error_if_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to set a variable to the error if an expression is true. </em> <a href="a00145.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00137.html">log_error_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to always log an error to a stream. </em> <a href="a00137.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00136.html">log_error_if_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to log an error to a stream if an expression is true. </em> <a href="a00136.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00127.html">ignore_error_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to always ignore an error. </em> <a href="a00127.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00126.html">ignore_error_if_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to ignore an error if an expression is true. </em> <a href="a00126.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00123.html">fixed_buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00123.html">fixed_buffer</a> class template can be used as a byte buffer. </em> <a href="a00123.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00130.html">is_read_buffered</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00130.html">is_read_buffered</a> class is a traits class that may be used to determine whether a stream type supports buffering of read data. </em> <a href="a00130.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00132.html">is_write_buffered</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00132.html">is_write_buffered</a> class is a traits class that may be used to determine whether a stream type supports buffering of written data. </em> <a href="a00132.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00135.html">locking_dispatcher_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a locking dispatcher. </em> <a href="a00135.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00138.html">null_error_handler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The null error handler. Always ignores the error. </em> <a href="a00138.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00143.html">service_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class may be specialised to provide custom service creation. </em> <a href="a00143.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00148.html">socket_acceptor_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a socket acceptor. </em> <a href="a00148.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00149.html">socket_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00149.html">socket_base</a> class is used as a base for the <a class="el" href="a00101.html">basic_stream_socket</a> and <a class="el" href="a00095.html">basic_datagram_socket</a> class templates so that we have a common place to define the shutdown_type and enum. </em> <a href="a00149.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00152.html">stream_socket_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a stream socket. </em> <a href="a00152.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>class &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00157.html">thread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple abstraction for starting threads. </em> <a href="a00157.html#_details">More...</a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>struct &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00160.html">time_traits&lt; boost.posix_time.ptime &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time traits specialised for posix_time;. </em> <a href="a00160.html#_details">More...</a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="a00095.html">basic_datagram_socket</a>&lt;<br>
 <a class="el" href="a00112.html">datagram_socket_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a0">datagram_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of datagram_socket. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="a00096.html">basic_deadline_timer</a>&lt;<br>
 <a class="el" href="a00113.html">deadline_timer_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a1">deadline_timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of timer. </em> <a href="#a1"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="a00097.html">basic_demuxer</a>&lt; <a class="el" href="a00115.html">demuxer_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a2">demuxer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for typical usage of demuxer. </em> <a href="#a2"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="a00099.html">basic_locking_dispatcher</a>&lt;<br>
 <a class="el" href="a00135.html">locking_dispatcher_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a4">locking_dispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of locking_dispatcher. </em> <a href="#a4"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="a00100.html">basic_socket_acceptor</a>&lt;<br>
 <a class="el" href="a00148.html">socket_acceptor_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a5">socket_acceptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of socket_acceptor. </em> <a href="#a5"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef <a class="el" href="a00101.html">basic_stream_socket</a>&lt;<br>
 <a class="el" href="a00152.html">stream_socket_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a6">stream_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of stream_socket. </em> <a href="#a6"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Expr&gt; <a class="el" href="a00122.html">expression</a>&lt; Expr &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a7">make_expression</a> (Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression object using template type deduction. </em> <a href="#a7"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Value&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00163.html">value_eq_error</a>&lt;<br>
 Value &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a8">operator==</a> (Value value, <a class="el" href="a00119.html">error_placeholder_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the error for equality with a given value. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Value&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00163.html">value_eq_error</a>&lt;<br>
 Value &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a9">operator==</a> (<a class="el" href="a00119.html">error_placeholder_t</a>, Value value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the error for equality with a given value. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Value&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00164.html">value_neq_error</a>&lt;<br>
 Value &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a10">operator!=</a> (Value value, <a class="el" href="a00119.html">error_placeholder_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the error for inequality with a given value. </em> <a href="#a10"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Value&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00164.html">value_neq_error</a>&lt;<br>
 Value &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a11">operator!=</a> (<a class="el" href="a00119.html">error_placeholder_t</a>, Value value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the error for inequality with a given value. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Expr1, typename Expr2&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00121.html">expr_or_expr</a>&lt;<br>
 <a class="el" href="a00122.html">expression</a>&lt; Expr1 &gt;, <a class="el" href="a00122.html">expression</a>&lt;<br>
 Expr2 &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a12">operator||</a> (<a class="el" href="a00122.html">expression</a>&lt; Expr1 &gt; expr1, <a class="el" href="a00122.html">expression</a>&lt; Expr2 &gt; expr2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a logical or on two expressions. </em> <a href="#a12"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Expr1, typename Expr2&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00120.html">expr_and_expr</a>&lt;<br>
 <a class="el" href="a00122.html">expression</a>&lt; Expr1 &gt;, <a class="el" href="a00122.html">expression</a>&lt;<br>
 Expr2 &gt; &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a13">operator &amp;&amp;</a> (<a class="el" href="a00122.html">expression</a>&lt; Expr1 &gt; expr1, <a class="el" href="a00122.html">expression</a>&lt; Expr2 &gt; expr2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a logical and on two expressions. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00159.html">throw_error_t</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a14">throw_error</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always throw an error. </em> <a href="#a14"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Expr&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00158.html">throw_error_if_t</a>&lt;<br>
 Expr &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a15">throw_error_if</a> (Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw an error if an expression is true. </em> <a href="#a15"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Target&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00146.html">set_error_t</a>&lt; Target &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a16">set_error</a> (Target &amp;target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a variable to the error. </em> <a href="#a16"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Target, typename Expr&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00145.html">set_error_if_t</a>&lt;<br>
 Target, Expr &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a17">set_error_if</a> (Target &amp;target, Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a variable to the error if an expression is true. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Ostream&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00137.html">log_error_t</a>&lt; Ostream &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a18">log_error</a> (Ostream &amp;ostream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always log an error to a stream. </em> <a href="#a18"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Ostream, typename Expr&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00136.html">log_error_if_t</a>&lt;<br>
 Ostream, Expr &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a19">log_error_if</a> (Ostream &amp;ostream, Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log an error to a stream if an expression is true. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00127.html">ignore_error_t</a> &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a20">ignore_error</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always ignore an error. </em> <a href="#a20"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Expr&gt; <a class="el" href="a00122.html">expression</a>&lt; <a class="el" href="a00126.html">ignore_error_if_t</a>&lt;<br>
 Expr &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a21">ignore_error_if</a> (Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ignore an error if an expression is true. </em> <a href="#a21"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Read_Stream&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a22">read</a> (<a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;s, void *data, size_t max_length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from a stream. </em> <a href="#a22"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Read_Stream, typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a23">read</a> (<a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;s, void *data, size_t max_length, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from a stream. </em> <a href="#a23"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Async_Read_Stream, typename Handler&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a24">async_read</a> (<a class="el" href="a00093.html">Async_Read_Stream</a> &amp;s, void *data, size_t max_length, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous read. </em> <a href="#a24"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Read_Stream&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a25">read_n</a> (<a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;s, void *data, size_t length, size_t *total_bytes_transferred=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the specified amount of data from the stream before returning. </em> <a href="#a25"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Read_Stream, typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a26">read_n</a> (<a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;s, void *data, size_t length, size_t *total_bytes_transferred, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the specified amount of data from the stream before returning. </em> <a href="#a26"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Async_Read_Stream, typename Handler&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a27">async_read_n</a> (<a class="el" href="a00093.html">Async_Read_Stream</a> &amp;s, void *data, size_t length, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous read that will not complete until the specified amount of data has been read. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Read_Stream&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a28">read_at_least_n</a> (<a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;s, void *data, size_t min_length, size_t max_length, size_t *total_bytes_transferred=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read at least the specified amount of data from the stream before returning. </em> <a href="#a28"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Read_Stream, typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a29">read_at_least_n</a> (<a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;s, void *data, size_t min_length, size_t max_length, size_t *total_bytes_transferred, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read at least the specified amount of data from the stream before returning. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Async_Read_Stream, typename Handler&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a30">async_read_at_least_n</a> (<a class="el" href="a00093.html">Async_Read_Stream</a> &amp;s, void *data, size_t min_length, size_t max_length, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous read that will not complete until at least the specified amount of data has been read. </em> <a href="#a30"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Write_Stream&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a31">write</a> (<a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;s, const void *data, size_t length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some data to a stream. </em> <a href="#a31"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Write_Stream, typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a32">write</a> (<a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;s, const void *data, size_t length, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some data to a stream. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Async_Write_Stream, typename Handler&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a33">async_write</a> (<a class="el" href="a00094.html">Async_Write_Stream</a> &amp;s, const void *data, size_t length, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write. </em> <a href="#a33"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Write_Stream&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a34">write_n</a> (<a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;s, const void *data, size_t length, size_t *total_bytes_transferred=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write all of the given data to the stream before returning. </em> <a href="#a34"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Write_Stream, typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a35">write_n</a> (<a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;s, const void *data, size_t length, size_t *total_bytes_transferred, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write all of the given data to the stream before returning. </em> <a href="#a35"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Async_Write_Stream, typename Handler&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a36">async_write_n</a> (<a class="el" href="a00094.html">Async_Write_Stream</a> &amp;s, const void *data, size_t length, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write that will not complete until the specified amount of data has been written. </em> <a href="#a36"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Write_Stream&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a37">write_at_least_n</a> (<a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;s, const void *data, size_t min_length, size_t max_length, size_t *total_bytes_transferred=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write at least a specified number of bytes of data to the stream before returning. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Sync_Write_Stream, typename Error_Handler&gt; size_t&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a38">write_at_least_n</a> (<a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;s, const void *data, size_t min_length, size_t max_length, size_t *total_bytes_transferred, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write at least a specified number of bytes of data to the stream before returning. </em> <a href="#a38"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>template&lt;typename Async_Write_Stream, typename Handler&gt; void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a39">async_write_at_least_n</a> (<a class="el" href="a00094.html">Async_Write_Stream</a> &amp;s, const void *data, size_t min_length, size_t max_length, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write that will not complete until at least the specified amount of data has been written. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="a00119.html">error_placeholder_t</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="a00236.html#a3">the_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This variable is used as a placeholder for the error value. </em> <a href="#a3"></a><em><br><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a name="a0" doxytag="asio::datagram_socket"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="a00095.html">basic_datagram_socket</a>&lt;<a class="el" href="a00112.html">datagram_socket_service</a>&lt;&gt; &gt; <a class="el" href="a00236.html#a0">asio::datagram_socket</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of datagram_socket. 
<p>
    </td>
  </tr>
</table>
<a name="a1" doxytag="asio::deadline_timer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="a00096.html">basic_deadline_timer</a>&lt;<a class="el" href="a00113.html">deadline_timer_service</a>&lt;&gt; &gt; <a class="el" href="a00236.html#a1">asio::deadline_timer</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of timer. 
<p>
    </td>
  </tr>
</table>
<a name="a2" doxytag="asio::demuxer"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="a00097.html">basic_demuxer</a>&lt;<a class="el" href="a00115.html">demuxer_service</a>&lt;&gt; &gt; <a class="el" href="a00236.html#a2">asio::demuxer</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for typical usage of demuxer. 
<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="asio::locking_dispatcher"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="a00099.html">basic_locking_dispatcher</a>&lt;<a class="el" href="a00135.html">locking_dispatcher_service</a>&lt;&gt; &gt; <a class="el" href="a00236.html#a4">asio::locking_dispatcher</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of locking_dispatcher. 
<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="asio::socket_acceptor"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="a00100.html">basic_socket_acceptor</a>&lt;<a class="el" href="a00148.html">socket_acceptor_service</a>&lt;&gt; &gt; <a class="el" href="a00236.html#a5">asio::socket_acceptor</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of socket_acceptor. 
<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="asio::stream_socket"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="a00101.html">basic_stream_socket</a>&lt;<a class="el" href="a00152.html">stream_socket_service</a>&lt;&gt; &gt; <a class="el" href="a00236.html#a6">asio::stream_socket</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of stream_socket. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a7" doxytag="asio::make_expression"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Expr&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;Expr&gt; make_expression </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Expr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>expr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an expression object using template type deduction. 
<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="asio::operator=="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Value&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00163.html">value_eq_error</a>&lt;Value&gt; &gt; operator== </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Value&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>error_placeholder_t&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare the error for equality with a given value. 
<p>
    </td>
  </tr>
</table>
<a name="a9" doxytag="asio::operator=="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Value&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00163.html">value_eq_error</a>&lt;Value&gt; &gt; operator== </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">error_placeholder_t&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Value&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare the error for equality with a given value. 
<p>
    </td>
  </tr>
</table>
<a name="a10" doxytag="asio::operator!="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Value&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00164.html">value_neq_error</a>&lt;Value&gt; &gt; operator!= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Value&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>error_placeholder_t&nbsp;</td>
          <td class="mdname" nowrap></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare the error for inequality with a given value. 
<p>
    </td>
  </tr>
</table>
<a name="a11" doxytag="asio::operator!="></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Value&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00164.html">value_neq_error</a>&lt;Value&gt; &gt; operator!= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">error_placeholder_t&nbsp;</td>
          <td class="mdname" nowrap>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Value&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare the error for inequality with a given value. 
<p>
    </td>
  </tr>
</table>
<a name="a12" doxytag="asio::operator||"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Expr1, typename Expr2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00121.html">expr_or_expr</a>&lt;<a class="el" href="a00122.html">expression</a>&lt;Expr1&gt;, <a class="el" href="a00122.html">expression</a>&lt;Expr2&gt; &gt; &gt; operator|| </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">expression&lt; Expr1 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>expr1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>expression&lt; Expr2 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>expr2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform a logical or on two expressions. 
<p>
    </td>
  </tr>
</table>
<a name="a13" doxytag="asio::operator &&"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Expr1, typename Expr2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00120.html">expr_and_expr</a>&lt;<a class="el" href="a00122.html">expression</a>&lt;Expr1&gt;, <a class="el" href="a00122.html">expression</a>&lt;Expr2&gt; &gt; &gt; operator &amp;&amp; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">expression&lt; Expr1 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>expr1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>expression&lt; Expr2 &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>expr2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform a logical and on two expressions. 
<p>
    </td>
  </tr>
</table>
<a name="a14" doxytag="asio::throw_error"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00159.html">throw_error_t</a>&gt; throw_error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Always throw an error. 
<p>
    </td>
  </tr>
</table>
<a name="a15" doxytag="asio::throw_error_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Expr&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00158.html">throw_error_if_t</a>&lt;Expr&gt; &gt; throw_error_if </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Expr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>expr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Throw an error if an expression is true. 
<p>
    </td>
  </tr>
</table>
<a name="a16" doxytag="asio::set_error"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Target&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00146.html">set_error_t</a>&lt;Target&gt; &gt; set_error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Target &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>target</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a variable to the error. 
<p>
    </td>
  </tr>
</table>
<a name="a17" doxytag="asio::set_error_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Target, typename Expr&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00145.html">set_error_if_t</a>&lt;Target, Expr&gt; &gt; set_error_if </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Target &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>target</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Expr&nbsp;</td>
          <td class="mdname" nowrap> <em>expr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a variable to the error if an expression is true. 
<p>
    </td>
  </tr>
</table>
<a name="a18" doxytag="asio::log_error"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Ostream&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00137.html">log_error_t</a>&lt;Ostream&gt; &gt; log_error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ostream</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Always log an error to a stream. 
<p>
    </td>
  </tr>
</table>
<a name="a19" doxytag="asio::log_error_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Ostream, typename Expr&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00136.html">log_error_if_t</a>&lt;Ostream, Expr&gt; &gt; log_error_if </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>ostream</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Expr&nbsp;</td>
          <td class="mdname" nowrap> <em>expr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Log an error to a stream if an expression is true. 
<p>
    </td>
  </tr>
</table>
<a name="a20" doxytag="asio::ignore_error"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00127.html">ignore_error_t</a>&gt; ignore_error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Always ignore an error. 
<p>
    </td>
  </tr>
</table>
<a name="a21" doxytag="asio::ignore_error_if"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Expr&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00122.html">expression</a>&lt;<a class="el" href="a00126.html">ignore_error_if_t</a>&lt;Expr&gt; &gt; ignore_error_if </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Expr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>expr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Ignore an error if an expression is true. 
<p>
    </td>
  </tr>
</table>
<a name="a22" doxytag="asio::read"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Read_Stream&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from a stream. 
<p>
This function is used to read data from a stream. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00153.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read, or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Throws an exception on failure. The type of the exception depends on the underlying stream's read operation.<p>
The read operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00236.html#a25">asio::read_n()</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a name="a23" doxytag="asio::read"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Read_Stream, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from a stream. 
<p>
This function is used to read data from a stream. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00153.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> Error&amp; error <span class="comment">// Result of operation (the actual type is dependent on</span>
                      <span class="comment">// the underlying stream's read operation)</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read, or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The read operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00236.html#a25">asio::read_n()</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a name="a24" doxytag="asio::async_read"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Async_Read_Stream, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void async_read </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00093.html">Async_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous read. 
<p>
This function is used to asynchronously read data from a stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00093.html">Async_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read. Ownership of the buffer is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> Error&amp; error,      <span class="comment">// Result of operation (the actual type is</span>
                            <span class="comment">// dependent on the underlying stream's read</span>
                            <span class="comment">// operation)</span>
   size_t bytes_transferred <span class="comment">// Number of bytes read</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The read operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00236.html#a27">asio::async_read_n()</a> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a name="a25" doxytag="asio::read_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Read_Stream&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t read_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>total_bytes_transferred</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the specified amount of data from the stream before returning. 
<p>
This function is used to read an exact number of bytes of data from a stream. The function call will block until the specified number of bytes has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00153.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>total_bytes_transferred</em>&nbsp;</td><td>An optional output parameter that receives the total number of bytes actually read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read on the last read, or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Throws an exception on failure. The type of the exception depends on the underlying stream's read operation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a26" doxytag="asio::read_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Read_Stream, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t read_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>total_bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the specified amount of data from the stream before returning. 
<p>
This function is used to read an exact number of bytes of data from a stream. The function call will block until the specified number of bytes has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00153.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>total_bytes_transferred</em>&nbsp;</td><td>An optional output parameter that receives the total number of bytes actually read.</td></tr>
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> Error&amp; error <span class="comment">// Result of operation (the actual type is dependent on</span>
                      <span class="comment">// the underlying stream's read operation)</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read on the last read, or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a name="a27" doxytag="asio::async_read_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Async_Read_Stream, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void async_read_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00093.html">Async_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous read that will not complete until the specified amount of data has been read. 
<p>
This function is used to asynchronously read an exact number of bytes of data from a stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00093.html">Async_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read. Ownership of the buffer is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> Error&amp; error,            <span class="comment">// Result of operation (the actual type is</span>
                                  <span class="comment">// dependent on the underlying stream's read</span>
                                  <span class="comment">// operation)</span>
   size_t last_bytes_transferred, <span class="comment">// Number of bytes read on last read</span>
                                  <span class="comment">// operation</span>
   size_t total_bytes_transferred <span class="comment">// Total number of bytes successfully read</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a28" doxytag="asio::read_at_least_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Read_Stream&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t read_at_least_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>min_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>total_bytes_transferred</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read at least the specified amount of data from the stream before returning. 
<p>
This function is used to read at least a specified number of bytes of data from a stream. The function call will block until at least that number of bytes has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00153.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>min_length</em>&nbsp;</td><td>The minimum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>total_bytes_transferred</em>&nbsp;</td><td>An optional output parameter that receives the total number of bytes actually red.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read on the last read, or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Throws an exception on failure. The type of the exception depends on the underlying stream's read operation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a29" doxytag="asio::read_at_least_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Read_Stream, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t read_at_least_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00153.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>min_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>total_bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read at least the specified amount of data from the stream before returning. 
<p>
This function is used to read at least a specified number of bytes of data from a stream. The function call will block until at least that number of bytes has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00153.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read.</td></tr>
    <tr><td valign=top><em>min_length</em>&nbsp;</td><td>The minimum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>total_bytes_transferred</em>&nbsp;</td><td>An optional output parameter that receives the total number of bytes actually red.</td></tr>
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> Error&amp; error <span class="comment">// Result of operation (the actual type is dependent on</span>
                      <span class="comment">// the underlying stream's read operation)</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read on the last read, or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a name="a30" doxytag="asio::async_read_at_least_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Async_Read_Stream, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void async_read_at_least_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00093.html">Async_Read_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>min_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous read that will not complete until at least the specified amount of data has been read. 
<p>
This function is used to asynchronously read at least a specified number of bytes of data from a stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00093.html">Async_Read_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The buffer into which the data will be read. Ownership of the buffer is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign=top><em>min_length</em>&nbsp;</td><td>The minimum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of the data to be read, in bytes.</td></tr>
    <tr><td valign=top><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> Error&amp; error,            <span class="comment">// Result of operation (the actual type is</span>
                                  <span class="comment">// dependent on the underlying stream's read</span>
                                  <span class="comment">// operation)</span>
   size_t last_bytes_transferred, <span class="comment">// Number of bytes read on last read</span>
                                  <span class="comment">// operation</span>
   size_t total_bytes_transferred <span class="comment">// Total number of bytes successfully read</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a31" doxytag="asio::write"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Write_Stream&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t write </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write some data to a stream. 
<p>
This function is used to write data to a stream. The function call will block until the data has been written successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00154.html">Sync_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be written, in bytes.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written, or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Throws an exception on failure. The type of the exception depends on the underlying stream's write operation.<p>
The write operation may not write all of the data to the stream. Consider using the <a class="el" href="a00236.html#a34">asio::write_n()</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a name="a32" doxytag="asio::write"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Write_Stream, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t write </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write some data to a stream. 
<p>
This function is used to write data to a stream. The function call will block until the data has been written successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00154.html">Sync_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> Error&amp; error <span class="comment">// Result of operation (the actual type is dependent on</span>
                      <span class="comment">// the underlying stream's write operation)</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written, or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The write operation may not write all of the data to the stream. Consider using the <a class="el" href="a00236.html#a34">asio::write_n()</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a name="a33" doxytag="asio::async_write"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Async_Write_Stream, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void async_write </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00094.html">Async_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous write. 
<p>
This function is used to asynchronously write data to a stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00094.html">Async_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream. Ownership of the data is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> Error&amp; error,      <span class="comment">// Result of operation (the actual type is</span>
                            <span class="comment">// dependent on the underlying stream's write</span>
                            <span class="comment">// operation)</span>
   size_t bytes_transferred <span class="comment">// Number of bytes written</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The write operation may not write all of the data to the stream. Consider using the <a class="el" href="a00236.html#a36">asio::async_write_n()</a> function if you need to ensure that all data is written before the asynchronous operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a name="a34" doxytag="asio::write_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Write_Stream&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t write_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>total_bytes_transferred</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write all of the given data to the stream before returning. 
<p>
This function is used to write an exact number of bytes of data to a stream. The function call will block until the specified number of bytes has been written successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00154.html">Sync_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>total_bytes_transferred</em>&nbsp;</td><td>An optional output parameter that receives the total number of bytes actually written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written on the last write, or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Throws an exception on failure. The type of the exception depends on the underlying stream's write operation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a35" doxytag="asio::write_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Write_Stream, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t write_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>total_bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write all of the given data to the stream before returning. 
<p>
This function is used to write an exact number of bytes of data to a stream. The function call will block until the specified number of bytes has been written successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00154.html">Sync_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>total_bytes_transferred</em>&nbsp;</td><td>An optional output parameter that receives the total number of bytes actually written.</td></tr>
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> Error&amp; error <span class="comment">// Result of operation (the actual type is dependent on</span>
                      <span class="comment">// the underlying stream's write operation)</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written on the last write, or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a name="a36" doxytag="asio::async_write_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Async_Write_Stream, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void async_write_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00094.html">Async_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous write that will not complete until the specified amount of data has been written. 
<p>
This function is used to asynchronously write an exact number of bytes of data to a stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00094.html">Async_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream. Ownership of the data is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign=top><em>length</em>&nbsp;</td><td>The size of the data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> Error&amp; error,            <span class="comment">// Result of operation (the actual type is</span>
                                  <span class="comment">// dependent on the underlying stream's</span>
                                  <span class="comment">// write operation)</span>
   size_t last_bytes_transferred, <span class="comment">// Number of bytes written on last write</span>
                                  <span class="comment">// operation</span>
   size_t total_bytes_transferred <span class="comment">// Total number of bytes successfully</span>
                                  <span class="comment">// written</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a name="a37" doxytag="asio::write_at_least_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Write_Stream&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t write_at_least_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>min_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>total_bytes_transferred</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write at least a specified number of bytes of data to the stream before returning. 
<p>
This function is used to write at least a specified number of bytes of data to a stream. The function call will block until at least that number of bytes has been written successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00154.html">Sync_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream.</td></tr>
    <tr><td valign=top><em>min_length</em>&nbsp;</td><td>The minimum size of data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>total_bytes_transferred</em>&nbsp;</td><td>An optional output parameter that receives the total number of bytes actually written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written on the last write, or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Throws an exception on failure. The type of the exception depends on the underlying stream's write operation. </dd></dl>
    </td>
  </tr>
</table>
<a name="a38" doxytag="asio::write_at_least_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Sync_Write_Stream, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> size_t write_at_least_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00154.html">Sync_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>min_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>total_bytes_transferred</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write at least a specified number of bytes of data to the stream before returning. 
<p>
This function is used to write at least a specified number of bytes of data to a stream. The function call will block until at least that number of bytes has been written successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00154.html">Sync_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream.</td></tr>
    <tr><td valign=top><em>min_length</em>&nbsp;</td><td>The minimum size of data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>total_bytes_transferred</em>&nbsp;</td><td>An optional output parameter that receives the total number of bytes actually written.</td></tr>
    <tr><td valign=top><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> Error&amp; error <span class="comment">// Result of operation (the actual type is dependent on</span>
                      <span class="comment">// the underlying stream's write operation)</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written on the last write, or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a name="a39" doxytag="asio::async_write_at_least_n"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;typename Async_Write_Stream, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void async_write_at_least_n </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00094.html">Async_Write_Stream</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap> <em>data</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>min_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>max_length</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous write that will not complete until at least the specified amount of data has been written. 
<p>
This function is used to asynchronously write at least a specified number of bytes of data to a stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the <a class="el" href="a00094.html">Async_Write_Stream</a> concept.</td></tr>
    <tr><td valign=top><em>data</em>&nbsp;</td><td>The data to be written to the stream. Ownership of the data is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign=top><em>min_length</em>&nbsp;</td><td>The minimum size of data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>max_length</em>&nbsp;</td><td>The maximum size of data to be written, in bytes.</td></tr>
    <tr><td valign=top><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Error&gt;
 <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> Error&amp; error,            <span class="comment">// Result of operation (the actual type is</span>
                                  <span class="comment">// dependent on the underlying stream's</span>
                                  <span class="comment">// write operation)</span>
   size_t last_bytes_transferred, <span class="comment">// Number of bytes written on last write</span>
                                  <span class="comment">// operation</span>
   size_t total_bytes_transferred <span class="comment">// Total number of bytes successfully</span>
                                  <span class="comment">// written</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a3" doxytag="asio::the_error"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="a00119.html">error_placeholder_t</a> <a class="el" href="a00236.html#a3">asio::the_error</a><code> [static]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This variable is used as a placeholder for the error value. 
<p>
    </td>
  </tr>
</table>
    <DIV CLASS="footer">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="index.html">Reference</A> |
            <A CLASS="qindex" HREF="tutindex.html">Tutorials</A> |
            <A CLASS="qindex" HREF="designindex.html">Design</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
