<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::basic_datagram_socket&lt; Protocol, DatagramSocketService &gt; Class Template Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc2</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="a00125.html">asio</a>::<a class="el" href="a00005.html">basic_datagram_socket</a></div>
<h1>asio::basic_datagram_socket&lt; Protocol, DatagramSocketService &gt; Class Template Reference</h1><!-- doxytag: class="asio::basic_datagram_socket" --><!-- doxytag: inherits="asio::basic_socket&lt; Protocol, DatagramSocketService &gt;" -->Inherits <a class="el" href="a00013.html">asio::basic_socket&lt; Protocol, DatagramSocketService &gt;</a>.
<p>
Inheritance diagram for asio::basic_datagram_socket&lt; Protocol, DatagramSocketService &gt;:<p><center><img src="a00141.png" border="0" usemap="#a00142" alt="Inheritance graph"></center>
<map name="a00142">
<area href="a00013.html" shape="rect" coords="328,344,816,370" alt="">
<area href="a00008.html" shape="rect" coords="8,176,440,202" alt="">
<area doxygen="external.doxytags:" href="noncopyable.html" shape="rect" coords="396,8,521,34" alt="">
<area href="a00008.html" shape="rect" coords="277,85,640,112" alt="">
<area href="a00008.html" shape="rect" coords="464,176,813,202" alt="">
<area href="a00045.html" shape="rect" coords="837,176,1008,202" alt="">
<area href="a00013.html" shape="rect" coords="434,253,842,280" alt="">
</map>
<a href="a00143.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt;<br>
 class asio::basic_datagram_socket&lt; Protocol, DatagramSocketService &gt;</h3>

Provides datagram-oriented socket functionality. 
<p>
The <a class="el" href="a00005.html">basic_datagram_socket</a> class template provides asynchronous and blocking datagram-oriented socket functionality.<p>
<dl class="user" compact><dt><b>Thread Safety</b></dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br>
 <em>Shared</em> <em>objects:</em> Unsafe. </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef DatagramSocketService::native_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#228501b6b2b71c04d77c9cc8ed6dfc76">native_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The native representation of a socket.  <a href="#228501b6b2b71c04d77c9cc8ed6dfc76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The protocol type.  <a href="#b65a458559daaa97ef48f6ee8ce46276"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol::endpoint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The endpoint type.  <a href="#f952c8d18c85588a16531cfc54a172bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00013.html">basic_socket</a>&lt; Protocol,<br>
 DatagramSocketService &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#7e749e9f9d470ab881564bd549473d2f">lowest_layer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="a00013.html">basic_socket</a> is always the lowest layer.  <a href="#7e749e9f9d470ab881564bd549473d2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef DatagramSocketService&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ee6c059b568e190966f1307cc21a264d">service_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the service that will be used to provide I/O operations.  <a href="#ee6c059b568e190966f1307cc21a264d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef service_type::implementation_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#36e6f136c8c1249242e81597c34d8d29">implementation_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying implementation type of I/O object.  <a href="#36e6f136c8c1249242e81597c34d8d29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b">shutdown_receive</a> =  implementation_defined, 
<br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62">shutdown_send</a> =  implementation_defined, 
<br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd">shutdown_both</a> =  implementation_defined
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Different ways a socket may be shutdown.  <a href="a00045.html#915e52ff147efd296350bba81f795c37">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">message_flags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitmask type for flags that can be passed to send and receive operations.  <a href="#c3cf77465dfedfe1979b5415cf32cc94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">broadcast</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to permit sending of broadcast messages.  <a href="#ee34d723e630ad0cc0b745ca5f6dc2ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">debug</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to enable socket-level debugging.  <a href="#d2c3c8844bdf08f6f74fae000d6d7217"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">do_not_route</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to prevent routing, use local interfaces only.  <a href="#4220b1b3fd7ca674d8adedb742d71680"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">keep_alive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to send keep-alives.  <a href="#493d09a6a851ec400a30e8f22adb9d74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">send_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send buffer size of a socket.  <a href="#8869a31e4367e9b62c08609dc89591b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">send_low_watermark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send low watermark.  <a href="#bff502237f6a2e248e68483e9ca6a0d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">receive_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive buffer size of a socket.  <a href="#d79401946636f3e91c1cc66436d1f975"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">receive_low_watermark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive low watermark.  <a href="#f487bc8987ef57e2c7469b40bba591a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">reuse_address</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to allow the socket to be bound to an address that is already in use.  <a href="#66ab5649a23766107c5da2a04993d8dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">linger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to specify whether the socket lingers on close if unsent data is present.  <a href="#308e86dd1ee896dd26c07abf7e6ff1b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">enable_connection_aborted</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to report aborted connections on accept.  <a href="#9ef00aa2ca23006e9868f2ea46223aea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">non_blocking_io</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO control command to set the blocking mode of the socket.  <a href="#28512bf41a5983383e0f5968c6e0580d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">bytes_readable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO control command to get the amount of data that can be read without blocking.  <a href="#bbde8e590fbb98dfa1685b9d435cb5dc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#e77f8c12f6b4b1e79cb46bedc7e7b1f8">basic_datagram_socket</a> (<a class="el" href="a00032.html">asio::io_service</a> &amp;<a class="el" href="a00032.html">io_service</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="a00005.html">basic_datagram_socket</a> without opening it.  <a href="#e77f8c12f6b4b1e79cb46bedc7e7b1f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#6f9602b7c0fb440492380d679d2d01d4">basic_datagram_socket</a> (<a class="el" href="a00032.html">asio::io_service</a> &amp;<a class="el" href="a00032.html">io_service</a>, const <a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a> &amp;protocol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct and open a <a class="el" href="a00005.html">basic_datagram_socket</a>.  <a href="#6f9602b7c0fb440492380d679d2d01d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#caa6d8654677fc051647817017df08da">basic_datagram_socket</a> (<a class="el" href="a00032.html">asio::io_service</a> &amp;<a class="el" href="a00032.html">io_service</a>, const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="a00005.html">basic_datagram_socket</a>, opening it and binding it to the given local endpoint.  <a href="#caa6d8654677fc051647817017df08da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html#cf5e1d7936cad338670ead6ac73d72a0">basic_datagram_socket</a> (<a class="el" href="a00032.html">asio::io_service</a> &amp;<a class="el" href="a00032.html">io_service</a>, const <a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a> &amp;protocol, const <a class="el" href="a00005.html#228501b6b2b71c04d77c9cc8ed6dfc76">native_type</a> &amp;native_socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="a00005.html">basic_datagram_socket</a> on an existing native socket.  <a href="#cf5e1d7936cad338670ead6ac73d72a0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#1483662cb979a253779299048cbfbc21">send</a> (const ConstBufferSequence &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send some data on a connected socket.  <a href="#1483662cb979a253779299048cbfbc21"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#feafeb0698eb82910ba1dfcaa4194e99">send</a> (const ConstBufferSequence &amp;buffers, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send some data on a connected socket.  <a href="#feafeb0698eb82910ba1dfcaa4194e99"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#a33a1dbe5354de35dd7fa5b8ffc36271">send</a> (const ConstBufferSequence &amp;buffers, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send some data on a connected socket.  <a href="#a33a1dbe5354de35dd7fa5b8ffc36271"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#ba72c1bc687c8e77d917ebb675d9d3d7">async_send</a> (const ConstBufferSequence &amp;buffers, WriteHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous send on a connected socket.  <a href="#ba72c1bc687c8e77d917ebb675d9d3d7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#ce601fb412f7d379d6470f0154602588">async_send</a> (const ConstBufferSequence &amp;buffers, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags, WriteHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous send on a connected socket.  <a href="#ce601fb412f7d379d6470f0154602588"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#4ad10cd68bc2738a97c361b6d2c90ea5">send_to</a> (const ConstBufferSequence &amp;buffers, const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;destination)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a datagram to the specified endpoint.  <a href="#4ad10cd68bc2738a97c361b6d2c90ea5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#8b3936498e4100b58a3e4ed5720b6fc1">send_to</a> (const ConstBufferSequence &amp;buffers, const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;destination, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a datagram to the specified endpoint.  <a href="#8b3936498e4100b58a3e4ed5720b6fc1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#f7ce556323d73182c473a049050298fd">send_to</a> (const ConstBufferSequence &amp;buffers, const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;destination, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a datagram to the specified endpoint.  <a href="#f7ce556323d73182c473a049050298fd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#684892ec806755c38810e2733950d609">async_send_to</a> (const ConstBufferSequence &amp;buffers, const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;destination, WriteHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous send.  <a href="#684892ec806755c38810e2733950d609"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#566c61113248013b5c11d7a31c0b7a0d">async_send_to</a> (const ConstBufferSequence &amp;buffers, const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;destination, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags, WriteHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous send.  <a href="#566c61113248013b5c11d7a31c0b7a0d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#87bf840e8e13167e9026df9f190607a5">receive</a> (const MutableBufferSequence &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive some data on a connected socket.  <a href="#87bf840e8e13167e9026df9f190607a5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#e533a17a81bc230e591995a433640751">receive</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive some data on a connected socket.  <a href="#e533a17a81bc230e591995a433640751"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#c650bfd118f390d43aee99527bae2743">receive</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive some data on a connected socket.  <a href="#c650bfd118f390d43aee99527bae2743"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#742d08afc6458b27dc803da1ff3c391d">async_receive</a> (const MutableBufferSequence &amp;buffers, ReadHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous receive on a connected socket.  <a href="#742d08afc6458b27dc803da1ff3c391d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#2b3c24ab7adc78b8e7f4caee528b313c">async_receive</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags, ReadHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous receive on a connected socket.  <a href="#2b3c24ab7adc78b8e7f4caee528b313c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#994ea38ff4c08abeacd663a4d1d9b72d">receive_from</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;sender_endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a datagram with the endpoint of the sender.  <a href="#994ea38ff4c08abeacd663a4d1d9b72d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#d7ef49c92a27a4b98b4a107c943b599a">receive_from</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;sender_endpoint, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a datagram with the endpoint of the sender.  <a href="#d7ef49c92a27a4b98b4a107c943b599a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#0b62c17f90b8d0c8c3910dc627914402">receive_from</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;sender_endpoint, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a datagram with the endpoint of the sender.  <a href="#0b62c17f90b8d0c8c3910dc627914402"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#873d734eea489acbe03a3302934fb89d">async_receive_from</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;sender_endpoint, ReadHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous receive.  <a href="#873d734eea489acbe03a3302934fb89d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00005.html#d7331d226f03efda6be1235d385584a2">async_receive_from</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;sender_endpoint, <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a> flags, ReadHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous receive.  <a href="#d7331d226f03efda6be1235d385584a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html">lowest_layer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#cd1a03601cf874d77169f9294e6ebad4">lowest_layer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#cd1a03601cf874d77169f9294e6ebad4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ddde141b21499e7918c5a93c3cbab1d1">open</a> (const <a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a> &amp;protocol=<a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="#ddde141b21499e7918c5a93c3cbab1d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#9cd7189fb57ad92321affbae2e7bcd01">open</a> (const <a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a> &amp;protocol, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="#9cd7189fb57ad92321affbae2e7bcd01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#452fbce78dff7c03c9906daa27d4163b">assign</a> (const <a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a> &amp;protocol, const <a class="el" href="a00005.html#228501b6b2b71c04d77c9cc8ed6dfc76">native_type</a> &amp;native_socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="#452fbce78dff7c03c9906daa27d4163b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#21d132e623b0f1b9eb6af15e60e9aef4">assign</a> (const <a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a> &amp;protocol, const <a class="el" href="a00005.html#228501b6b2b71c04d77c9cc8ed6dfc76">native_type</a> &amp;native_socket, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="#21d132e623b0f1b9eb6af15e60e9aef4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#d18a1f2f159d0d99aa088df9e58d1cfc">is_open</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the socket is open.  <a href="#d18a1f2f159d0d99aa088df9e58d1cfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ecb8346a5bc290e394a055b7d9164c0f">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the socket.  <a href="#ecb8346a5bc290e394a055b7d9164c0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#3fa404892b34feff1f8e013ab7c3e7ee">close</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the socket.  <a href="#3fa404892b34feff1f8e013ab7c3e7ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00005.html#228501b6b2b71c04d77c9cc8ed6dfc76">native_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#9e65e3e73aa11b017d355d902e9b6ddc">native</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the native socket representation.  <a href="#9e65e3e73aa11b017d355d902e9b6ddc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#8c93c7f90a9c2b44e1bedfa8f2fe63c8">cancel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="#8c93c7f90a9c2b44e1bedfa8f2fe63c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#1128f1e16ef26eb7fa9328548a2a08e9">cancel</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="#1128f1e16ef26eb7fa9328548a2a08e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#11fefda4db8247c58ada119040daedbe">at_mark</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="#11fefda4db8247c58ada119040daedbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#2fb2030562128667c88fe5f8cf613aa3">at_mark</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="#2fb2030562128667c88fe5f8cf613aa3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#1464a056487487ba19ac2a7ce633ffac">available</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="#1464a056487487ba19ac2a7ce633ffac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#f32340508e7c17e124418ebd1f48a0e4">available</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="#f32340508e7c17e124418ebd1f48a0e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#29f2660dcb63871f6ac50e5be2545194">bind</a> (const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="#29f2660dcb63871f6ac50e5be2545194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#7b65419efd4f773417c53221070d5a59">bind</a> (const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;endpoint, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="#7b65419efd4f773417c53221070d5a59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#c3c66c10841897d56e75799e81d7f319">connect</a> (const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;peer_endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="#c3c66c10841897d56e75799e81d7f319"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#9f590780830e8f00925fd07ebaa9e71b">connect</a> (const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;peer_endpoint, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="#9f590780830e8f00925fd07ebaa9e71b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#13862c86b40404249dc2ad54dbb81271">async_connect</a> (const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;peer_endpoint, ConnectHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous connect.  <a href="#13862c86b40404249dc2ad54dbb81271"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#f040b3c66c466f4184b690bb6904a3f3">set_option</a> (const SettableSocketOption &amp;option)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option on the socket.  <a href="#f040b3c66c466f4184b690bb6904a3f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#e42c5d5d6779b68fa068032814a969da">set_option</a> (const SettableSocketOption &amp;option, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option on the socket.  <a href="#e42c5d5d6779b68fa068032814a969da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#88d39aad400fa707d816639402d013b8">get_option</a> (GettableSocketOption &amp;option) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an option from the socket.  <a href="#88d39aad400fa707d816639402d013b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#8c40f85557f13e0e946a9b0395f9c313">get_option</a> (GettableSocketOption &amp;option, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an option from the socket.  <a href="#8c40f85557f13e0e946a9b0395f9c313"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#4fb5d33d2ebee7fc119c3060ab258cde">io_control</a> (IoControlCommand &amp;command)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="#4fb5d33d2ebee7fc119c3060ab258cde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#6fa2182e4e122c5e1a1a5c960ef41180">io_control</a> (IoControlCommand &amp;command, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="#6fa2182e4e122c5e1a1a5c960ef41180"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#efb7bdafc26eb3dd3b1a8c0559947754">local_endpoint</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="#efb7bdafc26eb3dd3b1a8c0559947754"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#2bec75bc112611561d8f13db299d72af">local_endpoint</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="#2bec75bc112611561d8f13db299d72af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a190ca5477b3dcee0d9c9d97a427897a">remote_endpoint</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="#a190ca5477b3dcee0d9c9d97a427897a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#61cc239a1078a1a62589a2abedea8b76">remote_endpoint</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="#61cc239a1078a1a62589a2abedea8b76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#f8b410b0be483ff3a9c03d67f754f02c">shutdown</a> (<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a> what)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="#f8b410b0be483ff3a9c03d67f754f02c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#7f07b5990a61e483ab24862912e695ae">shutdown</a> (<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a> what, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="#7f07b5990a61e483ab24862912e695ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="a00032.html">io_service</a> associated with the object.  <a href="#e5208e056c92fa6130114d023a5bd8b0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#356e1bd7da0353e5472028cdec742ed0">message_peek</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at incoming data without removing it from the input queue.  <a href="#356e1bd7da0353e5472028cdec742ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#b9f08ba445b7ce09ece5ac7beaa6e7c9">message_out_of_band</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process out-of-band data.  <a href="#b9f08ba445b7ce09ece5ac7beaa6e7c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#e27428a48d1a7113a95ea205b1e17978">message_do_not_route</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify that the data should not be subject to routing.  <a href="#e27428a48d1a7113a95ea205b1e17978"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">max_connections</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the queue of pending incoming connections.  <a href="#85ee2a3ce0ec68ac8c026884c5bd3098"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="228501b6b2b71c04d77c9cc8ed6dfc76"></a><!-- doxytag: member="asio::basic_datagram_socket::native_type" ref="228501b6b2b71c04d77c9cc8ed6dfc76" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DatagramSocketService::native_type <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::<a class="el" href="a00005.html#228501b6b2b71c04d77c9cc8ed6dfc76">native_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The native representation of a socket. 
<p>

<p>
Reimplemented from <a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">asio::basic_socket&lt; Protocol, DatagramSocketService &gt;</a>.
</div>
</div><p>
<a class="anchor" name="b65a458559daaa97ef48f6ee8ce46276"></a><!-- doxytag: member="asio::basic_datagram_socket::protocol_type" ref="b65a458559daaa97ef48f6ee8ce46276" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::<a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The protocol type. 
<p>

<p>
Reimplemented from <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">asio::basic_socket&lt; Protocol, DatagramSocketService &gt;</a>.
</div>
</div><p>
<a class="anchor" name="f952c8d18c85588a16531cfc54a172bb"></a><!-- doxytag: member="asio::basic_datagram_socket::endpoint_type" ref="f952c8d18c85588a16531cfc54a172bb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::<a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The endpoint type. 
<p>

<p>
Reimplemented from <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">asio::basic_socket&lt; Protocol, DatagramSocketService &gt;</a>.
</div>
</div><p>
<a class="anchor" name="7e749e9f9d470ab881564bd549473d2f"></a><!-- doxytag: member="asio::basic_datagram_socket::lowest_layer_type" ref="7e749e9f9d470ab881564bd549473d2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00013.html">basic_socket</a>&lt;Protocol , DatagramSocketService &gt; <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::<a class="el" href="a00013.html">lowest_layer_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A <a class="el" href="a00013.html">basic_socket</a> is always the lowest layer. 
<p>

</div>
</div><p>
<a class="anchor" name="ee6c059b568e190966f1307cc21a264d"></a><!-- doxytag: member="asio::basic_datagram_socket::service_type" ref="ee6c059b568e190966f1307cc21a264d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DatagramSocketService  <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; DatagramSocketService  &gt;::<a class="el" href="a00008.html#ee6c059b568e190966f1307cc21a264d">service_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of the service that will be used to provide I/O operations. 
<p>

</div>
</div><p>
<a class="anchor" name="36e6f136c8c1249242e81597c34d8d29"></a><!-- doxytag: member="asio::basic_datagram_socket::implementation_type" ref="36e6f136c8c1249242e81597c34d8d29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef service_type::implementation_type <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; DatagramSocketService  &gt;::<a class="el" href="a00008.html#36e6f136c8c1249242e81597c34d8d29">implementation_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The underlying implementation type of I/O object. 
<p>

</div>
</div><p>
<a class="anchor" name="c3cf77465dfedfe1979b5415cf32cc94"></a><!-- doxytag: member="asio::basic_datagram_socket::message_flags" ref="c3cf77465dfedfe1979b5415cf32cc94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">asio::socket_base::message_flags</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitmask type for flags that can be passed to send and receive operations. 
<p>

</div>
</div><p>
<a class="anchor" name="ee34d723e630ad0cc0b745ca5f6dc2ba"></a><!-- doxytag: member="asio::basic_datagram_socket::broadcast" ref="ee34d723e630ad0cc0b745ca5f6dc2ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to permit sending of broadcast messages. 
<p>
Implements the SOL_SOCKET/SO_BROADCAST socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2c3c8844bdf08f6f74fae000d6d7217"></a><!-- doxytag: member="asio::basic_datagram_socket::debug" ref="d2c3c8844bdf08f6f74fae000d6d7217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to enable socket-level debugging. 
<p>
Implements the SOL_SOCKET/SO_DEBUG socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4220b1b3fd7ca674d8adedb742d71680"></a><!-- doxytag: member="asio::basic_datagram_socket::do_not_route" ref="4220b1b3fd7ca674d8adedb742d71680" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to prevent routing, use local interfaces only. 
<p>
Implements the SOL_SOCKET/SO_DONTROUTE socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="493d09a6a851ec400a30e8f22adb9d74"></a><!-- doxytag: member="asio::basic_datagram_socket::keep_alive" ref="493d09a6a851ec400a30e8f22adb9d74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to send keep-alives. 
<p>
Implements the SOL_SOCKET/SO_KEEPALIVE socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8869a31e4367e9b62c08609dc89591b2"></a><!-- doxytag: member="asio::basic_datagram_socket::send_buffer_size" ref="8869a31e4367e9b62c08609dc89591b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the send buffer size of a socket. 
<p>
Implements the SOL_SOCKET/SO_SNDBUF socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> option(8192);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bff502237f6a2e248e68483e9ca6a0d2"></a><!-- doxytag: member="asio::basic_datagram_socket::send_low_watermark" ref="bff502237f6a2e248e68483e9ca6a0d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the send low watermark. 
<p>
Implements the SOL_SOCKET/SO_SNDLOWAT socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> option(1024);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d79401946636f3e91c1cc66436d1f975"></a><!-- doxytag: member="asio::basic_datagram_socket::receive_buffer_size" ref="d79401946636f3e91c1cc66436d1f975" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the receive buffer size of a socket. 
<p>
Implements the SOL_SOCKET/SO_RCVBUF socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> option(8192);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f487bc8987ef57e2c7469b40bba591a3"></a><!-- doxytag: member="asio::basic_datagram_socket::receive_low_watermark" ref="f487bc8987ef57e2c7469b40bba591a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the receive low watermark. 
<p>
Implements the SOL_SOCKET/SO_RCVLOWAT socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> option(1024);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66ab5649a23766107c5da2a04993d8dc"></a><!-- doxytag: member="asio::basic_datagram_socket::reuse_address" ref="66ab5649a23766107c5da2a04993d8dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to allow the socket to be bound to an address that is already in use. 
<p>
Implements the SOL_SOCKET/SO_REUSEADDR socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> option(<span class="keyword">true</span>);
 acceptor.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> option;
 acceptor.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="308e86dd1ee896dd26c07abf7e6ff1b5"></a><!-- doxytag: member="asio::basic_datagram_socket::linger" ref="308e86dd1ee896dd26c07abf7e6ff1b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to specify whether the socket lingers on close if unsent data is present. 
<p>
Implements the SOL_SOCKET/SO_LINGER socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> option(<span class="keyword">true</span>, 30);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.enabled();
 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> timeout = option.timeout();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Linger_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ef00aa2ca23006e9868f2ea46223aea"></a><!-- doxytag: member="asio::basic_datagram_socket::enable_connection_aborted" ref="9ef00aa2ca23006e9868f2ea46223aea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to report aborted connections on accept. 
<p>
Implements a custom socket option that determines whether or not an accept operation is permitted to fail with <a class="el" href="a00029.html#9bf2f12d5c023d03e276df42b9572d16">asio::error::connection_aborted</a>. By default the option is false.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a> option(<span class="keyword">true</span>);
 acceptor.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a> option;
 acceptor.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28512bf41a5983383e0f5968c6e0580d"></a><!-- doxytag: member="asio::basic_datagram_socket::non_blocking_io" ref="28512bf41a5983383e0f5968c6e0580d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IO control command to set the blocking mode of the socket. 
<p>
Implements the FIONBIO IO control command.<p>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a> command(<span class="keyword">true</span>);
 socket.io_control(command);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>IO_Control_Command, Boolean_IO_Control_Command. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bbde8e590fbb98dfa1685b9d435cb5dc"></a><!-- doxytag: member="asio::basic_datagram_socket::bytes_readable" ref="bbde8e590fbb98dfa1685b9d435cb5dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IO control command to get the amount of data that can be read without blocking. 
<p>
Implements the FIONREAD IO control command.<p>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a> command(<span class="keyword">true</span>);
 socket.io_control(command);
 std::size_t <a class="code" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">bytes_readable</a> = command.get();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>IO_Control_Command, Size_IO_Control_Command. </dd></dl>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="915e52ff147efd296350bba81f795c37"></a><!-- doxytag: member="asio::basic_datagram_socket::shutdown_type" ref="915e52ff147efd296350bba81f795c37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">asio::socket_base::shutdown_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Different ways a socket may be shutdown. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b"></a><!-- doxytag: member="shutdown_receive" ref="915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b" args="" -->shutdown_receive</em>&nbsp;</td><td>
Shutdown the receive side of the socket. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62"></a><!-- doxytag: member="shutdown_send" ref="915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62" args="" -->shutdown_send</em>&nbsp;</td><td>
Shutdown the send side of the socket. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd"></a><!-- doxytag: member="shutdown_both" ref="915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd" args="" -->shutdown_both</em>&nbsp;</td><td>
Shutdown both send and receive on the socket. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="e77f8c12f6b4b1e79cb46bedc7e7b1f8"></a><!-- doxytag: member="asio::basic_datagram_socket::basic_datagram_socket" ref="e77f8c12f6b4b1e79cb46bedc7e7b1f8" args="(asio::io_service &amp;io_service)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::<a class="el" href="a00005.html">basic_datagram_socket</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="a00005.html">basic_datagram_socket</a> without opening it. 
<p>
This constructor creates a datagram socket without opening it. The <a class="el" href="a00013.html#ddde141b21499e7918c5a93c3cbab1d1">open()</a> function must be called before data can be sent or received on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00032.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00032.html">io_service</a> object that the datagram socket will use to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6f9602b7c0fb440492380d679d2d01d4"></a><!-- doxytag: member="asio::basic_datagram_socket::basic_datagram_socket" ref="6f9602b7c0fb440492380d679d2d01d4" args="(asio::io_service &amp;io_service, const protocol_type &amp;protocol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::<a class="el" href="a00005.html">basic_datagram_socket</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct and open a <a class="el" href="a00005.html">basic_datagram_socket</a>. 
<p>
This constructor creates and opens a datagram socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00032.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00032.html">io_service</a> object that the datagram socket will use to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="caa6d8654677fc051647817017df08da"></a><!-- doxytag: member="asio::basic_datagram_socket::basic_datagram_socket" ref="caa6d8654677fc051647817017df08da" args="(asio::io_service &amp;io_service, const endpoint_type &amp;endpoint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::<a class="el" href="a00005.html">basic_datagram_socket</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="a00005.html">basic_datagram_socket</a>, opening it and binding it to the given local endpoint. 
<p>
This constructor creates a datagram socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00032.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00032.html">io_service</a> object that the datagram socket will use to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the datagram socket will be bound.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cf5e1d7936cad338670ead6ac73d72a0"></a><!-- doxytag: member="asio::basic_datagram_socket::basic_datagram_socket" ref="cf5e1d7936cad338670ead6ac73d72a0" args="(asio::io_service &amp;io_service, const protocol_type &amp;protocol, const native_type &amp;native_socket)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::<a class="el" href="a00005.html">basic_datagram_socket</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#b65a458559daaa97ef48f6ee8ce46276">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#228501b6b2b71c04d77c9cc8ed6dfc76">native_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>native_socket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="a00005.html">basic_datagram_socket</a> on an existing native socket. 
<p>
This constructor creates a datagram socket object to hold an existing native socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00032.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00032.html">io_service</a> object that the datagram socket will use to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>native_socket</em>&nbsp;</td><td>The new underlying socket implementation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1483662cb979a253779299048cbfbc21"></a><!-- doxytag: member="asio::basic_datagram_socket::send" ref="1483662cb979a253779299048cbfbc21" args="(const ConstBufferSequence &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::send           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send some data on a connected socket. 
<p>
This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One ore more data buffers to be sent on the socket.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes sent.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The send operation can only be used with a connected socket. Use the send_to function to send data on an unconnected datagram socket.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To send a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.send(<a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size)); 
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="feafeb0698eb82910ba1dfcaa4194e99"></a><!-- doxytag: member="asio::basic_datagram_socket::send" ref="feafeb0698eb82910ba1dfcaa4194e99" args="(const ConstBufferSequence &amp;buffers, socket_base::message_flags flags)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::send           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send some data on a connected socket. 
<p>
This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One ore more data buffers to be sent on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes sent.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The send operation can only be used with a connected socket. Use the send_to function to send data on an unconnected datagram socket. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a33a1dbe5354de35dd7fa5b8ffc36271"></a><!-- doxytag: member="asio::basic_datagram_socket::send" ref="a33a1dbe5354de35dd7fa5b8ffc36271" args="(const ConstBufferSequence &amp;buffers, socket_base::message_flags flags, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::send           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send some data on a connected socket. 
<p>
This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes sent.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The send operation can only be used with a connected socket. Use the send_to function to send data on an unconnected datagram socket. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ba72c1bc687c8e77d917ebb675d9d3d7"></a><!-- doxytag: member="asio::basic_datagram_socket::async_send" ref="ba72c1bc687c8e77d917ebb675d9d3d7" args="(const ConstBufferSequence &amp;buffers, WriteHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::async_send           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous send on a connected socket. 
<p>
This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred           <span class="comment">// Number of bytes sent.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The async_send operation can only be used with a connected socket. Use the async_send_to function to send data on an unconnected datagram socket.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To send a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.async_send(<a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size), handler);
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ce601fb412f7d379d6470f0154602588"></a><!-- doxytag: member="asio::basic_datagram_socket::async_send" ref="ce601fb412f7d379d6470f0154602588" args="(const ConstBufferSequence &amp;buffers, socket_base::message_flags flags, WriteHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::async_send           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous send on a connected socket. 
<p>
This function is used to send data on the datagram socket. The function call will block until the data has been sent successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred           <span class="comment">// Number of bytes sent.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The async_send operation can only be used with a connected socket. Use the async_send_to function to send data on an unconnected datagram socket. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4ad10cd68bc2738a97c361b6d2c90ea5"></a><!-- doxytag: member="asio::basic_datagram_socket::send_to" ref="4ad10cd68bc2738a97c361b6d2c90ea5" args="(const ConstBufferSequence &amp;buffers, const endpoint_type &amp;destination)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::send_to           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a datagram to the specified endpoint. 
<p>
This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent to the remote endpoint.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>The remote endpoint to which the data will be sent.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes sent.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To send a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00007.html">asio::ip::udp::endpoint</a> destination(
     <a class="code" href="a00001.html#d67f1bd21015fea425f0bd305425ad8e">asio::ip::address::from_string</a>(<span class="stringliteral">"1.2.3.4"</span>), 12345);
 socket.send_to(<a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size), destination);
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b3936498e4100b58a3e4ed5720b6fc1"></a><!-- doxytag: member="asio::basic_datagram_socket::send_to" ref="8b3936498e4100b58a3e4ed5720b6fc1" args="(const ConstBufferSequence &amp;buffers, const endpoint_type &amp;destination, socket_base::message_flags flags)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::send_to           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a datagram to the specified endpoint. 
<p>
This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent to the remote endpoint.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>The remote endpoint to which the data will be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes sent.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f7ce556323d73182c473a049050298fd"></a><!-- doxytag: member="asio::basic_datagram_socket::send_to" ref="f7ce556323d73182c473a049050298fd" args="(const ConstBufferSequence &amp;buffers, const endpoint_type &amp;destination, socket_base::message_flags flags, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::send_to           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a datagram to the specified endpoint. 
<p>
This function is used to send a datagram to the specified remote endpoint. The function call will block until the data has been sent successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent to the remote endpoint.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>The remote endpoint to which the data will be sent.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes sent. </dd></dl>

</div>
</div><p>
<a class="anchor" name="684892ec806755c38810e2733950d609"></a><!-- doxytag: member="asio::basic_datagram_socket::async_send_to" ref="684892ec806755c38810e2733950d609" args="(const ConstBufferSequence &amp;buffers, const endpoint_type &amp;destination, WriteHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::async_send_to           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous send. 
<p>
This function is used to asynchronously send a datagram to the specified remote endpoint. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred           <span class="comment">// Number of bytes sent.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To send a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00007.html">asio::ip::udp::endpoint</a> destination(
     <a class="code" href="a00001.html#d67f1bd21015fea425f0bd305425ad8e">asio::ip::address::from_string</a>(<span class="stringliteral">"1.2.3.4"</span>), 12345);
 socket.async_send_to(
     <a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size), destination, handler);
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="566c61113248013b5c11d7a31c0b7a0d"></a><!-- doxytag: member="asio::basic_datagram_socket::async_send_to" ref="566c61113248013b5c11d7a31c0b7a0d" args="(const ConstBufferSequence &amp;buffers, const endpoint_type &amp;destination, socket_base::message_flags flags, WriteHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename ConstBufferSequence, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::async_send_to           </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous send. 
<p>
This function is used to asynchronously send a datagram to the specified remote endpoint. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent to the remote endpoint. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>The remote endpoint to which the data will be sent. Copies will be made of the endpoint as required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the send operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred           <span class="comment">// Number of bytes sent.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="87bf840e8e13167e9026df9f190607a5"></a><!-- doxytag: member="asio::basic_datagram_socket::receive" ref="87bf840e8e13167e9026df9f190607a5" args="(const MutableBufferSequence &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::receive           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive some data on a connected socket. 
<p>
This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The receive operation can only be used with a connected socket. Use the receive_from function to receive data on an unconnected datagram socket.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To receive into a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.receive(<a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size)); 
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e533a17a81bc230e591995a433640751"></a><!-- doxytag: member="asio::basic_datagram_socket::receive" ref="e533a17a81bc230e591995a433640751" args="(const MutableBufferSequence &amp;buffers, socket_base::message_flags flags)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::receive           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive some data on a connected socket. 
<p>
This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The receive operation can only be used with a connected socket. Use the receive_from function to receive data on an unconnected datagram socket. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c650bfd118f390d43aee99527bae2743"></a><!-- doxytag: member="asio::basic_datagram_socket::receive" ref="c650bfd118f390d43aee99527bae2743" args="(const MutableBufferSequence &amp;buffers, socket_base::message_flags flags, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::receive           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive some data on a connected socket. 
<p>
This function is used to receive data on the datagram socket. The function call will block until data has been received successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The receive operation can only be used with a connected socket. Use the receive_from function to receive data on an unconnected datagram socket. </dd></dl>

</div>
</div><p>
<a class="anchor" name="742d08afc6458b27dc803da1ff3c391d"></a><!-- doxytag: member="asio::basic_datagram_socket::async_receive" ref="742d08afc6458b27dc803da1ff3c391d" args="(const MutableBufferSequence &amp;buffers, ReadHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::async_receive           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous receive on a connected socket. 
<p>
This function is used to asynchronously receive data from the datagram socket. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred           <span class="comment">// Number of bytes received.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The async_receive operation can only be used with a connected socket. Use the async_receive_from function to receive data on an unconnected datagram socket.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To receive into a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.async_receive(<a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size), handler);
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2b3c24ab7adc78b8e7f4caee528b313c"></a><!-- doxytag: member="asio::basic_datagram_socket::async_receive" ref="2b3c24ab7adc78b8e7f4caee528b313c" args="(const MutableBufferSequence &amp;buffers, socket_base::message_flags flags, ReadHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::async_receive           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous receive on a connected socket. 
<p>
This function is used to asynchronously receive data from the datagram socket. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred           <span class="comment">// Number of bytes received.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The async_receive operation can only be used with a connected socket. Use the async_receive_from function to receive data on an unconnected datagram socket. </dd></dl>

</div>
</div><p>
<a class="anchor" name="994ea38ff4c08abeacd663a4d1d9b72d"></a><!-- doxytag: member="asio::basic_datagram_socket::receive_from" ref="994ea38ff4c08abeacd663a4d1d9b72d" args="(const MutableBufferSequence &amp;buffers, endpoint_type &amp;sender_endpoint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::receive_from           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sender_endpoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a datagram with the endpoint of the sender. 
<p>
This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sender_endpoint</em>&nbsp;</td><td>An endpoint object that receives the endpoint of the remote sender of the datagram.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To receive into a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00007.html">asio::ip::udp::endpoint</a> sender_endpoint;
 socket.receive_from(
     <a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size), sender_endpoint);
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7ef49c92a27a4b98b4a107c943b599a"></a><!-- doxytag: member="asio::basic_datagram_socket::receive_from" ref="d7ef49c92a27a4b98b4a107c943b599a" args="(const MutableBufferSequence &amp;buffers, endpoint_type &amp;sender_endpoint, socket_base::message_flags flags)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::receive_from           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sender_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a datagram with the endpoint of the sender. 
<p>
This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sender_endpoint</em>&nbsp;</td><td>An endpoint object that receives the endpoint of the remote sender of the datagram.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0b62c17f90b8d0c8c3910dc627914402"></a><!-- doxytag: member="asio::basic_datagram_socket::receive_from" ref="0b62c17f90b8d0c8c3910dc627914402" args="(const MutableBufferSequence &amp;buffers, endpoint_type &amp;sender_endpoint, socket_base::message_flags flags, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::receive_from           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sender_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive a datagram with the endpoint of the sender. 
<p>
This function is used to receive a datagram. The function call will block until data has been received successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sender_endpoint</em>&nbsp;</td><td>An endpoint object that receives the endpoint of the remote sender of the datagram.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes received. </dd></dl>

</div>
</div><p>
<a class="anchor" name="873d734eea489acbe03a3302934fb89d"></a><!-- doxytag: member="asio::basic_datagram_socket::async_receive_from" ref="873d734eea489acbe03a3302934fb89d" args="(const MutableBufferSequence &amp;buffers, endpoint_type &amp;sender_endpoint, ReadHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::async_receive_from           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sender_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous receive. 
<p>
This function is used to asynchronously receive a datagram. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sender_endpoint</em>&nbsp;</td><td>An endpoint object that receives the endpoint of the remote sender of the datagram. Ownership of the sender_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00050.html">asio::system_error</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred             <span class="comment">// Number of bytes received.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To receive into a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.async_receive_from(
     <a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size), 0, sender_endpoint, handler); 
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d7331d226f03efda6be1235d385584a2"></a><!-- doxytag: member="asio::basic_datagram_socket::async_receive_from" ref="d7331d226f03efda6be1235d385584a2" args="(const MutableBufferSequence &amp;buffers, endpoint_type &amp;sender_endpoint, socket_base::message_flags flags, ReadHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename DatagramSocketService = datagram_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename MutableBufferSequence, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">asio::basic_datagram_socket</a>&lt; Protocol, DatagramSocketService &gt;::async_receive_from           </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>sender_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">socket_base::message_flags</a>&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous receive. 
<p>
This function is used to asynchronously receive a datagram. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sender_endpoint</em>&nbsp;</td><td>An endpoint object that receives the endpoint of the remote sender of the datagram. Ownership of the sender_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the receive operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred           <span class="comment">// Number of bytes received.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cd1a03601cf874d77169f9294e6ebad4"></a><!-- doxytag: member="asio::basic_datagram_socket::lowest_layer" ref="cd1a03601cf874d77169f9294e6ebad4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">lowest_layer_type</a>&amp; <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::lowest_layer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a reference to the lowest layer. 
<p>
This function returns a reference to the lowest layer in a stack of layers. Since a <a class="el" href="a00013.html">basic_socket</a> cannot contain any further layers, it simply returns a reference to itself.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ddde141b21499e7918c5a93c3cbab1d1"></a><!-- doxytag: member="asio::basic_datagram_socket::open" ref="ddde141b21499e7918c5a93c3cbab1d1" args="(const protocol_type &amp;protocol=protocol_type())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::open           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em> = <code><a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a>()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the socket using the specified protocol. 
<p>
This function opens the socket so that it will use the specified protocol.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 socket.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cd7189fb57ad92321affbae2e7bcd01"></a><!-- doxytag: member="asio::basic_datagram_socket::open" ref="9cd7189fb57ad92321affbae2e7bcd01" args="(const protocol_type &amp;protocol, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::open           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the socket using the specified protocol. 
<p>
This function opens the socket so that it will use the specified protocol.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="452fbce78dff7c03c9906daa27d4163b"></a><!-- doxytag: member="asio::basic_datagram_socket::assign" ref="452fbce78dff7c03c9906daa27d4163b" args="(const protocol_type &amp;protocol, const native_type &amp;native_socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>native_socket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign an existing native socket to the socket. 
<p>

</div>
</div><p>
<a class="anchor" name="21d132e623b0f1b9eb6af15e60e9aef4"></a><!-- doxytag: member="asio::basic_datagram_socket::assign" ref="21d132e623b0f1b9eb6af15e60e9aef4" args="(const protocol_type &amp;protocol, const native_type &amp;native_socket, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign an existing native socket to the socket. 
<p>

</div>
</div><p>
<a class="anchor" name="d18a1f2f159d0d99aa088df9e58d1cfc"></a><!-- doxytag: member="asio::basic_datagram_socket::is_open" ref="d18a1f2f159d0d99aa088df9e58d1cfc" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::is_open           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the socket is open. 
<p>

</div>
</div><p>
<a class="anchor" name="ecb8346a5bc290e394a055b7d9164c0f"></a><!-- doxytag: member="asio::basic_datagram_socket::close" ref="ecb8346a5bc290e394a055b7d9164c0f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the socket. 
<p>
This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3fa404892b34feff1f8e013ab7c3e7ee"></a><!-- doxytag: member="asio::basic_datagram_socket::close" ref="3fa404892b34feff1f8e013ab7c3e7ee" args="(asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the socket. 
<p>
This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.close(ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e65e3e73aa11b017d355d902e9b6ddc"></a><!-- doxytag: member="asio::basic_datagram_socket::native" ref="9e65e3e73aa11b017d355d902e9b6ddc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html#228501b6b2b71c04d77c9cc8ed6dfc76">native_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::native           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the native socket representation. 
<p>
This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 
</div>
</div><p>
<a class="anchor" name="8c93c7f90a9c2b44e1bedfa8f2fe63c8"></a><!-- doxytag: member="asio::basic_datagram_socket::cancel" ref="8c93c7f90a9c2b44e1bedfa8f2fe63c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::cancel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel all asynchronous operations associated with the socket. 
<p>
This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1128f1e16ef26eb7fa9328548a2a08e9"></a><!-- doxytag: member="asio::basic_datagram_socket::cancel" ref="1128f1e16ef26eb7fa9328548a2a08e9" args="(asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::cancel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel all asynchronous operations associated with the socket. 
<p>
This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="11fefda4db8247c58ada119040daedbe"></a><!-- doxytag: member="asio::basic_datagram_socket::at_mark" ref="11fefda4db8247c58ada119040daedbe" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::at_mark           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the socket is at the out-of-band data mark. 
<p>
This function is used to check whether the socket input is currently positioned at the out-of-band data mark.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A bool indicating whether the socket is at the out-of-band data mark.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2fb2030562128667c88fe5f8cf613aa3"></a><!-- doxytag: member="asio::basic_datagram_socket::at_mark" ref="2fb2030562128667c88fe5f8cf613aa3" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::at_mark           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the socket is at the out-of-band data mark. 
<p>
This function is used to check whether the socket input is currently positioned at the out-of-band data mark.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A bool indicating whether the socket is at the out-of-band data mark. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1464a056487487ba19ac2a7ce633ffac"></a><!-- doxytag: member="asio::basic_datagram_socket::available" ref="1464a056487487ba19ac2a7ce633ffac" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::available           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the number of bytes available for reading. 
<p>
This function is used to determine the number of bytes that may be read without blocking.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f32340508e7c17e124418ebd1f48a0e4"></a><!-- doxytag: member="asio::basic_datagram_socket::available" ref="f32340508e7c17e124418ebd1f48a0e4" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::available           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the number of bytes available for reading. 
<p>
This function is used to determine the number of bytes that may be read without blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29f2660dcb63871f6ac50e5be2545194"></a><!-- doxytag: member="asio::basic_datagram_socket::bind" ref="29f2660dcb63871f6ac50e5be2545194" args="(const endpoint_type &amp;endpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::bind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind the socket to the given local endpoint. 
<p>
This function binds the socket to the specified endpoint on the local machine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 socket.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
 socket.bind(<a class="code" href="a00007.html">asio::ip::tcp::endpoint</a>(
       <a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), 12345));
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b65419efd4f773417c53221070d5a59"></a><!-- doxytag: member="asio::basic_datagram_socket::bind" ref="7b65419efd4f773417c53221070d5a59" args="(const endpoint_type &amp;endpoint, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::bind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind the socket to the given local endpoint. 
<p>
This function binds the socket to the specified endpoint on the local machine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 socket.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.bind(<a class="code" href="a00007.html">asio::ip::tcp::endpoint</a>(
       <a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), 12345), ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c3c66c10841897d56e75799e81d7f319"></a><!-- doxytag: member="asio::basic_datagram_socket::connect" ref="c3c66c10841897d56e75799e81d7f319" args="(const endpoint_type &amp;peer_endpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>peer_endpoint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect the socket to the specified endpoint. 
<p>
This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.<p>
The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is returned to the closed state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>The remote endpoint to which the socket will be connected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint(
     <a class="code" href="a00001.html#d67f1bd21015fea425f0bd305425ad8e">asio::ip::address::from_string</a>(<span class="stringliteral">"1.2.3.4"</span>), 12345);
 socket.connect(endpoint);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f590780830e8f00925fd07ebaa9e71b"></a><!-- doxytag: member="asio::basic_datagram_socket::connect" ref="9f590780830e8f00925fd07ebaa9e71b" args="(const endpoint_type &amp;peer_endpoint, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect the socket to the specified endpoint. 
<p>
This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.<p>
The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is returned to the closed state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>The remote endpoint to which the socket will be connected.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint(
     <a class="code" href="a00001.html#d67f1bd21015fea425f0bd305425ad8e">asio::ip::address::from_string</a>(<span class="stringliteral">"1.2.3.4"</span>), 12345);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.connect(endpoint, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="13862c86b40404249dc2ad54dbb81271"></a><!-- doxytag: member="asio::basic_datagram_socket::async_connect" ref="13862c86b40404249dc2ad54dbb81271" args="(const endpoint_type &amp;peer_endpoint, ConnectHandler handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::async_connect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous connect. 
<p>
This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.<p>
The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is returned to the closed state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> connect_handler(<span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error)
 {
   <span class="keywordflow">if</span> (!error)
   {
     <span class="comment">// Connect succeeded.</span>
   }
 }

 ...

 <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint(
     <a class="code" href="a00001.html#d67f1bd21015fea425f0bd305425ad8e">asio::ip::address::from_string</a>(<span class="stringliteral">"1.2.3.4"</span>), 12345);
 socket.async_connect(endpoint, connect_handler);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f040b3c66c466f4184b690bb6904a3f3"></a><!-- doxytag: member="asio::basic_datagram_socket::set_option" ref="f040b3c66c466f4184b690bb6904a3f3" args="(const SettableSocketOption &amp;option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::set_option           </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an option on the socket. 
<p>
This function is used to set an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The new option value to be set on the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>SettableSocketOption <br>
 <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> <br>
 <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> <br>
 <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> <br>
 <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> <br>
 <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> <br>
 <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <br>
 <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> <br>
 <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> <br>
 <a class="el" href="a00128.html#b9ef02d2f76ab2a904ad0008aa9b9afc">asio::ip::multicast::join_group</a> <br>
 <a class="el" href="a00128.html#6dfad4ffefcbddd1be19c1518ab4f8eb">asio::ip::multicast::leave_group</a> <br>
 <a class="el" href="a00128.html#a0a6359db040928c26ec5f66ded5cb58">asio::ip::multicast::enable_loopback</a> <br>
 <a class="el" href="a00128.html#ecc5b43cb6820baa08f008400b0dbef6">asio::ip::multicast::outbound_interface</a> <br>
 <a class="el" href="a00128.html#9054deaca4a61e75e872292d9ba98e97">asio::ip::multicast::hops</a> <br>
 <a class="el" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e42c5d5d6779b68fa068032814a969da"></a><!-- doxytag: member="asio::basic_datagram_socket::set_option" ref="e42c5d5d6779b68fa068032814a969da" args="(const SettableSocketOption &amp;option, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::set_option           </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an option on the socket. 
<p>
This function is used to set an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The new option value to be set on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>SettableSocketOption <br>
 <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> <br>
 <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> <br>
 <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> <br>
 <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> <br>
 <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> <br>
 <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <br>
 <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> <br>
 <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> <br>
 <a class="el" href="a00128.html#b9ef02d2f76ab2a904ad0008aa9b9afc">asio::ip::multicast::join_group</a> <br>
 <a class="el" href="a00128.html#6dfad4ffefcbddd1be19c1518ab4f8eb">asio::ip::multicast::leave_group</a> <br>
 <a class="el" href="a00128.html#a0a6359db040928c26ec5f66ded5cb58">asio::ip::multicast::enable_loopback</a> <br>
 <a class="el" href="a00128.html#ecc5b43cb6820baa08f008400b0dbef6">asio::ip::multicast::outbound_interface</a> <br>
 <a class="el" href="a00128.html#9054deaca4a61e75e872292d9ba98e97">asio::ip::multicast::hops</a> <br>
 <a class="el" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a> option(<span class="keyword">true</span>);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.set_option(option, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="88d39aad400fa707d816639402d013b8"></a><!-- doxytag: member="asio::basic_datagram_socket::get_option" ref="88d39aad400fa707d816639402d013b8" args="(GettableSocketOption &amp;option) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::get_option           </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an option from the socket. 
<p>
This function is used to get the current value of an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The option value to be obtained from the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>GettableSocketOption <br>
 <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> <br>
 <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> <br>
 <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> <br>
 <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> <br>
 <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> <br>
 <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <br>
 <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> <br>
 <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> <br>
 <a class="el" href="a00128.html#b9ef02d2f76ab2a904ad0008aa9b9afc">asio::ip::multicast::join_group</a> <br>
 <a class="el" href="a00128.html#6dfad4ffefcbddd1be19c1518ab4f8eb">asio::ip::multicast::leave_group</a> <br>
 <a class="el" href="a00128.html#a0a6359db040928c26ec5f66ded5cb58">asio::ip::multicast::enable_loopback</a> <br>
 <a class="el" href="a00128.html#ecc5b43cb6820baa08f008400b0dbef6">asio::ip::multicast::outbound_interface</a> <br>
 <a class="el" href="a00128.html#9054deaca4a61e75e872292d9ba98e97">asio::ip::multicast::hops</a> <br>
 <a class="el" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::ip::tcp::socket::keep_alive</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c40f85557f13e0e946a9b0395f9c313"></a><!-- doxytag: member="asio::basic_datagram_socket::get_option" ref="8c40f85557f13e0e946a9b0395f9c313" args="(GettableSocketOption &amp;option, asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::get_option           </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an option from the socket. 
<p>
This function is used to get the current value of an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The option value to be obtained from the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>GettableSocketOption <br>
 <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> <br>
 <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> <br>
 <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> <br>
 <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> <br>
 <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> <br>
 <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <br>
 <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> <br>
 <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> <br>
 <a class="el" href="a00128.html#b9ef02d2f76ab2a904ad0008aa9b9afc">asio::ip::multicast::join_group</a> <br>
 <a class="el" href="a00128.html#6dfad4ffefcbddd1be19c1518ab4f8eb">asio::ip::multicast::leave_group</a> <br>
 <a class="el" href="a00128.html#a0a6359db040928c26ec5f66ded5cb58">asio::ip::multicast::enable_loopback</a> <br>
 <a class="el" href="a00128.html#ecc5b43cb6820baa08f008400b0dbef6">asio::ip::multicast::outbound_interface</a> <br>
 <a class="el" href="a00128.html#9054deaca4a61e75e872292d9ba98e97">asio::ip::multicast::hops</a> <br>
 <a class="el" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::ip::tcp::socket::keep_alive</a> option;
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.get_option(option, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
 <span class="keywordtype">bool</span> is_set = option.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4fb5d33d2ebee7fc119c3060ab258cde"></a><!-- doxytag: member="asio::basic_datagram_socket::io_control" ref="4fb5d33d2ebee7fc119c3060ab258cde" args="(IoControlCommand &amp;command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::io_control           </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform an IO control command on the socket. 
<p>
This function is used to execute an IO control command on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>The IO control command to be performed on the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>IoControlCommand <br>
 <a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a> <br>
 <a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the number of bytes ready to read: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::ip::tcp::socket::bytes_readable</a> command;
 socket.io_control(command);
 std::size_t bytes_readable = command.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6fa2182e4e122c5e1a1a5c960ef41180"></a><!-- doxytag: member="asio::basic_datagram_socket::io_control" ref="6fa2182e4e122c5e1a1a5c960ef41180" args="(IoControlCommand &amp;command, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::io_control           </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform an IO control command on the socket. 
<p>
This function is used to execute an IO control command on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>The IO control command to be performed on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>IoControlCommand <br>
 <a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a> <br>
 <a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the number of bytes ready to read: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::ip::tcp::socket::bytes_readable</a> command;
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.io_control(command, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
 std::size_t bytes_readable = command.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="efb7bdafc26eb3dd3b1a8c0559947754"></a><!-- doxytag: member="asio::basic_datagram_socket::local_endpoint" ref="efb7bdafc26eb3dd3b1a8c0559947754" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::local_endpoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the local endpoint of the socket. 
<p>
This function is used to obtain the locally bound endpoint of the socket.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the local endpoint of the socket.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = socket.local_endpoint();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2bec75bc112611561d8f13db299d72af"></a><!-- doxytag: member="asio::basic_datagram_socket::local_endpoint" ref="2bec75bc112611561d8f13db299d72af" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::local_endpoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the local endpoint of the socket. 
<p>
This function is used to obtain the locally bound endpoint of the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = socket.local_endpoint(ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a190ca5477b3dcee0d9c9d97a427897a"></a><!-- doxytag: member="asio::basic_datagram_socket::remote_endpoint" ref="a190ca5477b3dcee0d9c9d97a427897a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::remote_endpoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the remote endpoint of the socket. 
<p>
This function is used to obtain the remote endpoint of the socket.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the remote endpoint of the socket.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = socket.remote_endpoint();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="61cc239a1078a1a62589a2abedea8b76"></a><!-- doxytag: member="asio::basic_datagram_socket::remote_endpoint" ref="61cc239a1078a1a62589a2abedea8b76" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html#f952c8d18c85588a16531cfc54a172bb">endpoint_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::remote_endpoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the remote endpoint of the socket. 
<p>
This function is used to obtain the remote endpoint of the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = socket.remote_endpoint(ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8b410b0be483ff3a9c03d67f754f02c"></a><!-- doxytag: member="asio::basic_datagram_socket::shutdown" ref="f8b410b0be483ff3a9c03d67f754f02c" args="(shutdown_type what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::shutdown           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a>&nbsp;</td>
          <td class="paramname"> <em>what</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable sends or receives on the socket. 
<p>
This function is used to disable send operations, receive operations, or both.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>what</em>&nbsp;</td><td>Determines what types of operation will no longer be allowed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Shutting down the send side of the socket: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 socket.shutdown(<a class="code" href="a00045.html#915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62">asio::ip::tcp::socket::shutdown_send</a>);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7f07b5990a61e483ab24862912e695ae"></a><!-- doxytag: member="asio::basic_datagram_socket::shutdown" ref="7f07b5990a61e483ab24862912e695ae" args="(shutdown_type what, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , DatagramSocketService  &gt;::shutdown           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a>&nbsp;</td>
          <td class="paramname"> <em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable sends or receives on the socket. 
<p>
This function is used to disable send operations, receive operations, or both.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>what</em>&nbsp;</td><td>Determines what types of operation will no longer be allowed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Shutting down the send side of the socket: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(<a class="code" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a>);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.shutdown(<a class="code" href="a00045.html#915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62">asio::ip::tcp::socket::shutdown_send</a>, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5208e056c92fa6130114d023a5bd8b0"></a><!-- doxytag: member="asio::basic_datagram_socket::io_service" ref="e5208e056c92fa6130114d023a5bd8b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00032.html">asio::io_service</a>&amp; <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; DatagramSocketService  &gt;::<a class="el" href="a00032.html">io_service</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="a00032.html">io_service</a> associated with the object. 
<p>
This function may be used to obtain the <a class="el" href="a00032.html">io_service</a> object that the I/O object uses to dispatch handlers for asynchronous operations.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the <a class="el" href="a00032.html">io_service</a> object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="356e1bd7da0353e5472028cdec742ed0"></a><!-- doxytag: member="asio::basic_datagram_socket::message_peek" ref="356e1bd7da0353e5472028cdec742ed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#356e1bd7da0353e5472028cdec742ed0">asio::socket_base::message_peek</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Peek at incoming data without removing it from the input queue. 
<p>

</div>
</div><p>
<a class="anchor" name="b9f08ba445b7ce09ece5ac7beaa6e7c9"></a><!-- doxytag: member="asio::basic_datagram_socket::message_out_of_band" ref="b9f08ba445b7ce09ece5ac7beaa6e7c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#b9f08ba445b7ce09ece5ac7beaa6e7c9">asio::socket_base::message_out_of_band</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process out-of-band data. 
<p>

</div>
</div><p>
<a class="anchor" name="e27428a48d1a7113a95ea205b1e17978"></a><!-- doxytag: member="asio::basic_datagram_socket::message_do_not_route" ref="e27428a48d1a7113a95ea205b1e17978" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#e27428a48d1a7113a95ea205b1e17978">asio::socket_base::message_do_not_route</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify that the data should not be subject to routing. 
<p>

</div>
</div><p>
<a class="anchor" name="85ee2a3ce0ec68ac8c026884c5bd3098"></a><!-- doxytag: member="asio::basic_datagram_socket::max_connections" ref="85ee2a3ce0ec68ac8c026884c5bd3098" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">asio::socket_base::max_connections</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The maximum length of the queue of pending incoming connections. 
<p>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc2</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
