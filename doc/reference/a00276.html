<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::async_read_until</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1>asio::async_read_until</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Allocator, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#ga8436a772555e39eadd00fcaaa851d27">asio::async_read_until</a> (<a class="el" href="a00102.html">Async_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until a delimiter is encountered.  <a href="#ga8436a772555e39eadd00fcaaa851d27"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Allocator, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g0d3e0e921716e4bee8cd9aa386a4d116">asio::async_read_until</a> (<a class="el" href="a00102.html">Async_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until a regular expression is located.  <a href="#g0d3e0e921716e4bee8cd9aa386a4d116"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga8436a772555e39eadd00fcaaa851d27"></a><!-- doxytag: member="asio::async_read_until" ref="ga8436a772555e39eadd00fcaaa851d27" args="(Async_Read_Stream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, char delim, Handler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Async_Read_Stream, typename Allocator, typename Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_read_until           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00102.html">Async_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to read data into a streambuf until a delimiter is encountered. 
<p>
This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's async_read_some function. If the streambuf's get area already contains the delimiter, the asynchronous operation completes immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00102.html">Async_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Async_Read_Stream::error_type</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred               <span class="comment">// The number of bytes in the</span>
                                               <span class="comment">// streambuf's get area up to</span>
                                               <span class="comment">// and including the delimiter.</span>
                                               <span class="comment">// 0 if an error occurred.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00140.html#9cd4ea280c4cb0d4748173f57cadfccb">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Example:</b></dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><pre class="fragment"> <a class="code" href="a00119.html">asio::streambuf</a> b;
 ...
 <span class="keywordtype">void</span> handler(<span class="keyword">const</span> <a class="code" href="a00135.html">asio::error</a>&amp; e, std::size_t size)
 {
   <span class="keywordflow">if</span> (!e)
   {
     std::istream is(&amp;b);
     std::string line;
     std::getline(is, line);
     ...
   }
 }
 ...
 <a class="code" href="a00276.html#ga8436a772555e39eadd00fcaaa851d27">asio::async_read_until</a>(s, b, <span class="charliteral">'\n'</span>, handler); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0d3e0e921716e4bee8cd9aa386a4d116"></a><!-- doxytag: member="asio::async_read_until" ref="g0d3e0e921716e4bee8cd9aa386a4d116" args="(Async_Read_Stream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, Handler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Async_Read_Stream, typename Allocator, typename Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_read_until           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00102.html">Async_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to read data into a streambuf until a regular expression is located. 
<p>
This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>A substring of the streambuf's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's async_read_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00102.html">Async_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The regular expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Async_Read_Stream::error_type</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred               <span class="comment">// The number of bytes in the</span>
                                               <span class="comment">// streambuf's get area up to</span>
                                               <span class="comment">// and including the substring</span>
                                               <span class="comment">// that matches the regular</span>
                                               <span class="comment">// expression. 0 if an error</span>
                                               <span class="comment">// occurred.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00140.html#9cd4ea280c4cb0d4748173f57cadfccb">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Example:</b></dt><dd>To asynchronously read data into a streambuf until a CR-LF sequence is encountered: <div class="fragment"><pre class="fragment"> <a class="code" href="a00119.html">asio::streambuf</a> b;
 ...
 <span class="keywordtype">void</span> handler(<span class="keyword">const</span> <a class="code" href="a00135.html">asio::error</a>&amp; e, std::size_t size)
 {
   <span class="keywordflow">if</span> (!e)
   {
     std::istream is(&amp;b);
     std::string line;
     std::getline(is, line);
     ...
   }
 }
 ...
 <a class="code" href="a00276.html#ga8436a772555e39eadd00fcaaa851d27">asio::async_read_until</a>(s, b, boost::regex(<span class="stringliteral">"\r\n"</span>), handler); 
</pre></div> </dd></dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
