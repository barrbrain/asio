<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::basic_resolver&lt; Protocol, Service &gt; Class Template Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<div class="nav">
<a class="el" href="a00262.html">asio</a>::<a class="el" href="a00109.html">basic_resolver</a></div>
<h1>asio::basic_resolver&lt; Protocol, Service &gt; Class Template Reference</h1><!-- doxytag: class="asio::basic_resolver" --><!-- doxytag: inherits="asio::basic_io_object" -->Inherits <a class="el" href="a00108.html">asio::basic_io_object&lt; Service &gt;&lt; Service &gt;</a>.
<p>
Inheritance diagram for asio::basic_resolver&lt; Protocol, Service &gt;:<p><center><img src="a00323.png" border="0" usemap="#a00324" alt="Inheritance graph"></center>
<map name="a00324">
<area href="a00108.html" shape="rect" coords="41,82,334,109" alt="">
<area doxygen="external.doxytags:" href="noncopyable.html" shape="rect" coords="125,8,250,34" alt="">
</map>
<a href="a00006.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt;<br>
 class asio::basic_resolver&lt; Protocol, Service &gt;</h3>

Provides endpoint resolution functionality. 
<p>
The <a class="el" href="a00109.html">basic_resolver</a> class template provides the ability to resolve a query to a list of endpoints.<p>
<dl compact><dt><b>Thread Safety:</b></dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br>
 <em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl compact><dt><b>Concepts:</b></dt><dd><a class="el" href="a00101.html">Async_Object</a>, <a class="el" href="a00136.html">Error_Source</a>. </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00151.html">Protocol</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#be3aa74bc7e3b541523b3bf10ac30cd2">protocol_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The protocol type.  <a href="#be3aa74bc7e3b541523b3bf10ac30cd2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol::endpoint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#9f5857f766a26a6964b97e18f3b55852">endpoint_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The endpoint type.  <a href="#9f5857f766a26a6964b97e18f3b55852"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol::resolver_query&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#688ee769f0eae3691bf65d0e91fffba7">query</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The query type.  <a href="#688ee769f0eae3691bf65d0e91fffba7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol::resolver_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The iterator type.  <a href="#4d8fef02de5e7db6dd1614f3d8325ea3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00135.html">asio::error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#096a650e317797d7e0f228896c16bfa1">error_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type used for reporting errors.  <a href="#096a650e317797d7e0f228896c16bfa1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Service&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#6f5cde5fe7b2e0a8e6f96f08584d2aa5">service_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the service that will be used to provide I/O operations.  <a href="#6f5cde5fe7b2e0a8e6f96f08584d2aa5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef service_type::implementation_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#b72f7245597ff283525d80bf0ffa52fb">implementation_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying implementation type of I/O object.  <a href="#b72f7245597ff283525d80bf0ffa52fb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#4de12e4d1be36feab272c949bf8a7166">basic_resolver</a> (<a class="el" href="a00140.html">asio::io_service</a> &amp;<a class="el" href="a00140.html">io_service</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#4de12e4d1be36feab272c949bf8a7166"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a16fba9d23b53e375216e1108e209442">cancel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel any asynchronous operations that are waiting on the resolver.  <a href="#a16fba9d23b53e375216e1108e209442"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#2ff03ba9608236e2111c03ea16410b1b">resolve</a> (const <a class="el" href="a00109.html#688ee769f0eae3691bf65d0e91fffba7">query</a> &amp;q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a query to a list of entries.  <a href="#2ff03ba9608236e2111c03ea16410b1b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#f5e472c28fa363144b6f24cbabd60184">resolve</a> (const <a class="el" href="a00109.html#688ee769f0eae3691bf65d0e91fffba7">query</a> &amp;q, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve a query to a list of entries.  <a href="#f5e472c28fa363144b6f24cbabd60184"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#2659f5d6a62356bb48466e6a5cf568cb">async_resolve</a> (const <a class="el" href="a00109.html#688ee769f0eae3691bf65d0e91fffba7">query</a> &amp;q, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronously resolve a query to a list of entries.  <a href="#2659f5d6a62356bb48466e6a5cf568cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#f15964665734f6940c9842ef3d60455a">resolve</a> (const <a class="el" href="a00109.html#9f5857f766a26a6964b97e18f3b55852">endpoint_type</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve an endpoint to a list of entries.  <a href="#f15964665734f6940c9842ef3d60455a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#e79c5cc08dca177c0954b7d87fbc32f6">resolve</a> (const <a class="el" href="a00109.html#9f5857f766a26a6964b97e18f3b55852">endpoint_type</a> &amp;e, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resolve an endpoint to a list of entries.  <a href="#e79c5cc08dca177c0954b7d87fbc32f6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#16254d96706f08ae91bcf682ce9b4a02">async_resolve</a> (const <a class="el" href="a00109.html#9f5857f766a26a6964b97e18f3b55852">endpoint_type</a> &amp;e, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronously resolve an endpoint to a list of entries.  <a href="#16254d96706f08ae91bcf682ce9b4a02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00140.html">asio::io_service</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#07646b3fbab85fb0e438a8a651461881">io_service</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="a00140.html">io_service</a> associated with the object.  <a href="#07646b3fbab85fb0e438a8a651461881"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="be3aa74bc7e3b541523b3bf10ac30cd2"></a><!-- doxytag: member="asio::basic_resolver::protocol_type" ref="be3aa74bc7e3b541523b3bf10ac30cd2" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00151.html">Protocol</a> <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::<a class="el" href="a00151.html">protocol_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The protocol type. 
<p>

</div>
</div><p>
<a class="anchor" name="9f5857f766a26a6964b97e18f3b55852"></a><!-- doxytag: member="asio::basic_resolver::endpoint_type" ref="9f5857f766a26a6964b97e18f3b55852" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::<a class="el" href="a00109.html#9f5857f766a26a6964b97e18f3b55852">endpoint_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The endpoint type. 
<p>

</div>
</div><p>
<a class="anchor" name="688ee769f0eae3691bf65d0e91fffba7"></a><!-- doxytag: member="asio::basic_resolver::query" ref="688ee769f0eae3691bf65d0e91fffba7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::resolver_query <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::<a class="el" href="a00109.html#688ee769f0eae3691bf65d0e91fffba7">query</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The query type. 
<p>

</div>
</div><p>
<a class="anchor" name="4d8fef02de5e7db6dd1614f3d8325ea3"></a><!-- doxytag: member="asio::basic_resolver::iterator" ref="4d8fef02de5e7db6dd1614f3d8325ea3" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::resolver_iterator <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::<a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The iterator type. 
<p>

</div>
</div><p>
<a class="anchor" name="096a650e317797d7e0f228896c16bfa1"></a><!-- doxytag: member="asio::basic_resolver::error_type" ref="096a650e317797d7e0f228896c16bfa1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00135.html">asio::error</a> <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::<a class="el" href="a00135.html">error_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type used for reporting errors. 
<p>

</div>
</div><p>
<a class="anchor" name="6f5cde5fe7b2e0a8e6f96f08584d2aa5"></a><!-- doxytag: member="asio::basic_resolver::service_type" ref="6f5cde5fe7b2e0a8e6f96f08584d2aa5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Service <a class="el" href="a00108.html">asio::basic_io_object</a>&lt; Service &gt;::<a class="el" href="a00108.html#6f5cde5fe7b2e0a8e6f96f08584d2aa5">service_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of the service that will be used to provide I/O operations. 
<p>

</div>
</div><p>
<a class="anchor" name="b72f7245597ff283525d80bf0ffa52fb"></a><!-- doxytag: member="asio::basic_resolver::implementation_type" ref="b72f7245597ff283525d80bf0ffa52fb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef service_type::implementation_type <a class="el" href="a00108.html">asio::basic_io_object</a>&lt; Service &gt;::<a class="el" href="a00108.html#b72f7245597ff283525d80bf0ffa52fb">implementation_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The underlying implementation type of I/O object. 
<p>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="4de12e4d1be36feab272c949bf8a7166"></a><!-- doxytag: member="asio::basic_resolver::basic_resolver" ref="4de12e4d1be36feab272c949bf8a7166" args="(asio::io_service &amp;io_service)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::<a class="el" href="a00109.html">basic_resolver</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00140.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
This constructor creates a <a class="el" href="a00109.html">basic_resolver</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00140.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00140.html">io_service</a> object that the resolver will use to dispatch handlers for any asynchronous operations performed on the timer. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a16fba9d23b53e375216e1108e209442"></a><!-- doxytag: member="asio::basic_resolver::cancel" ref="a16fba9d23b53e375216e1108e209442" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::cancel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel any asynchronous operations that are waiting on the resolver. 
<p>
This function forces the completion of any pending asynchronous operations on the host resolver. The handler for each cancelled operation will be invoked with the <a class="el" href="a00135.html#07d16ab7bd80c0b67c2286817d02bd47cde6760763051561f6c2ffc4ddf2be1b">asio::error::operation_aborted</a> error code. 
</div>
</div><p>
<a class="anchor" name="2ff03ba9608236e2111c03ea16410b1b"></a><!-- doxytag: member="asio::basic_resolver::resolve" ref="2ff03ba9608236e2111c03ea16410b1b" args="(const query &amp;q)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a> <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::resolve           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00109.html#688ee769f0eae3691bf65d0e91fffba7">query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a query to a list of entries. 
<p>
This function is used to resolve a query into a list of endpoint entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A query object that determines what endpoints will be returned.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A forward-only iterator that can be used to traverse the list of endpoint entries.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00135.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>A default constructed iterator represents the end of the list.<p>
A successful call to this function is guaranteed to return at least one entry. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5e472c28fa363144b6f24cbabd60184"></a><!-- doxytag: member="asio::basic_resolver::resolve" ref="f5e472c28fa363144b6f24cbabd60184" args="(const query &amp;q, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a> <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::resolve           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00109.html#688ee769f0eae3691bf65d0e91fffba7">query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve a query to a list of entries. 
<p>
This function is used to resolve a query into a list of endpoint entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A query object that determines what endpoints will be returned.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A forward-only iterator that can be used to traverse the list of endpoint entries. Returns a default constructed iterator if an error occurs.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>A handler to be called when the operation completes, to indicate whether or not an error has occurred. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00135.html">asio::error</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>A default constructed iterator represents the end of the list.<p>
A successful call to this function is guaranteed to return at least one entry. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2659f5d6a62356bb48466e6a5cf568cb"></a><!-- doxytag: member="asio::basic_resolver::async_resolve" ref="2659f5d6a62356bb48466e6a5cf568cb" args="(const query &amp;q, Handler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::async_resolve           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00109.html#688ee769f0eae3691bf65d0e91fffba7">query</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronously resolve a query to a list of entries. 
<p>
This function is used to asynchronously resolve a query into a list of endpoint entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>q</em>&nbsp;</td><td>A query object that determines what endpoints will be returned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00135.html">asio::error</a>&amp; error,   <span class="comment">// Result of operation.</span>
   resolver::iterator <a class="code" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a> <span class="comment">// Forward-only iterator that can be used to</span>
                               <span class="comment">// traverse the list of endpoint entries.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00140.html#9cd4ea280c4cb0d4748173f57cadfccb">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>A default constructed iterator represents the end of the list.<p>
A successful resolve operation is guaranteed to pass at least one entry to the handler. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f15964665734f6940c9842ef3d60455a"></a><!-- doxytag: member="asio::basic_resolver::resolve" ref="f15964665734f6940c9842ef3d60455a" args="(const endpoint_type &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a> <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::resolve           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00109.html#9f5857f766a26a6964b97e18f3b55852">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve an endpoint to a list of entries. 
<p>
This function is used to resolve an endpoint into a list of endpoint entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A forward-only iterator that can be used to traverse the list of endpoint entries.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00135.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>A default constructed iterator represents the end of the list.<p>
A successful call to this function is guaranteed to return at least one entry. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e79c5cc08dca177c0954b7d87fbc32f6"></a><!-- doxytag: member="asio::basic_resolver::resolve" ref="e79c5cc08dca177c0954b7d87fbc32f6" args="(const endpoint_type &amp;e, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a> <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::resolve           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00109.html#9f5857f766a26a6964b97e18f3b55852">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resolve an endpoint to a list of entries. 
<p>
This function is used to resolve an endpoint into a list of endpoint entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A forward-only iterator that can be used to traverse the list of endpoint entries. Returns a default constructed iterator if an error occurs.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>A handler to be called when the operation completes, to indicate whether or not an error has occurred. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00135.html">asio::error</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>A default constructed iterator represents the end of the list.<p>
A successful call to this function is guaranteed to return at least one entry. </dd></dl>

</div>
</div><p>
<a class="anchor" name="16254d96706f08ae91bcf682ce9b4a02"></a><!-- doxytag: member="asio::basic_resolver::async_resolve" ref="16254d96706f08ae91bcf682ce9b4a02" args="(const endpoint_type &amp;e, Handler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename Service = resolver_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00109.html">asio::basic_resolver</a>&lt; <a class="el" href="a00151.html">Protocol</a>, Service &gt;::async_resolve           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00109.html#9f5857f766a26a6964b97e18f3b55852">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Asynchronously resolve an endpoint to a list of entries. 
<p>
This function is used to asynchronously resolve an endpoint into a list of endpoint entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>e</em>&nbsp;</td><td>An endpoint object that determines what endpoints will be returned.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the resolve operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00135.html">asio::error</a>&amp; error,   <span class="comment">// Result of operation.</span>
   resolver::iterator <a class="code" href="a00109.html#4d8fef02de5e7db6dd1614f3d8325ea3">iterator</a> <span class="comment">// Forward-only iterator that can be used to</span>
                               <span class="comment">// traverse the list of endpoint entries.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00140.html#9cd4ea280c4cb0d4748173f57cadfccb">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>A default constructed iterator represents the end of the list.<p>
A successful resolve operation is guaranteed to pass at least one entry to the handler. </dd></dl>

</div>
</div><p>
<a class="anchor" name="07646b3fbab85fb0e438a8a651461881"></a><!-- doxytag: member="asio::basic_resolver::io_service" ref="07646b3fbab85fb0e438a8a651461881" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00140.html">asio::io_service</a>&amp; <a class="el" href="a00108.html">asio::basic_io_object</a>&lt; Service &gt;::<a class="el" href="a00140.html">io_service</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="a00140.html">io_service</a> associated with the object. 
<p>
This function may be used to obtain the <a class="el" href="a00140.html">io_service</a> object that the I/O object uses to dispatch handlers for asynchronous operations.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the <a class="el" href="a00140.html">io_service</a> object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
