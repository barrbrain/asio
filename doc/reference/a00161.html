<HTML>
  <HEAD>
    <TITLE>asio Reference: Stream Class Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1>Stream Class Reference</h1><!-- doxytag: class="Stream" --><!-- doxytag: inherits="Async_Read_Stream,Async_Write_Stream,Sync_Read_Stream,Sync_Write_Stream" -->Inherits <a class="el" href="a00102.html">Async_Read_Stream</a>, <a class="el" href="a00103.html">Async_Write_Stream</a>, <a class="el" href="a00165.html">Sync_Read_Stream</a>, and <a class="el" href="a00166.html">Sync_Write_Stream</a>.
<p>
Inheritance diagram for Stream:<p><center><img src="a00311.png" border="0" usemap="#a00312" alt="Inheritance graph"></center>
<map name="a00312">
<area href="a00102.html" shape="rect" coords="8,82,202,109" alt="">
<area href="a00101.html" shape="rect" coords="162,8,301,34" alt="">
<area href="a00103.html" shape="rect" coords="226,82,426,109" alt="">
<area href="a00136.html" shape="rect" coords="356,8,486,34" alt="">
<area href="a00165.html" shape="rect" coords="450,82,634,109" alt="">
<area href="a00166.html" shape="rect" coords="658,82,848,109" alt="">
</map>
<a href="a00092.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<a class="el" href="a00161.html">Stream</a> concept. 
<p>
<dl compact><dt><b>Implemented By:</b></dt><dd><a class="el" href="a00118.html">asio::basic_stream_socket</a> <br>
 <a class="el" href="a00122.html">asio::buffered_read_stream</a> <br>
 <a class="el" href="a00124.html">asio::buffered_write_stream</a> <br>
 <a class="el" href="a00123.html">asio::buffered_stream</a> <br>
 <a class="el" href="a00160.html">asio::ssl::stream</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00161.html#cb5a283b6cf6c1c74f441b10c7c4da45">lowest_layer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the lowest layer in the stream.  <a href="#cb5a283b6cf6c1c74f441b10c7c4da45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html#0af58642b00097c04b8e7afaec566f3a">io_service_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The io_service type for this object.  <a href="#0af58642b00097c04b8e7afaec566f3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">error_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type used for reporting errors.  <a href="#bf315c06b88920b501db82537b15b2a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html#0af58642b00097c04b8e7afaec566f3a">io_service_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The io_service type for this object.  <a href="#0af58642b00097c04b8e7afaec566f3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">error_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type used for reporting errors.  <a href="#bf315c06b88920b501db82537b15b2a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">error_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type used for reporting errors.  <a href="#bf315c06b88920b501db82537b15b2a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">error_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type used for reporting errors.  <a href="#bf315c06b88920b501db82537b15b2a4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00161.html#cb5a283b6cf6c1c74f441b10c7c4da45">lowest_layer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00161.html#85f023a78f050d80566b133274eff213">lowest_layer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#85f023a78f050d80566b133274eff213"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00102.html#44debb2eb05d23d0d2d59afeb5fd5560">async_read_some</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous read.  <a href="#44debb2eb05d23d0d2d59afeb5fd5560"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00101.html#0af58642b00097c04b8e7afaec566f3a">io_service_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html#6fabef2a25c93bd28e5bf8c2d7696bc9">io_service</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the io_service associated with the object.  <a href="#6fabef2a25c93bd28e5bf8c2d7696bc9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00103.html#22c9cfdccc9b7b23e041157a802734fb">async_write_some</a> (const <a class="el" href="a00127.html">Const_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write.  <a href="#22c9cfdccc9b7b23e041157a802734fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00101.html#0af58642b00097c04b8e7afaec566f3a">io_service_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html#6fabef2a25c93bd28e5bf8c2d7696bc9">io_service</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the io_service associated with the object.  <a href="#6fabef2a25c93bd28e5bf8c2d7696bc9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#1fedf129e086ec23c0261b51e28e10da">read_some</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream.  <a href="#1fedf129e086ec23c0261b51e28e10da"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#6b05c7fa5ec6feefcebed8420ce3d66d">read_some</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream.  <a href="#6b05c7fa5ec6feefcebed8420ce3d66d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#19ac9913d4af45fd50ee4cafa03037e9">peek</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#19ac9913d4af45fd50ee4cafa03037e9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#15b890297019569e52d53034bd115c13">peek</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#15b890297019569e52d53034bd115c13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html#8239a95aea8a1f2c05b671c49ea26781">in_avail</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#8239a95aea8a1f2c05b671c49ea26781"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#7ee6eb759fb01ca08b1608414ad7c0dd">in_avail</a> (Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#7ee6eb759fb01ca08b1608414ad7c0dd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00166.html#29859ba7e5b55f23abf6f7e7d7baaf5a">write_some</a> (const <a class="el" href="a00127.html">Const_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the given data on the stream.  <a href="#29859ba7e5b55f23abf6f7e7d7baaf5a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00166.html#0e0597aeb96464b5b088417cd4a0d591">write_some</a> (const <a class="el" href="a00127.html">Const_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the given data on the stream.  <a href="#0e0597aeb96464b5b088417cd4a0d591"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="cb5a283b6cf6c1c74f441b10c7c4da45"></a><!-- doxytag: member="Stream::lowest_layer_type" ref="cb5a283b6cf6c1c74f441b10c7c4da45" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00161.html#cb5a283b6cf6c1c74f441b10c7c4da45">Stream::lowest_layer_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of the lowest layer in the stream. 
<p>

</div>
</div><p>
<a class="anchor" name="0af58642b00097c04b8e7afaec566f3a"></a><!-- doxytag: member="Stream::io_service_type" ref="0af58642b00097c04b8e7afaec566f3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00101.html#0af58642b00097c04b8e7afaec566f3a">Async_Object::io_service_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The io_service type for this object. 
<p>

</div>
</div><p>
<a class="anchor" name="bf315c06b88920b501db82537b15b2a4"></a><!-- doxytag: member="Stream::error_type" ref="bf315c06b88920b501db82537b15b2a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Error_Source::error_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type used for reporting errors. 
<p>

</div>
</div><p>
<a class="anchor" name="0af58642b00097c04b8e7afaec566f3a"></a><!-- doxytag: member="Stream::io_service_type" ref="0af58642b00097c04b8e7afaec566f3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00101.html#0af58642b00097c04b8e7afaec566f3a">Async_Object::io_service_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The io_service type for this object. 
<p>

</div>
</div><p>
<a class="anchor" name="bf315c06b88920b501db82537b15b2a4"></a><!-- doxytag: member="Stream::error_type" ref="bf315c06b88920b501db82537b15b2a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Error_Source::error_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type used for reporting errors. 
<p>

</div>
</div><p>
<a class="anchor" name="bf315c06b88920b501db82537b15b2a4"></a><!-- doxytag: member="Stream::error_type" ref="bf315c06b88920b501db82537b15b2a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Error_Source::error_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type used for reporting errors. 
<p>

</div>
</div><p>
<a class="anchor" name="bf315c06b88920b501db82537b15b2a4"></a><!-- doxytag: member="Stream::error_type" ref="bf315c06b88920b501db82537b15b2a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Error_Source::error_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type used for reporting errors. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="85f023a78f050d80566b133274eff213"></a><!-- doxytag: member="Stream::lowest_layer" ref="85f023a78f050d80566b133274eff213" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00161.html#cb5a283b6cf6c1c74f441b10c7c4da45">lowest_layer_type</a>&amp; Stream::lowest_layer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a reference to the lowest layer. 
<p>

</div>
</div><p>
<a class="anchor" name="44debb2eb05d23d0d2d59afeb5fd5560"></a><!-- doxytag: member="Stream::async_read_some" ref="44debb2eb05d23d0d2d59afeb5fd5560" args="(const Mutable_Buffers &amp;buffers, Handler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers, typename Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Async_Read_Stream::async_read_some           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous read. 
<p>
This function is used to asynchronously read one or more bytes of data from the stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Async_Read_Stream::error_type</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred               <span class="comment">// Number of bytes read.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00140.html#9cd4ea280c4cb0d4748173f57cadfccb">asio::io_service::post()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6fabef2a25c93bd28e5bf8c2d7696bc9"></a><!-- doxytag: member="Stream::io_service" ref="6fabef2a25c93bd28e5bf8c2d7696bc9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00101.html#0af58642b00097c04b8e7afaec566f3a">io_service_type</a>&amp; Async_Object::io_service           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the io_service associated with the object. 
<p>
This function may be used to obtain the io_service object that the object uses to dispatch handlers for asynchronous operations.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the io_service object that the object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div><p>
<a class="anchor" name="22c9cfdccc9b7b23e041157a802734fb"></a><!-- doxytag: member="Stream::async_write_some" ref="22c9cfdccc9b7b23e041157a802734fb" args="(const Const_Buffers &amp;buffers, Handler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Const_Buffers, typename Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Async_Write_Stream::async_write_some           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00127.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Handler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous write. 
<p>
This function is used to asynchronously write one or more bytes of data to the stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Async_Write_Stream::error_type</a>&amp; error, <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred                <span class="comment">// Number of bytes written.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00140.html#9cd4ea280c4cb0d4748173f57cadfccb">asio::io_service::post()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6fabef2a25c93bd28e5bf8c2d7696bc9"></a><!-- doxytag: member="Stream::io_service" ref="6fabef2a25c93bd28e5bf8c2d7696bc9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00101.html#0af58642b00097c04b8e7afaec566f3a">io_service_type</a>&amp; Async_Object::io_service           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the io_service associated with the object. 
<p>
This function may be used to obtain the io_service object that the object uses to dispatch handlers for asynchronous operations.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the io_service object that the object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1fedf129e086ec23c0261b51e28e10da"></a><!-- doxytag: member="Stream::read_some" ref="1fedf129e086ec23c0261b51e28e10da" args="(const Mutable_Buffers &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::read_some           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b05c7fa5ec6feefcebed8420ce3d66d"></a><!-- doxytag: member="Stream::read_some" ref="6b05c7fa5ec6feefcebed8420ce3d66d" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::read_some           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read. Returns 0 if an error occurred and the error handler did not throw an exception. </dd></dl>

</div>
</div><p>
<a class="anchor" name="19ac9913d4af45fd50ee4cafa03037e9"></a><!-- doxytag: member="Stream::peek" ref="19ac9913d4af45fd50ee4cafa03037e9" args="(const Mutable_Buffers &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::peek           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="15b890297019569e52d53034bd115c13"></a><!-- doxytag: member="Stream::peek" ref="15b890297019569e52d53034bd115c13" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::peek           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read. Returns 0 if an error occurred and the error handler did not throw an exception. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8239a95aea8a1f2c05b671c49ea26781"></a><!-- doxytag: member="Stream::in_avail" ref="8239a95aea8a1f2c05b671c49ea26781" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::in_avail           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the amount of data that may be read without blocking. 
<p>
The function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ee6eb759fb01ca08b1608414ad7c0dd"></a><!-- doxytag: member="Stream::in_avail" ref="7ee6eb759fb01ca08b1608414ad7c0dd" args="(Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::in_avail           </td>
          <td>(</td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the amount of data that may be read without blocking. 
<p>
The function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29859ba7e5b55f23abf6f7e7d7baaf5a"></a><!-- doxytag: member="Stream::write_some" ref="29859ba7e5b55f23abf6f7e7d7baaf5a" args="(const Const_Buffers &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Const_Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Write_Stream::write_some           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00127.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the given data on the stream. 
<p>
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Write_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e0597aeb96464b5b088417cd4a0d591"></a><!-- doxytag: member="Stream::write_some" ref="0e0597aeb96464b5b088417cd4a0d591" args="(const Const_Buffers &amp;buffers, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Const_Buffers, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Write_Stream::write_some           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00127.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the given data on the stream. 
<p>
This function is used to write data on the stream. The function call will block until one or more bytes of data has been written successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Write_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written. Returns 0 if an error occurred and the error handler did not throw an exception. </dd></dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
