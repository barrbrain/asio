<HTML>
  <HEAD>
    <TITLE>asio Reference: Sync_Read_Stream Class Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1>Sync_Read_Stream Class Reference</h1><!-- doxytag: class="Sync_Read_Stream" --><!-- doxytag: inherits="Error_Source" -->Inherits <a class="el" href="a00136.html">Error_Source</a>.
<p>
Inherited by <a class="el" href="a00161.html">Stream</a>.
<p>
Inheritance diagram for Sync_Read_Stream:<p><center><img src="a00313.png" border="0" usemap="#a00314" alt="Inheritance graph"></center>
<map name="a00314">
<area href="a00161.html" shape="rect" coords="60,157,140,184" alt="">
<area href="a00136.html" shape="rect" coords="34,8,165,34" alt="">
</map>
<a href="a00093.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Synchronous read stream concept. 
<p>
<dl compact><dt><b>Implemented By:</b></dt><dd><a class="el" href="a00118.html">asio::basic_stream_socket</a> <br>
 <a class="el" href="a00122.html">asio::buffered_read_stream</a> <br>
 <a class="el" href="a00124.html">asio::buffered_write_stream</a> <br>
 <a class="el" href="a00123.html">asio::buffered_stream</a> <br>
 <a class="el" href="a00160.html">asio::ssl::stream</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">error_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type used for reporting errors.  <a href="#bf315c06b88920b501db82537b15b2a4"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#1fedf129e086ec23c0261b51e28e10da">read_some</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream.  <a href="#1fedf129e086ec23c0261b51e28e10da"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#6b05c7fa5ec6feefcebed8420ce3d66d">read_some</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream.  <a href="#6b05c7fa5ec6feefcebed8420ce3d66d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#19ac9913d4af45fd50ee4cafa03037e9">peek</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#19ac9913d4af45fd50ee4cafa03037e9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#15b890297019569e52d53034bd115c13">peek</a> (const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#15b890297019569e52d53034bd115c13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html#8239a95aea8a1f2c05b671c49ea26781">in_avail</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#8239a95aea8a1f2c05b671c49ea26781"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00165.html#7ee6eb759fb01ca08b1608414ad7c0dd">in_avail</a> (Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#7ee6eb759fb01ca08b1608414ad7c0dd"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="bf315c06b88920b501db82537b15b2a4"></a><!-- doxytag: member="Sync_Read_Stream::error_type" ref="bf315c06b88920b501db82537b15b2a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Error_Source::error_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type used for reporting errors. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1fedf129e086ec23c0261b51e28e10da"></a><!-- doxytag: member="Sync_Read_Stream::read_some" ref="1fedf129e086ec23c0261b51e28e10da" args="(const Mutable_Buffers &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::read_some           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b05c7fa5ec6feefcebed8420ce3d66d"></a><!-- doxytag: member="Sync_Read_Stream::read_some" ref="6b05c7fa5ec6feefcebed8420ce3d66d" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::read_some           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read. Returns 0 if an error occurred and the error handler did not throw an exception. </dd></dl>

</div>
</div><p>
<a class="anchor" name="19ac9913d4af45fd50ee4cafa03037e9"></a><!-- doxytag: member="Sync_Read_Stream::peek" ref="19ac9913d4af45fd50ee4cafa03037e9" args="(const Mutable_Buffers &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::peek           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="15b890297019569e52d53034bd115c13"></a><!-- doxytag: member="Sync_Read_Stream::peek" ref="15b890297019569e52d53034bd115c13" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::peek           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read. Returns 0 if an error occurred and the error handler did not throw an exception. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8239a95aea8a1f2c05b671c49ea26781"></a><!-- doxytag: member="Sync_Read_Stream::in_avail" ref="8239a95aea8a1f2c05b671c49ea26781" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::in_avail           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the amount of data that may be read without blocking. 
<p>
The function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ee6eb759fb01ca08b1608414ad7c0dd"></a><!-- doxytag: member="Sync_Read_Stream::in_avail" ref="7ee6eb759fb01ca08b1608414ad7c0dd" args="(Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Sync_Read_Stream::in_avail           </td>
          <td>(</td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the amount of data that may be read without blocking. 
<p>
The function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking. </dd></dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
