<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::async_write</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc2</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.5.1 -->
<h1>asio::async_write</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename WriteHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00140.html#g1747d3ec27f952154952e23be9249fbc">asio::async_write</a> (AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, WriteHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to write of all of the supplied data to a stream.  <a href="#g1747d3ec27f952154952e23be9249fbc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename CompletionCondition, typename WriteHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00140.html#g92449ad9f738a94223ee156ee40db396">asio::async_write</a> (AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="#g92449ad9f738a94223ee156ee40db396"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename AsyncWriteStream, typename Allocator, typename WriteHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00140.html#g388f23198effec84f65586ddf6aefa42">asio::async_write</a> (AsyncWriteStream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, WriteHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="#g388f23198effec84f65586ddf6aefa42"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename AsyncWriteStream, typename Allocator, typename CompletionCondition, typename WriteHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00140.html#g0eba9707f4ec3d9c7a38222c20043fa8">asio::async_write</a> (AsyncWriteStream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="#g0eba9707f4ec3d9c7a38222c20043fa8"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g1747d3ec27f952154952e23be9249fbc"></a><!-- doxytag: member="asio::async_write" ref="g1747d3ec27f952154952e23be9249fbc" args="(AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, WriteHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_write           </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to write of all of the supplied data to a stream. 
<p>
This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's async_write_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span>
                                           <span class="comment">// buffers. If an error occurred,</span>
                                           <span class="comment">// this will be less than the sum</span>
                                           <span class="comment">// of the buffer sizes.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To write a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00140.html#g1747d3ec27f952154952e23be9249fbc">asio::async_write</a>(s, <a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size), handler);
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g92449ad9f738a94223ee156ee40db396"></a><!-- doxytag: member="asio::async_write" ref="g92449ad9f738a94223ee156ee40db396" args="(AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename ConstBufferSequence, typename CompletionCondition, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_write           </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&nbsp;</td>
          <td class="paramname"> <em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to write a certain amount of data to a stream. 
<p>
This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns true.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's async_write_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completion_condition</em>&nbsp;</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> completion_condition(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of latest write_some</span>
                                           <span class="comment">// operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes transferred</span>
                                           <span class="comment">// so far.</span>
 ); 
</pre></div> A return value of true indicates that the write operation is complete. False indicates that further calls to the stream's async_write_some function are required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span>
                                           <span class="comment">// buffers. If an error occurred,</span>
                                           <span class="comment">// this will be less than the sum</span>
                                           <span class="comment">// of the buffer sizes.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To write a single data buffer use the <a class="el" href="a00133.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00140.html#g1747d3ec27f952154952e23be9249fbc">asio::async_write</a>(s,
     <a class="code" href="a00133.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size),
     <a class="code" href="a00134.html#gdba1ed43445276e2b563a59663ca26cd">asio::transfer_at_least</a>(32),
     handler); 
</pre></div> See the <a class="el" href="a00133.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g388f23198effec84f65586ddf6aefa42"></a><!-- doxytag: member="asio::async_write" ref="g388f23198effec84f65586ddf6aefa42" args="(AsyncWriteStream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, WriteHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename Allocator, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_write           </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_streambuf&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to write a certain amount of data to a stream. 
<p>
This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>All of the data in the supplied <a class="el" href="a00018.html">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's async_write_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A <a class="el" href="a00018.html">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span>
                                           <span class="comment">// buffers. If an error occurred,</span>
                                           <span class="comment">// this will be less than the sum</span>
                                           <span class="comment">// of the buffer sizes.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g0eba9707f4ec3d9c7a38222c20043fa8"></a><!-- doxytag: member="asio::async_write" ref="g0eba9707f4ec3d9c7a38222c20043fa8" args="(AsyncWriteStream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncWriteStream, typename Allocator, typename CompletionCondition, typename WriteHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_write           </td>
          <td>(</td>
          <td class="paramtype">AsyncWriteStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_streambuf&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&nbsp;</td>
          <td class="paramname"> <em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to write a certain amount of data to a stream. 
<p>
This function is used to asynchronously write a certain number of bytes of data to a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>All of the data in the supplied <a class="el" href="a00018.html">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns true.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's async_write_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream to which the data is to be written. The type must support the AsyncWriteStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A <a class="el" href="a00018.html">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completion_condition</em>&nbsp;</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> completion_condition(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of latest write_some</span>
                                           <span class="comment">// operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes transferred</span>
                                           <span class="comment">// so far.</span>
 ); 
</pre></div> A return value of true indicates that the write operation is complete. False indicates that further calls to the stream's async_write_some function are required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes written from the</span>
                                           <span class="comment">// buffers. If an error occurred,</span>
                                           <span class="comment">// this will be less than the sum</span>
                                           <span class="comment">// of the buffer sizes.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc2</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
