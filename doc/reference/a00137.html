<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::async_read</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.5.1 -->
<h1>asio::async_read</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename ReadHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00137.html#gb1d5925953621f0ba652f8b158eb4687">asio::async_read</a> (AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, ReadHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="#gb1d5925953621f0ba652f8b158eb4687"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename CompletionCondition, typename ReadHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00137.html#gf579a61847ecd3827da62e12a9f2ce66">asio::async_read</a> (AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="#gf579a61847ecd3827da62e12a9f2ce66"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00137.html#g9507feb399da622b527672bda53a9416">asio::async_read</a> (AsyncReadStream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, ReadHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="#g9507feb399da622b527672bda53a9416"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename AsyncReadStream, typename Allocator, typename CompletionCondition, typename ReadHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00137.html#g59f59c888216323a25fe49f781466d95">asio::async_read</a> (AsyncReadStream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="#g59f59c888216323a25fe49f781466d95"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gb1d5925953621f0ba652f8b158eb4687"></a><!-- doxytag: member="asio::async_read" ref="gb1d5925953621f0ba652f8b158eb4687" args="(AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, ReadHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_read           </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to read a certain amount of data from a stream. 
<p>
This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's async_read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span>
                                           <span class="comment">// buffers. If an error occurred,</span>
                                           <span class="comment">// this will be the  number of</span>
                                           <span class="comment">// bytes successfully transferred</span>
                                           <span class="comment">// prior to the error.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To read into a single data buffer use the <a class="el" href="a00134.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00137.html#gb1d5925953621f0ba652f8b158eb4687">asio::async_read</a>(s, <a class="code" href="a00134.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size), handler);
</pre></div> See the <a class="el" href="a00134.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This overload is equivalent to calling: <div class="fragment"><pre class="fragment"> <a class="code" href="a00137.html#gb1d5925953621f0ba652f8b158eb4687">asio::async_read</a>(
     s, buffers,
     <a class="code" href="a00135.html#g750bf6e293973be0ed8e2c7a085457f7">asio::transfer_all</a>(),
     handler); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf579a61847ecd3827da62e12a9f2ce66"></a><!-- doxytag: member="asio::async_read" ref="gf579a61847ecd3827da62e12a9f2ce66" args="(AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename MutableBufferSequence, typename CompletionCondition, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_read           </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&nbsp;</td>
          <td class="paramname"> <em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to read a certain amount of data from a stream. 
<p>
This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns true.</li>
</ul>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completion_condition</em>&nbsp;</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> completion_condition(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of latest read_some</span>
                                           <span class="comment">// operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes transferred</span>
                                           <span class="comment">// so far.</span>
 ); 
</pre></div> A return value of true indicates that the read operation is complete. False indicates that further calls to the stream's async_read_some function are required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span>
                                           <span class="comment">// buffers. If an error occurred,</span>
                                           <span class="comment">// this will be the  number of</span>
                                           <span class="comment">// bytes successfully transferred</span>
                                           <span class="comment">// prior to the error.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To read into a single data buffer use the <a class="el" href="a00134.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00137.html#gb1d5925953621f0ba652f8b158eb4687">asio::async_read</a>(s,
     <a class="code" href="a00134.html#g1ed66e401559cbfd19595392f653b47c">asio::buffer</a>(data, size),
     <a class="code" href="a00135.html#gdba1ed43445276e2b563a59663ca26cd">asio::transfer_at_least</a>(32),
     handler); 
</pre></div> See the <a class="el" href="a00134.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9507feb399da622b527672bda53a9416"></a><!-- doxytag: member="asio::async_read" ref="g9507feb399da622b527672bda53a9416" args="(AsyncReadStream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, ReadHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename Allocator, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_read           </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_streambuf&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to read a certain amount of data from a stream. 
<p>
This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's async_read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A <a class="el" href="a00018.html">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span>
                                           <span class="comment">// buffers. If an error occurred,</span>
                                           <span class="comment">// this will be the  number of</span>
                                           <span class="comment">// bytes successfully transferred</span>
                                           <span class="comment">// prior to the error.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This overload is equivalent to calling: <div class="fragment"><pre class="fragment"> <a class="code" href="a00137.html#gb1d5925953621f0ba652f8b158eb4687">asio::async_read</a>(
     s, b,
     <a class="code" href="a00135.html#g750bf6e293973be0ed8e2c7a085457f7">asio::transfer_all</a>(),
     handler); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g59f59c888216323a25fe49f781466d95"></a><!-- doxytag: member="asio::async_read" ref="g59f59c888216323a25fe49f781466d95" args="(AsyncReadStream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream, typename Allocator, typename CompletionCondition, typename ReadHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::async_read           </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_streambuf&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&nbsp;</td>
          <td class="paramname"> <em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous operation to read a certain amount of data from a stream. 
<p>
This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:<p>
<ul>
<li>The completion_condition function object returns true.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's async_read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A <a class="el" href="a00018.html">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completion_condition</em>&nbsp;</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> completion_condition(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of latest read_some</span>
                                           <span class="comment">// operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes transferred</span>
                                           <span class="comment">// so far.</span>
 ); 
</pre></div> A return value of true indicates that the read operation is complete. False indicates that further calls to the stream's async_read_some function are required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span>

   std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span>
                                           <span class="comment">// buffers. If an error occurred,</span>
                                           <span class="comment">// this will be the  number of</span>
                                           <span class="comment">// bytes successfully transferred</span>
                                           <span class="comment">// prior to the error.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
