<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::basic_socket_acceptor&lt; Protocol, SocketAcceptorService &gt; Class Template Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="a00126.html">asio</a>::<a class="el" href="a00014.html">basic_socket_acceptor</a></div>
<h1>asio::basic_socket_acceptor&lt; Protocol, SocketAcceptorService &gt; Class Template Reference</h1><!-- doxytag: class="asio::basic_socket_acceptor" --><!-- doxytag: inherits="asio::basic_io_object&lt; SocketAcceptorService &gt;,asio::socket_base" -->Inherits <a class="el" href="a00008.html">asio::basic_io_object&lt; SocketAcceptorService &gt;</a>, and <a class="el" href="a00045.html">asio::socket_base</a>.
<p>
Inheritance diagram for asio::basic_socket_acceptor&lt; Protocol, SocketAcceptorService &gt;:<p><center><img src="a00154.png" border="0" usemap="#a00155" alt="Inheritance graph"></center>
<map name="a00155">
<area href="a00008.html" shape="rect" coords="8,176,434,202" alt="">
<area doxygen="external.doxytags:" href="noncopyable.html" shape="rect" coords="194,8,320,34" alt="">
<area href="a00008.html" shape="rect" coords="228,85,590,112" alt="">
<area href="a00045.html" shape="rect" coords="458,176,629,202" alt="">
</map>
<a href="a00156.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt;<br>
 class asio::basic_socket_acceptor&lt; Protocol, SocketAcceptorService &gt;</h3>

Provides the ability to accept new connections. 
<p>
The <a class="el" href="a00014.html">basic_socket_acceptor</a> class template is used for accepting new socket connections.<p>
<dl class="user" compact><dt><b>Thread Safety</b></dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br>
 <em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Opening a socket acceptor with the SO_REUSEADDR option enabled: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), port);
 acceptor.open(endpoint.<a class="code" href="a00007.html#a9c4d0afb36a788547d8610722627446">protocol</a>());
 acceptor.set_option(<a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::ip::tcp::acceptor::reuse_address</a>(<span class="keyword">true</span>));
 acceptor.bind(endpoint);
 acceptor.listen();
</pre></div> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef SocketAcceptorService::native_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The native representation of an acceptor.  <a href="#9235a28f30142290e4dbc8b6bbdb016a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The protocol type.  <a href="#38f40022b2596eb88875792bd6c0fb21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol::endpoint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The endpoint type.  <a href="#393d69e2f8a370aaa13a9018af4c0048"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef SocketAcceptorService&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ee6c059b568e190966f1307cc21a264d">service_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the service that will be used to provide I/O operations.  <a href="#ee6c059b568e190966f1307cc21a264d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef service_type::implementation_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#36e6f136c8c1249242e81597c34d8d29">implementation_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying implementation type of I/O object.  <a href="#36e6f136c8c1249242e81597c34d8d29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b">shutdown_receive</a> =  implementation_defined, 
<br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62">shutdown_send</a> =  implementation_defined, 
<br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd">shutdown_both</a> =  implementation_defined
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Different ways a socket may be shutdown.  <a href="a00045.html#915e52ff147efd296350bba81f795c37">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">message_flags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitmask type for flags that can be passed to send and receive operations.  <a href="#c3cf77465dfedfe1979b5415cf32cc94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">broadcast</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to permit sending of broadcast messages.  <a href="#ee34d723e630ad0cc0b745ca5f6dc2ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">debug</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to enable socket-level debugging.  <a href="#d2c3c8844bdf08f6f74fae000d6d7217"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">do_not_route</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to prevent routing, use local interfaces only.  <a href="#4220b1b3fd7ca674d8adedb742d71680"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">keep_alive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to send keep-alives.  <a href="#493d09a6a851ec400a30e8f22adb9d74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">send_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send buffer size of a socket.  <a href="#8869a31e4367e9b62c08609dc89591b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">send_low_watermark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send low watermark.  <a href="#bff502237f6a2e248e68483e9ca6a0d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">receive_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive buffer size of a socket.  <a href="#d79401946636f3e91c1cc66436d1f975"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">receive_low_watermark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive low watermark.  <a href="#f487bc8987ef57e2c7469b40bba591a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">reuse_address</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to allow the socket to be bound to an address that is already in use.  <a href="#66ab5649a23766107c5da2a04993d8dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">linger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to specify whether the socket lingers on close if unsent data is present.  <a href="#308e86dd1ee896dd26c07abf7e6ff1b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">enable_connection_aborted</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to report aborted connections on accept.  <a href="#9ef00aa2ca23006e9868f2ea46223aea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">non_blocking_io</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO control command to set the blocking mode of the socket.  <a href="#28512bf41a5983383e0f5968c6e0580d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">bytes_readable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO control command to get the amount of data that can be read without blocking.  <a href="#bbde8e590fbb98dfa1685b9d435cb5dc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#047f1b2817ee4afd097a7b42192245c0">basic_socket_acceptor</a> (<a class="el" href="a00032.html">asio::io_service</a> &amp;<a class="el" href="a00032.html">io_service</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an acceptor without opening it.  <a href="#047f1b2817ee4afd097a7b42192245c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#40486b04aa49d3aac981e9fc43b78b3b">basic_socket_acceptor</a> (<a class="el" href="a00032.html">asio::io_service</a> &amp;<a class="el" href="a00032.html">io_service</a>, const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;protocol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an open acceptor.  <a href="#40486b04aa49d3aac981e9fc43b78b3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#06923f4b125f6003af2ce051d062fcb6">basic_socket_acceptor</a> (<a class="el" href="a00032.html">asio::io_service</a> &amp;<a class="el" href="a00032.html">io_service</a>, const <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;endpoint, bool reuse_addr=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an acceptor opened on the given endpoint.  <a href="#06923f4b125f6003af2ce051d062fcb6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#a8ddc2434ae8be4859bd79d82e31bb19">basic_socket_acceptor</a> (<a class="el" href="a00032.html">asio::io_service</a> &amp;<a class="el" href="a00032.html">io_service</a>, const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;protocol, const <a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a> &amp;native_acceptor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="a00014.html">basic_socket_acceptor</a> on an existing native acceptor.  <a href="#a8ddc2434ae8be4859bd79d82e31bb19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#8482fb8ffe099526567a721f027dacf0">open</a> (const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;protocol=<a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the acceptor using the specified protocol.  <a href="#8482fb8ffe099526567a721f027dacf0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#b661d709895470380e3dab3601e5fb64">open</a> (const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;protocol, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the acceptor using the specified protocol.  <a href="#b661d709895470380e3dab3601e5fb64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#233a7c12672b589c18f53ae8cbf561d5">assign</a> (const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;protocol, const <a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a> &amp;native_acceptor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns an existing native acceptor to the acceptor.  <a href="#233a7c12672b589c18f53ae8cbf561d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#807969a9b35037fa90a30571bb566687">assign</a> (const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;protocol, const <a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a> &amp;native_acceptor, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assigns an existing native acceptor to the acceptor.  <a href="#807969a9b35037fa90a30571bb566687"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#b5a99e6f2a5c41f61fc6fffda878be81">is_open</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the acceptor is open.  <a href="#b5a99e6f2a5c41f61fc6fffda878be81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#513b6fc8e25f355d3970f305eefac406">bind</a> (const <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the acceptor to the given local endpoint.  <a href="#513b6fc8e25f355d3970f305eefac406"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#4122fb3452c405d8869ca2eefe85475d">bind</a> (const <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;endpoint, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the acceptor to the given local endpoint.  <a href="#4122fb3452c405d8869ca2eefe85475d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#05d696cd8d5d5c21375be583bd30d492">listen</a> (int backlog=<a class="el" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">socket_base::max_connections</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place the acceptor into the state where it will listen for new connections.  <a href="#05d696cd8d5d5c21375be583bd30d492"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#6b5d0d4df74d3fe90985cd5714650f23">listen</a> (int backlog, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Place the acceptor into the state where it will listen for new connections.  <a href="#6b5d0d4df74d3fe90985cd5714650f23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#48e36d9d2248efde8d85e339c5695e06">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the acceptor.  <a href="#48e36d9d2248efde8d85e339c5695e06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#e56dea43b3cd00dbc7d432c267d020c1">close</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the acceptor.  <a href="#e56dea43b3cd00dbc7d432c267d020c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#6765e5952ac2c22ae8cc21af84e1e4cf">native</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the native acceptor representation.  <a href="#6765e5952ac2c22ae8cc21af84e1e4cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#24e4ffda1c79c425f407bb5f749f4d16">cancel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all asynchronous operations associated with the acceptor.  <a href="#24e4ffda1c79c425f407bb5f749f4d16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#093c764ab49404ff2d26c9e25935e183">cancel</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all asynchronous operations associated with the acceptor.  <a href="#093c764ab49404ff2d26c9e25935e183"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SettableSocketOption&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#e386974e0f857cc9d142f28192085925">set_option</a> (const SettableSocketOption &amp;option)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option on the acceptor.  <a href="#e386974e0f857cc9d142f28192085925"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SettableSocketOption&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#92c22c601e327c1f4f340243f7a7a633">set_option</a> (const SettableSocketOption &amp;option, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option on the acceptor.  <a href="#92c22c601e327c1f4f340243f7a7a633"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename GettableSocketOption&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#ab68854902c5dbbc57878ed62bd22810">get_option</a> (GettableSocketOption &amp;option)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an option from the acceptor.  <a href="#ab68854902c5dbbc57878ed62bd22810"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename GettableSocketOption&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#46d23eb68c48002ff97745312569717c">get_option</a> (GettableSocketOption &amp;option, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an option from the acceptor.  <a href="#46d23eb68c48002ff97745312569717c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#e451ddc7ec313f91b0f8194731ba3a5f">local_endpoint</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local endpoint of the acceptor.  <a href="#e451ddc7ec313f91b0f8194731ba3a5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html#574cf608b846cedd689d4d2f49420f00">local_endpoint</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local endpoint of the acceptor.  <a href="#574cf608b846cedd689d4d2f49420f00"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SocketService&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#ccbe246b8077b7b51792523a10e6584c">accept</a> (<a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;peer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a new connection.  <a href="#ccbe246b8077b7b51792523a10e6584c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SocketService&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#95767d5ea8cf710ff3799233cc214fc0">accept</a> (<a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;peer, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a new connection.  <a href="#95767d5ea8cf710ff3799233cc214fc0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SocketService, typename AcceptHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#236dafe870a90ec66e784bb216b28620">async_accept</a> (<a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;peer, AcceptHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous accept.  <a href="#236dafe870a90ec66e784bb216b28620"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SocketService&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#790f664f6401b36b5d08a0f5b3f5c0a4">accept</a> (<a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;peer, <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;peer_endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a new connection and obtain the endpoint of the peer.  <a href="#790f664f6401b36b5d08a0f5b3f5c0a4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SocketService&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#34cb2b50fd0db55b98bd5e0674a22420">accept</a> (<a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;peer, <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;peer_endpoint, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accept a new connection and obtain the endpoint of the peer.  <a href="#34cb2b50fd0db55b98bd5e0674a22420"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SocketService, typename AcceptHandler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00014.html#483a2c45305cea4f3ed8e8bf1301d19d">async_accept</a> (<a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;peer, <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;peer_endpoint, AcceptHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous accept.  <a href="#483a2c45305cea4f3ed8e8bf1301d19d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="a00032.html">io_service</a> associated with the object.  <a href="#e5208e056c92fa6130114d023a5bd8b0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#356e1bd7da0353e5472028cdec742ed0">message_peek</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at incoming data without removing it from the input queue.  <a href="#356e1bd7da0353e5472028cdec742ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#b9f08ba445b7ce09ece5ac7beaa6e7c9">message_out_of_band</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process out-of-band data.  <a href="#b9f08ba445b7ce09ece5ac7beaa6e7c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#e27428a48d1a7113a95ea205b1e17978">message_do_not_route</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify that the data should not be subject to routing.  <a href="#e27428a48d1a7113a95ea205b1e17978"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">max_connections</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the queue of pending incoming connections.  <a href="#85ee2a3ce0ec68ac8c026884c5bd3098"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="9235a28f30142290e4dbc8b6bbdb016a"></a><!-- doxytag: member="asio::basic_socket_acceptor::native_type" ref="9235a28f30142290e4dbc8b6bbdb016a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef SocketAcceptorService::native_type <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::<a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The native representation of an acceptor. 
<p>

</div>
</div><p>
<a class="anchor" name="38f40022b2596eb88875792bd6c0fb21"></a><!-- doxytag: member="asio::basic_socket_acceptor::protocol_type" ref="38f40022b2596eb88875792bd6c0fb21" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::<a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The protocol type. 
<p>

</div>
</div><p>
<a class="anchor" name="393d69e2f8a370aaa13a9018af4c0048"></a><!-- doxytag: member="asio::basic_socket_acceptor::endpoint_type" ref="393d69e2f8a370aaa13a9018af4c0048" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::<a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The endpoint type. 
<p>

</div>
</div><p>
<a class="anchor" name="ee6c059b568e190966f1307cc21a264d"></a><!-- doxytag: member="asio::basic_socket_acceptor::service_type" ref="ee6c059b568e190966f1307cc21a264d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef SocketAcceptorService  <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; SocketAcceptorService  &gt;::<a class="el" href="a00008.html#ee6c059b568e190966f1307cc21a264d">service_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of the service that will be used to provide I/O operations. 
<p>

</div>
</div><p>
<a class="anchor" name="36e6f136c8c1249242e81597c34d8d29"></a><!-- doxytag: member="asio::basic_socket_acceptor::implementation_type" ref="36e6f136c8c1249242e81597c34d8d29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef service_type::implementation_type <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; SocketAcceptorService  &gt;::<a class="el" href="a00008.html#36e6f136c8c1249242e81597c34d8d29">implementation_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The underlying implementation type of I/O object. 
<p>

</div>
</div><p>
<a class="anchor" name="c3cf77465dfedfe1979b5415cf32cc94"></a><!-- doxytag: member="asio::basic_socket_acceptor::message_flags" ref="c3cf77465dfedfe1979b5415cf32cc94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">asio::socket_base::message_flags</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitmask type for flags that can be passed to send and receive operations. 
<p>

</div>
</div><p>
<a class="anchor" name="ee34d723e630ad0cc0b745ca5f6dc2ba"></a><!-- doxytag: member="asio::basic_socket_acceptor::broadcast" ref="ee34d723e630ad0cc0b745ca5f6dc2ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to permit sending of broadcast messages. 
<p>
Implements the SOL_SOCKET/SO_BROADCAST socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2c3c8844bdf08f6f74fae000d6d7217"></a><!-- doxytag: member="asio::basic_socket_acceptor::debug" ref="d2c3c8844bdf08f6f74fae000d6d7217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to enable socket-level debugging. 
<p>
Implements the SOL_SOCKET/SO_DEBUG socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4220b1b3fd7ca674d8adedb742d71680"></a><!-- doxytag: member="asio::basic_socket_acceptor::do_not_route" ref="4220b1b3fd7ca674d8adedb742d71680" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to prevent routing, use local interfaces only. 
<p>
Implements the SOL_SOCKET/SO_DONTROUTE socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="493d09a6a851ec400a30e8f22adb9d74"></a><!-- doxytag: member="asio::basic_socket_acceptor::keep_alive" ref="493d09a6a851ec400a30e8f22adb9d74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to send keep-alives. 
<p>
Implements the SOL_SOCKET/SO_KEEPALIVE socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8869a31e4367e9b62c08609dc89591b2"></a><!-- doxytag: member="asio::basic_socket_acceptor::send_buffer_size" ref="8869a31e4367e9b62c08609dc89591b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the send buffer size of a socket. 
<p>
Implements the SOL_SOCKET/SO_SNDBUF socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> option(8192);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bff502237f6a2e248e68483e9ca6a0d2"></a><!-- doxytag: member="asio::basic_socket_acceptor::send_low_watermark" ref="bff502237f6a2e248e68483e9ca6a0d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the send low watermark. 
<p>
Implements the SOL_SOCKET/SO_SNDLOWAT socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> option(1024);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d79401946636f3e91c1cc66436d1f975"></a><!-- doxytag: member="asio::basic_socket_acceptor::receive_buffer_size" ref="d79401946636f3e91c1cc66436d1f975" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the receive buffer size of a socket. 
<p>
Implements the SOL_SOCKET/SO_RCVBUF socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> option(8192);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f487bc8987ef57e2c7469b40bba591a3"></a><!-- doxytag: member="asio::basic_socket_acceptor::receive_low_watermark" ref="f487bc8987ef57e2c7469b40bba591a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the receive low watermark. 
<p>
Implements the SOL_SOCKET/SO_RCVLOWAT socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> option(1024);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66ab5649a23766107c5da2a04993d8dc"></a><!-- doxytag: member="asio::basic_socket_acceptor::reuse_address" ref="66ab5649a23766107c5da2a04993d8dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to allow the socket to be bound to an address that is already in use. 
<p>
Implements the SOL_SOCKET/SO_REUSEADDR socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> option(<span class="keyword">true</span>);
 acceptor.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> option;
 acceptor.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="308e86dd1ee896dd26c07abf7e6ff1b5"></a><!-- doxytag: member="asio::basic_socket_acceptor::linger" ref="308e86dd1ee896dd26c07abf7e6ff1b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to specify whether the socket lingers on close if unsent data is present. 
<p>
Implements the SOL_SOCKET/SO_LINGER socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> option(<span class="keyword">true</span>, 30);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.enabled();
 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> timeout = option.timeout();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Linger_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ef00aa2ca23006e9868f2ea46223aea"></a><!-- doxytag: member="asio::basic_socket_acceptor::enable_connection_aborted" ref="9ef00aa2ca23006e9868f2ea46223aea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to report aborted connections on accept. 
<p>
Implements a custom socket option that determines whether or not an accept operation is permitted to fail with <a class="el" href="a00029.html#9bf2f12d5c023d03e276df42b9572d16">asio::error::connection_aborted</a>. By default the option is false.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a> option(<span class="keyword">true</span>);
 acceptor.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a> option;
 acceptor.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28512bf41a5983383e0f5968c6e0580d"></a><!-- doxytag: member="asio::basic_socket_acceptor::non_blocking_io" ref="28512bf41a5983383e0f5968c6e0580d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IO control command to set the blocking mode of the socket. 
<p>
Implements the FIONBIO IO control command.<p>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a> command(<span class="keyword">true</span>);
 socket.io_control(command);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>IO_Control_Command, Boolean_IO_Control_Command. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bbde8e590fbb98dfa1685b9d435cb5dc"></a><!-- doxytag: member="asio::basic_socket_acceptor::bytes_readable" ref="bbde8e590fbb98dfa1685b9d435cb5dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IO control command to get the amount of data that can be read without blocking. 
<p>
Implements the FIONREAD IO control command.<p>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a> command(<span class="keyword">true</span>);
 socket.io_control(command);
 std::size_t bytes_readable = command.get();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>IO_Control_Command, Size_IO_Control_Command. </dd></dl>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="915e52ff147efd296350bba81f795c37"></a><!-- doxytag: member="asio::basic_socket_acceptor::shutdown_type" ref="915e52ff147efd296350bba81f795c37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">asio::socket_base::shutdown_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Different ways a socket may be shutdown. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b"></a><!-- doxytag: member="shutdown_receive" ref="915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b" args="" -->shutdown_receive</em>&nbsp;</td><td>
Shutdown the receive side of the socket. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62"></a><!-- doxytag: member="shutdown_send" ref="915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62" args="" -->shutdown_send</em>&nbsp;</td><td>
Shutdown the send side of the socket. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd"></a><!-- doxytag: member="shutdown_both" ref="915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd" args="" -->shutdown_both</em>&nbsp;</td><td>
Shutdown both send and receive on the socket. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="047f1b2817ee4afd097a7b42192245c0"></a><!-- doxytag: member="asio::basic_socket_acceptor::basic_socket_acceptor" ref="047f1b2817ee4afd097a7b42192245c0" args="(asio::io_service &amp;io_service)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::<a class="el" href="a00014.html">basic_socket_acceptor</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an acceptor without opening it. 
<p>
This constructor creates an acceptor without opening it to listen for new connections. The <a class="el" href="a00014.html#8482fb8ffe099526567a721f027dacf0">open()</a> function must be called before the acceptor can accept new socket connections.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00032.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00032.html">io_service</a> object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="40486b04aa49d3aac981e9fc43b78b3b"></a><!-- doxytag: member="asio::basic_socket_acceptor::basic_socket_acceptor" ref="40486b04aa49d3aac981e9fc43b78b3b" args="(asio::io_service &amp;io_service, const protocol_type &amp;protocol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::<a class="el" href="a00014.html">basic_socket_acceptor</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an open acceptor. 
<p>
This constructor creates an acceptor and automatically opens it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00032.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00032.html">io_service</a> object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="06923f4b125f6003af2ce051d062fcb6"></a><!-- doxytag: member="asio::basic_socket_acceptor::basic_socket_acceptor" ref="06923f4b125f6003af2ce051d062fcb6" args="(asio::io_service &amp;io_service, const endpoint_type &amp;endpoint, bool reuse_addr=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::<a class="el" href="a00014.html">basic_socket_acceptor</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>reuse_addr</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an acceptor opened on the given endpoint. 
<p>
This constructor creates an acceptor and automatically opens it to listen for new connections on the specified endpoint.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00032.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00032.html">io_service</a> object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine on which the acceptor will listen for new connections.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reuse_addr</em>&nbsp;</td><td>Whether the constructor should set the socket option <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">socket_base::reuse_address</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This constructor is equivalent to the following code: <div class="fragment"><pre class="fragment"> basic_socket_acceptor&lt;Protocol&gt; acceptor(io_service);
 acceptor.open(endpoint.<a class="code" href="a00007.html#a9c4d0afb36a788547d8610722627446">protocol</a>());
 <span class="keywordflow">if</span> (reuse_addr)
   acceptor.set_option(<a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">socket_base::reuse_address</a>(<span class="keyword">true</span>));
 acceptor.bind(endpoint);
 acceptor.listen(listen_backlog);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8ddc2434ae8be4859bd79d82e31bb19"></a><!-- doxytag: member="asio::basic_socket_acceptor::basic_socket_acceptor" ref="a8ddc2434ae8be4859bd79d82e31bb19" args="(asio::io_service &amp;io_service, const protocol_type &amp;protocol, const native_type &amp;native_acceptor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::<a class="el" href="a00014.html">basic_socket_acceptor</a>           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>native_acceptor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="a00014.html">basic_socket_acceptor</a> on an existing native acceptor. 
<p>
This constructor creates an acceptor object to hold an existing native acceptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00032.html">io_service</a></em>&nbsp;</td><td>The <a class="el" href="a00032.html">io_service</a> object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>native_acceptor</em>&nbsp;</td><td>A native acceptor.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8482fb8ffe099526567a721f027dacf0"></a><!-- doxytag: member="asio::basic_socket_acceptor::open" ref="8482fb8ffe099526567a721f027dacf0" args="(const protocol_type &amp;protocol=protocol_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::open           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em> = <code><a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the acceptor using the specified protocol. 
<p>
This function opens the socket acceptor so that it will use the specified protocol.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying which protocol is to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 acceptor.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="b661d709895470380e3dab3601e5fb64"></a><!-- doxytag: member="asio::basic_socket_acceptor::open" ref="b661d709895470380e3dab3601e5fb64" args="(const protocol_type &amp;protocol, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::open           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the acceptor using the specified protocol. 
<p>
This function opens the socket acceptor so that it will use the specified protocol.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 acceptor.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="233a7c12672b589c18f53ae8cbf561d5"></a><!-- doxytag: member="asio::basic_socket_acceptor::assign" ref="233a7c12672b589c18f53ae8cbf561d5" args="(const protocol_type &amp;protocol, const native_type &amp;native_acceptor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>native_acceptor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns an existing native acceptor to the acceptor. 
<p>

</div>
</div><p>
<a class="anchor" name="807969a9b35037fa90a30571bb566687"></a><!-- doxytag: member="asio::basic_socket_acceptor::assign" ref="807969a9b35037fa90a30571bb566687" args="(const protocol_type &amp;protocol, const native_type &amp;native_acceptor, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>native_acceptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assigns an existing native acceptor to the acceptor. 
<p>

</div>
</div><p>
<a class="anchor" name="b5a99e6f2a5c41f61fc6fffda878be81"></a><!-- doxytag: member="asio::basic_socket_acceptor::is_open" ref="b5a99e6f2a5c41f61fc6fffda878be81" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::is_open           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the acceptor is open. 
<p>

</div>
</div><p>
<a class="anchor" name="513b6fc8e25f355d3970f305eefac406"></a><!-- doxytag: member="asio::basic_socket_acceptor::bind" ref="513b6fc8e25f355d3970f305eefac406" args="(const endpoint_type &amp;endpoint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::bind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind the acceptor to the given local endpoint. 
<p>
This function binds the socket acceptor to the specified endpoint on the local machine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the socket acceptor will be bound.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 acceptor.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
 acceptor.bind(<a class="code" href="a00007.html">asio::ip::tcp::endpoint</a>(12345));
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4122fb3452c405d8869ca2eefe85475d"></a><!-- doxytag: member="asio::basic_socket_acceptor::bind" ref="4122fb3452c405d8869ca2eefe85475d" args="(const endpoint_type &amp;endpoint, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::bind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind the acceptor to the given local endpoint. 
<p>
This function binds the socket acceptor to the specified endpoint on the local machine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the socket acceptor will be bound.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 acceptor.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 acceptor.bind(<a class="code" href="a00007.html">asio::ip::tcp::endpoint</a>(12345), ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="05d696cd8d5d5c21375be583bd30d492"></a><!-- doxytag: member="asio::basic_socket_acceptor::listen" ref="05d696cd8d5d5c21375be583bd30d492" args="(int backlog=socket_base::max_connections)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::listen           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em> = <code><a class="el" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">socket_base::max_connections</a></code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Place the acceptor into the state where it will listen for new connections. 
<p>
This function puts the socket acceptor into the state where it may accept new connections.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>backlog</em>&nbsp;</td><td>The maximum length of the queue of pending connections.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6b5d0d4df74d3fe90985cd5714650f23"></a><!-- doxytag: member="asio::basic_socket_acceptor::listen" ref="6b5d0d4df74d3fe90985cd5714650f23" args="(int backlog, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::listen           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Place the acceptor into the state where it will listen for new connections. 
<p>
This function puts the socket acceptor into the state where it may accept new connections.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>backlog</em>&nbsp;</td><td>The maximum length of the queue of pending connections.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 acceptor.listen(<a class="code" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">asio::socket_base::max_connections</a>, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="48e36d9d2248efde8d85e339c5695e06"></a><!-- doxytag: member="asio::basic_socket_acceptor::close" ref="48e36d9d2248efde8d85e339c5695e06" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the acceptor. 
<p>
This function is used to close the acceptor. Any asynchronous accept operations will be cancelled immediately.<p>
A subsequent call to <a class="el" href="a00014.html#8482fb8ffe099526567a721f027dacf0">open()</a> is required before the acceptor can again be used to again perform socket accept operations.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e56dea43b3cd00dbc7d432c267d020c1"></a><!-- doxytag: member="asio::basic_socket_acceptor::close" ref="e56dea43b3cd00dbc7d432c267d020c1" args="(asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the acceptor. 
<p>
This function is used to close the acceptor. Any asynchronous accept operations will be cancelled immediately.<p>
A subsequent call to <a class="el" href="a00014.html#8482fb8ffe099526567a721f027dacf0">open()</a> is required before the acceptor can again be used to again perform socket accept operations.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 acceptor.close(ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6765e5952ac2c22ae8cc21af84e1e4cf"></a><!-- doxytag: member="asio::basic_socket_acceptor::native" ref="6765e5952ac2c22ae8cc21af84e1e4cf" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00014.html#9235a28f30142290e4dbc8b6bbdb016a">native_type</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::native           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the native acceptor representation. 
<p>
This function may be used to obtain the underlying representation of the acceptor. This is intended to allow access to native acceptor functionality that is not otherwise provided. 
</div>
</div><p>
<a class="anchor" name="24e4ffda1c79c425f407bb5f749f4d16"></a><!-- doxytag: member="asio::basic_socket_acceptor::cancel" ref="24e4ffda1c79c425f407bb5f749f4d16" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::cancel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel all asynchronous operations associated with the acceptor. 
<p>
This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="093c764ab49404ff2d26c9e25935e183"></a><!-- doxytag: member="asio::basic_socket_acceptor::cancel" ref="093c764ab49404ff2d26c9e25935e183" args="(asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::cancel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel all asynchronous operations associated with the acceptor. 
<p>
This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e386974e0f857cc9d142f28192085925"></a><!-- doxytag: member="asio::basic_socket_acceptor::set_option" ref="e386974e0f857cc9d142f28192085925" args="(const SettableSocketOption &amp;option)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::set_option           </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an option on the acceptor. 
<p>
This function is used to set an option on the acceptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The new option value to be set on the acceptor.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>SettableSocketOption <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <a class="el" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Setting the SOL_SOCKET/SO_REUSEADDR option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::ip::tcp::acceptor::reuse_address</a> option(<span class="keyword">true</span>);
 acceptor.set_option(option);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="92c22c601e327c1f4f340243f7a7a633"></a><!-- doxytag: member="asio::basic_socket_acceptor::set_option" ref="92c22c601e327c1f4f340243f7a7a633" args="(const SettableSocketOption &amp;option, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::set_option           </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an option on the acceptor. 
<p>
This function is used to set an option on the acceptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The new option value to be set on the acceptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>SettableSocketOption <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <a class="el" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Setting the SOL_SOCKET/SO_REUSEADDR option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::ip::tcp::acceptor::reuse_address</a> option(<span class="keyword">true</span>);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 acceptor.set_option(option, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab68854902c5dbbc57878ed62bd22810"></a><!-- doxytag: member="asio::basic_socket_acceptor::get_option" ref="ab68854902c5dbbc57878ed62bd22810" args="(GettableSocketOption &amp;option)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::get_option           </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an option from the acceptor. 
<p>
This function is used to get the current value of an option on the acceptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The option value to be obtained from the acceptor.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>GettableSocketOption <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the value of the SOL_SOCKET/SO_REUSEADDR option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::ip::tcp::acceptor::reuse_address</a> option;
 acceptor.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="46d23eb68c48002ff97745312569717c"></a><!-- doxytag: member="asio::basic_socket_acceptor::get_option" ref="46d23eb68c48002ff97745312569717c" args="(GettableSocketOption &amp;option, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::get_option           </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an option from the acceptor. 
<p>
This function is used to get the current value of an option on the acceptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The option value to be obtained from the acceptor.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>GettableSocketOption <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the value of the SOL_SOCKET/SO_REUSEADDR option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::ip::tcp::acceptor::reuse_address</a> option;
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 acceptor.get_option(option, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
 <span class="keywordtype">bool</span> is_set = option.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e451ddc7ec313f91b0f8194731ba3a5f"></a><!-- doxytag: member="asio::basic_socket_acceptor::local_endpoint" ref="e451ddc7ec313f91b0f8194731ba3a5f" args="() const" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::local_endpoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the local endpoint of the acceptor. 
<p>
This function is used to obtain the locally bound endpoint of the acceptor.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the local endpoint of the acceptor.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = acceptor.local_endpoint();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="574cf608b846cedd689d4d2f49420f00"></a><!-- doxytag: member="asio::basic_socket_acceptor::local_endpoint" ref="574cf608b846cedd689d4d2f49420f00" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::local_endpoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the local endpoint of the acceptor. 
<p>
This function is used to obtain the locally bound endpoint of the acceptor.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the local endpoint of the acceptor. Returns a default-constructed endpoint object if an error occurred and the error handler did not throw an exception.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = acceptor.local_endpoint(ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ccbe246b8077b7b51792523a10e6584c"></a><!-- doxytag: member="asio::basic_socket_acceptor::accept" ref="ccbe246b8077b7b51792523a10e6584c" args="(basic_socket&lt; protocol_type, SocketService &gt; &amp;peer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SocketService&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>peer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accept a new connection. 
<p>
This function is used to accept a new connection from a peer into the given socket. The function call will block until a new connection has been accepted successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer</em>&nbsp;</td><td>The socket into which the new connection will be accepted.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 acceptor.accept(socket);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="95767d5ea8cf710ff3799233cc214fc0"></a><!-- doxytag: member="asio::basic_socket_acceptor::accept" ref="95767d5ea8cf710ff3799233cc214fc0" args="(basic_socket&lt; protocol_type, SocketService &gt; &amp;peer, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SocketService&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accept a new connection. 
<p>
This function is used to accept a new connection from a peer into the given socket. The function call will block until a new connection has been accepted successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer</em>&nbsp;</td><td>The socket into which the new connection will be accepted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 asio::ip::tcp::soocket socket(io_service);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 acceptor.accept(socket, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="236dafe870a90ec66e784bb216b28620"></a><!-- doxytag: member="asio::basic_socket_acceptor::async_accept" ref="236dafe870a90ec66e784bb216b28620" args="(basic_socket&lt; protocol_type, SocketService &gt; &amp;peer, AcceptHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SocketService, typename AcceptHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::async_accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous accept. 
<p>
This function is used to asynchronously accept a new connection into a socket. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer</em>&nbsp;</td><td>The socket into which the new connection will be accepted. Ownership of the peer object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> accept_handler(<span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error)
 {
   <span class="keywordflow">if</span> (!error)
   {
     <span class="comment">// Accept succeeded.</span>
   }
 }

 ...

 <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 acceptor.async_accept(socket, accept_handler);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="790f664f6401b36b5d08a0f5b3f5c0a4"></a><!-- doxytag: member="asio::basic_socket_acceptor::accept" ref="790f664f6401b36b5d08a0f5b3f5c0a4" args="(basic_socket&lt; protocol_type, SocketService &gt; &amp;peer, endpoint_type &amp;peer_endpoint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SocketService&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>peer_endpoint</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accept a new connection and obtain the endpoint of the peer. 
<p>
This function is used to accept a new connection from a peer into the given socket, and additionally provide the endpoint of the remote peer. The function call will block until a new connection has been accepted successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer</em>&nbsp;</td><td>The socket into which the new connection will be accepted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>An endpoint object which will receive the endpoint of the remote peer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint;
 acceptor.accept(socket, endpoint);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="34cb2b50fd0db55b98bd5e0674a22420"></a><!-- doxytag: member="asio::basic_socket_acceptor::accept" ref="34cb2b50fd0db55b98bd5e0674a22420" args="(basic_socket&lt; protocol_type, SocketService &gt; &amp;peer, endpoint_type &amp;peer_endpoint, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SocketService&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accept a new connection and obtain the endpoint of the peer. 
<p>
This function is used to accept a new connection from a peer into the given socket, and additionally provide the endpoint of the remote peer. The function call will block until a new connection has been accepted successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer</em>&nbsp;</td><td>The socket into which the new connection will be accepted.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>An endpoint object which will receive the endpoint of the remote peer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service);
 ...
 <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint;
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 acceptor.accept(socket, endpoint, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="483a2c45305cea4f3ed8e8bf1301d19d"></a><!-- doxytag: member="asio::basic_socket_acceptor::async_accept" ref="483a2c45305cea4f3ed8e8bf1301d19d" args="(basic_socket&lt; protocol_type, SocketService &gt; &amp;peer, endpoint_type &amp;peer_endpoint, AcceptHandler handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename SocketAcceptorService = socket_acceptor_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename SocketService, typename AcceptHandler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00014.html">asio::basic_socket_acceptor</a>&lt; Protocol, SocketAcceptorService &gt;::async_accept           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00013.html">basic_socket</a>&lt; <a class="el" href="a00014.html#38f40022b2596eb88875792bd6c0fb21">protocol_type</a>, SocketService &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00014.html#393d69e2f8a370aaa13a9018af4c0048">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous accept. 
<p>
This function is used to asynchronously accept a new connection into a socket, and additionally obtain the endpoint of the remote peer. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer</em>&nbsp;</td><td>The socket into which the new connection will be accepted. Ownership of the peer object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e5208e056c92fa6130114d023a5bd8b0"></a><!-- doxytag: member="asio::basic_socket_acceptor::io_service" ref="e5208e056c92fa6130114d023a5bd8b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00032.html">asio::io_service</a>&amp; <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; SocketAcceptorService  &gt;::<a class="el" href="a00032.html">io_service</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="a00032.html">io_service</a> associated with the object. 
<p>
This function may be used to obtain the <a class="el" href="a00032.html">io_service</a> object that the I/O object uses to dispatch handlers for asynchronous operations.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the <a class="el" href="a00032.html">io_service</a> object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="356e1bd7da0353e5472028cdec742ed0"></a><!-- doxytag: member="asio::basic_socket_acceptor::message_peek" ref="356e1bd7da0353e5472028cdec742ed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#356e1bd7da0353e5472028cdec742ed0">asio::socket_base::message_peek</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Peek at incoming data without removing it from the input queue. 
<p>

</div>
</div><p>
<a class="anchor" name="b9f08ba445b7ce09ece5ac7beaa6e7c9"></a><!-- doxytag: member="asio::basic_socket_acceptor::message_out_of_band" ref="b9f08ba445b7ce09ece5ac7beaa6e7c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#b9f08ba445b7ce09ece5ac7beaa6e7c9">asio::socket_base::message_out_of_band</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process out-of-band data. 
<p>

</div>
</div><p>
<a class="anchor" name="e27428a48d1a7113a95ea205b1e17978"></a><!-- doxytag: member="asio::basic_socket_acceptor::message_do_not_route" ref="e27428a48d1a7113a95ea205b1e17978" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#e27428a48d1a7113a95ea205b1e17978">asio::socket_base::message_do_not_route</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify that the data should not be subject to routing. 
<p>

</div>
</div><p>
<a class="anchor" name="85ee2a3ce0ec68ac8c026884c5bd3098"></a><!-- doxytag: member="asio::basic_socket_acceptor::max_connections" ref="85ee2a3ce0ec68ac8c026884c5bd3098" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">asio::socket_base::max_connections</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The maximum length of the queue of pending incoming connections. 
<p>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
