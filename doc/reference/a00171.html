<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::ssl::stream&lt; Stream, Service &gt; Class Template Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.4</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.5 -->
<div class="nav">
<a class="el" href="a00264.html">asio</a>::<a class="el" href="a00275.html">ssl</a>::<a class="el" href="a00171.html">stream</a></div>
<h1>asio::ssl::stream&lt; Stream, Service &gt; Class Template Reference</h1><!-- doxytag: class="asio::ssl::stream" --><!-- doxytag: inherits="asio::ssl::stream_base" -->Inherits <a class="el" href="a00172.html">asio::ssl::stream_base</a>.
<p>
<a href="a00076.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt;<br>
 class asio::ssl::stream&lt; Stream, Service &gt;</h3>

Provides stream-oriented functionality using SSL. 
<p>
The stream class template provides asynchronous and blocking stream-oriented functionality using SSL.<p>
<dl compact><dt><b>Thread Safety:</b></dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br>
 <em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To use the SSL stream template with a stream_socket, you would write: <div class="fragment"><pre class="fragment"> <a class="code" href="a00115.html">asio::demuxer</a> <a class="code" href="a00171.html#6afeb5e9a5b1a4fbbc83e784e9d07a99">demuxer</a>;
 <a class="code" href="a00112.html">asio::ssl::context</a> <a class="code" href="a00275.html#5c18ef72771564b7f43c497dc507aeab">context</a>(demuxer, <a class="code" href="a00130.html#ea9f6aca279138c58f705c8d4cb4b8ce5edfacbf6a225e647ca1238806765693">asio::ssl::context::sslv23</a>);
 asio::ssl::stream&lt;asio::stream_socket&gt; sock(demuxer, <a class="code" href="a00275.html#5c18ef72771564b7f43c497dc507aeab">context</a>); 
</pre></div></dd></dl>
<dl compact><dt><b>Concepts:</b></dt><dd><a class="el" href="a00109.html">Async_Object</a>, <a class="el" href="a00110.html">Async_Read_Stream</a>, <a class="el" href="a00111.html">Async_Write_Stream</a>, <a class="el" href="a00170.html">Stream</a>, <a class="el" href="a00175.html">Sync_Read_Stream</a>, <a class="el" href="a00176.html">Sync_Write_Stream</a>. </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::remove_reference&lt;<br>
 <a class="el" href="a00170.html">Stream</a> &gt;::type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#c1e68987164e915e01be267e61e5564a">next_layer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the next layer.  <a href="#c1e68987164e915e01be267e61e5564a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef next_layer_type::lowest_layer_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#90d5ffdfbbdd5d67a61516c38215f0d5">lowest_layer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the lowest layer.  <a href="#90d5ffdfbbdd5d67a61516c38215f0d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef next_layer_type::demuxer_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The demuxer type for this asynchronous type.  <a href="#a88158c5007f6c3cba0dcaea6724b104"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Service&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#f43697a993f56955e3f9e353b3b1f210">service_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the service that will be used to provide stream operations.  <a href="#f43697a993f56955e3f9e353b3b1f210"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef service_type::impl_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The native implementation type of the stream.  <a href="#0ac43ba128daec432ece8d7eaecacbcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f">handshake_type</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f62608e08adc29a8d6dbc9754e659f125">client</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17fcf1e8c14e54505f60aa10ceb8d5d8ab3">server</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Different handshake types.  <a href="a00172.html#066a219e662971fd5181a43f888ab17f">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Arg, typename Context_Service&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#880de7bc559a9c2ce3bd7a54f1d68520">stream</a> (Arg &amp;arg, <a class="el" href="a00112.html">basic_context</a>&lt; Context_Service &gt; &amp;<a class="el" href="a00112.html">context</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a stream.  <a href="#880de7bc559a9c2ce3bd7a54f1d68520"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#4f6db94c5af2d9f27bef65874d668165">~stream</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#4f6db94c5af2d9f27bef65874d668165"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00171.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#6afeb5e9a5b1a4fbbc83e784e9d07a99">demuxer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the demuxer associated with the asynchronous object.  <a href="#6afeb5e9a5b1a4fbbc83e784e9d07a99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00171.html#c1e68987164e915e01be267e61e5564a">next_layer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#0d289fdb710fbecd1d6adcca81fe0f37">next_layer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the next layer.  <a href="#0d289fdb710fbecd1d6adcca81fe0f37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00171.html#90d5ffdfbbdd5d67a61516c38215f0d5">lowest_layer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#8884a12ca6ca736b3d4cdf885d0b6d07">lowest_layer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#8884a12ca6ca736b3d4cdf885d0b6d07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00171.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#01610c26789d1c8c6c2ff679f386caf5">impl</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying implementation in the native type.  <a href="#01610c26789d1c8c6c2ff679f386caf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#775fb41775f9ed292b74a886bf221b00">handshake</a> (<a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f">handshake_type</a> type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform SSL handshaking.  <a href="#775fb41775f9ed292b74a886bf221b00"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#fca706d4bedbae3fcc517043ee7c7180">handshake</a> (<a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f">handshake_type</a> type, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform SSL handshaking.  <a href="#fca706d4bedbae3fcc517043ee7c7180"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#74f2a4dab50807d2daf747477dc87575">async_handshake</a> (<a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f">handshake_type</a> type, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous SSL handshake.  <a href="#74f2a4dab50807d2daf747477dc87575"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#5352e1d5e4706796a03f7cfd4e0d6949">shutdown</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down SSL on the stream.  <a href="#5352e1d5e4706796a03f7cfd4e0d6949"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#1500c4b141c187db538e5f9aeaccd1be">shutdown</a> (Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shut down SSL on the stream.  <a href="#1500c4b141c187db538e5f9aeaccd1be"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#4a0d9f5888238c9c4fb8b6afabe69f24">async_shutdown</a> (Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Asynchronously shut down SSL on the stream.  <a href="#4a0d9f5888238c9c4fb8b6afabe69f24"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#f96dffab0c878d59c4bf48127471d75b">write</a> (const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some data to the stream.  <a href="#f96dffab0c878d59c4bf48127471d75b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#e2891dd0bb45545ef4c4aae3e8434dce">write</a> (const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some data to the stream.  <a href="#e2891dd0bb45545ef4c4aae3e8434dce"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#b2ca2c762662202865f65a3389789595">async_write</a> (const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write.  <a href="#b2ca2c762662202865f65a3389789595"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#f50aab50daa68c84d02b06633fc6e621">read</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream.  <a href="#f50aab50daa68c84d02b06633fc6e621"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#2ad69e98019814679f4e480b26ce27e5">read</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream.  <a href="#2ad69e98019814679f4e480b26ce27e5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#11212cb2acb4bc1c05205e679cdc0528">async_read</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous read.  <a href="#11212cb2acb4bc1c05205e679cdc0528"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#32081c0c9f6f616ccd8ff6ce09c7c7b8">peek</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#32081c0c9f6f616ccd8ff6ce09c7c7b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#fb658c4ce8b9d216dd4bfb64a292cd90">peek</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#fb658c4ce8b9d216dd4bfb64a292cd90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#a0176623c6cd6d0f41c90bf3f2dfb225">in_avail</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#a0176623c6cd6d0f41c90bf3f2dfb225"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00171.html#50ebac28ba9e853abb18fa6149908c82">in_avail</a> (Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#50ebac28ba9e853abb18fa6149908c82"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00170.html">Stream</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#bf7ab454da0f2a4bdfbe77eb5c9c1c48">next_layer_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The next layer.  <a href="#bf7ab454da0f2a4bdfbe77eb5c9c1c48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00171.html#f43697a993f56955e3f9e353b3b1f210">service_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#4cfc8ad513bc76523d5348a71d320972">service_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The backend service implementation.  <a href="#4cfc8ad513bc76523d5348a71d320972"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00171.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html#da5cd4bcb34662066a3395c216c8c2b8">impl_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying native implementation.  <a href="#da5cd4bcb34662066a3395c216c8c2b8"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="c1e68987164e915e01be267e61e5564a"></a><!-- doxytag: member="asio::ssl::stream::next_layer_type" ref="c1e68987164e915e01be267e61e5564a" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef boost::remove_reference&lt;<a class="el" href="a00170.html">Stream</a>&gt;::type <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html#c1e68987164e915e01be267e61e5564a">next_layer_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type of the next layer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="90d5ffdfbbdd5d67a61516c38215f0d5"></a><!-- doxytag: member="asio::ssl::stream::lowest_layer_type" ref="90d5ffdfbbdd5d67a61516c38215f0d5" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef next_layer_type::lowest_layer_type <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html#90d5ffdfbbdd5d67a61516c38215f0d5">lowest_layer_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type of the lowest layer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a88158c5007f6c3cba0dcaea6724b104"></a><!-- doxytag: member="asio::ssl::stream::demuxer_type" ref="a88158c5007f6c3cba0dcaea6724b104" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef next_layer_type::demuxer_type <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The demuxer type for this asynchronous type. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="f43697a993f56955e3f9e353b3b1f210"></a><!-- doxytag: member="asio::ssl::stream::service_type" ref="f43697a993f56955e3f9e353b3b1f210" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef Service <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html#f43697a993f56955e3f9e353b3b1f210">service_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type of the service that will be used to provide stream operations. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="0ac43ba128daec432ece8d7eaecacbcb"></a><!-- doxytag: member="asio::ssl::stream::impl_type" ref="0ac43ba128daec432ece8d7eaecacbcb" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef service_type::impl_type <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The native implementation type of the stream. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="066a219e662971fd5181a43f888ab17f"></a><!-- doxytag: member="asio::ssl::stream::handshake_type" ref="066a219e662971fd5181a43f888ab17f" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f">asio::ssl::stream_base::handshake_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Different handshake types. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="066a219e662971fd5181a43f888ab17f62608e08adc29a8d6dbc9754e659f125"></a><!-- doxytag: member="client" ref="066a219e662971fd5181a43f888ab17f62608e08adc29a8d6dbc9754e659f125" args="" -->client</em>&nbsp;</td><td>
Perform handshaking as a client. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="066a219e662971fd5181a43f888ab17fcf1e8c14e54505f60aa10ceb8d5d8ab3"></a><!-- doxytag: member="server" ref="066a219e662971fd5181a43f888ab17fcf1e8c14e54505f60aa10ceb8d5d8ab3" args="" -->server</em>&nbsp;</td><td>
Perform handshaking as a server. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="880de7bc559a9c2ce3bd7a54f1d68520"></a><!-- doxytag: member="asio::ssl::stream::stream" ref="880de7bc559a9c2ce3bd7a54f1d68520" args="(Arg &amp;arg, basic_context&lt; Context_Service &gt; &amp;context)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Arg, typename Context_Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html">stream</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Arg &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>arg</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00112.html">basic_context</a>&lt; Context_Service &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>context</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [explicit]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a stream. 
<p>
This constructor creates a stream and initialises the underlying stream object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>The argument to be passed to initialise the underlying stream.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>The SSL context to be used for the stream. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4f6db94c5af2d9f27bef65874d668165"></a><!-- doxytag: member="asio::ssl::stream::~stream" ref="4f6db94c5af2d9f27bef65874d668165" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::~<a class="el" href="a00171.html">stream</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6afeb5e9a5b1a4fbbc83e784e9d07a99"></a><!-- doxytag: member="asio::ssl::stream::demuxer" ref="6afeb5e9a5b1a4fbbc83e784e9d07a99" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00171.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a>&amp; <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00115.html">demuxer</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the demuxer associated with the asynchronous object. 
<p>
This function may be used to obtain the demuxer object that the stream uses to dispatch handlers for asynchronous operations.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the demuxer object that stream will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0d289fdb710fbecd1d6adcca81fe0f37"></a><!-- doxytag: member="asio::ssl::stream::next_layer" ref="0d289fdb710fbecd1d6adcca81fe0f37" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00171.html#c1e68987164e915e01be267e61e5564a">next_layer_type</a>&amp; <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::next_layer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a reference to the next layer. 
<p>
This function returns a reference to the next layer in a stack of stream layers.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the next layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8884a12ca6ca736b3d4cdf885d0b6d07"></a><!-- doxytag: member="asio::ssl::stream::lowest_layer" ref="8884a12ca6ca736b3d4cdf885d0b6d07" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00171.html#90d5ffdfbbdd5d67a61516c38215f0d5">lowest_layer_type</a>&amp; <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::lowest_layer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a reference to the lowest layer. 
<p>
This function returns a reference to the lowest layer in a stack of stream layers.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="01610c26789d1c8c6c2ff679f386caf5"></a><!-- doxytag: member="asio::ssl::stream::impl" ref="01610c26789d1c8c6c2ff679f386caf5" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00171.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a> <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::impl           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the underlying implementation in the native type. 
<p>
This function may be used to obtain the underlying implementation of the context. This is intended to allow access to stream functionality that is not otherwise provided.     </td>
  </tr>
</table>
<a class="anchor" name="775fb41775f9ed292b74a886bf221b00"></a><!-- doxytag: member="asio::ssl::stream::handshake" ref="775fb41775f9ed292b74a886bf221b00" args="(handshake_type type)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::handshake           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f">handshake_type</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>type</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform SSL handshaking. 
<p>
This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00138.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fca706d4bedbae3fcc517043ee7c7180"></a><!-- doxytag: member="asio::ssl::stream::handshake" ref="fca706d4bedbae3fcc517043ee7c7180" args="(handshake_type type, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::handshake           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f">handshake_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform SSL handshaking. 
<p>
This function is used to perform SSL handshaking on the stream. The function call will block until handshaking is complete or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="74f2a4dab50807d2daf747477dc87575"></a><!-- doxytag: member="asio::ssl::stream::async_handshake" ref="74f2a4dab50807d2daf747477dc87575" args="(handshake_type type, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::async_handshake           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00172.html#066a219e662971fd5181a43f888ab17f">handshake_type</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous SSL handshake. 
<p>
This function is used to asynchronously perform an SSL handshake on the stream. This function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of handshaking to be performed, i.e. as a client or as a server.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error,     <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5352e1d5e4706796a03f7cfd4e0d6949"></a><!-- doxytag: member="asio::ssl::stream::shutdown" ref="5352e1d5e4706796a03f7cfd4e0d6949" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::shutdown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shut down SSL on the stream. 
<p>
This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00138.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1500c4b141c187db538e5f9aeaccd1be"></a><!-- doxytag: member="asio::ssl::stream::shutdown" ref="1500c4b141c187db538e5f9aeaccd1be" args="(Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::shutdown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Error_Handler&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>error_handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shut down SSL on the stream. 
<p>
This function is used to shut down SSL on the stream. The function call will block until SSL has been shut down or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4a0d9f5888238c9c4fb8b6afabe69f24"></a><!-- doxytag: member="asio::ssl::stream::async_shutdown" ref="4a0d9f5888238c9c4fb8b6afabe69f24" args="(Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::async_shutdown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Handler&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Asynchronously shut down SSL on the stream. 
<p>
This function is used to asynchronously shut down SSL on the stream. This function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the handshake operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error,     <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f96dffab0c878d59c4bf48127471d75b"></a><!-- doxytag: member="asio::ssl::stream::write" ref="f96dffab0c878d59c4bf48127471d75b" args="(const Const_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00128.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write some data to the stream. 
<p>
This function is used to write data to the stream. The function call will block until the data has been written successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written to the stream.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00138.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The write operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00287.html#gbe179bb6636a93b5f4538402e64f89a6">asio::write_n()</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e2891dd0bb45545ef4c4aae3e8434dce"></a><!-- doxytag: member="asio::ssl::stream::write" ref="e2891dd0bb45545ef4c4aae3e8434dce" args="(const Const_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00128.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write some data to the stream. 
<p>
This function is used to write data to the stream. The function call will block until the data has been written successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written to the stream.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written. cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The write operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00287.html#gbe179bb6636a93b5f4538402e64f89a6">asio::write_n()</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b2ca2c762662202865f65a3389789595"></a><!-- doxytag: member="asio::ssl::stream::async_write" ref="b2ca2c762662202865f65a3389789595" args="(const Const_Buffers &amp;buffers, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::async_write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00128.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous write. 
<p>
This function is used to asynchronously write data to the stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error,     <span class="comment">// Result of operation</span>
   std::size_t bytes_transferred <span class="comment">// Number of bytes written</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The write operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00288.html#gf2921160d147610e131c3882a3964f90">asio::async_write_n()</a> function if you need to ensure that all data is written before the asynchronous operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f50aab50daa68c84d02b06633fc6e621"></a><!-- doxytag: member="asio::ssl::stream::read" ref="f50aab50daa68c84d02b06633fc6e621" args="(const Mutable_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00138.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The read operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00281.html#g4960651e51196ea1bb3b0621ede932c3">asio::read_n()</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2ad69e98019814679f4e480b26ce27e5"></a><!-- doxytag: member="asio::ssl::stream::read" ref="2ad69e98019814679f4e480b26ce27e5" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the connection was closed cleanly.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The read operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00281.html#g4960651e51196ea1bb3b0621ede932c3">asio::read_n()</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="11212cb2acb4bc1c05205e679cdc0528"></a><!-- doxytag: member="asio::ssl::stream::async_read" ref="11212cb2acb4bc1c05205e679cdc0528" args="(const Mutable_Buffers &amp;buffers, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::async_read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous read. 
<p>
This function is used to asynchronously read data from the stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error,     <span class="comment">// Result of operation</span>
   std::size_t bytes_transferred <span class="comment">// Number of bytes read</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The read operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00282.html#g8e4ed20c71f6628b9feb0715054cd142">asio::async_read_n()</a> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="32081c0c9f6f616ccd8ff6ce09c7c7b8"></a><!-- doxytag: member="asio::ssl::stream::peek" ref="32081c0c9f6f616ccd8ff6ce09c7c7b8" args="(const Mutable_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::peek           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the connection was closed cleanly.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00138.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fb658c4ce8b9d216dd4bfb64a292cd90"></a><!-- doxytag: member="asio::ssl::stream::peek" ref="fb658c4ce8b9d216dd4bfb64a292cd90" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::peek           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, withoutxi removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the connection was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0176623c6cd6d0f41c90bf3f2dfb225"></a><!-- doxytag: member="asio::ssl::stream::in_avail" ref="a0176623c6cd6d0f41c90bf3f2dfb225" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::in_avail           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the amount of data that may be read without blocking. 
<p>
This function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00138.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="50ebac28ba9e853abb18fa6149908c82"></a><!-- doxytag: member="asio::ssl::stream::in_avail" ref="50ebac28ba9e853abb18fa6149908c82" args="(Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::in_avail           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Error_Handler&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>error_handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the amount of data that may be read without blocking. 
<p>
This function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00138.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="bf7ab454da0f2a4bdfbe77eb5c9c1c48"></a><!-- doxytag: member="asio::ssl::stream::next_layer_" ref="bf7ab454da0f2a4bdfbe77eb5c9c1c48" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00170.html">Stream</a> <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html#bf7ab454da0f2a4bdfbe77eb5c9c1c48">next_layer_</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The next layer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="4cfc8ad513bc76523d5348a71d320972"></a><!-- doxytag: member="asio::ssl::stream::service_" ref="4cfc8ad513bc76523d5348a71d320972" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00171.html#f43697a993f56955e3f9e353b3b1f210">service_type</a>&amp; <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html#4cfc8ad513bc76523d5348a71d320972">service_</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The backend service implementation. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="da5cd4bcb34662066a3395c216c8c2b8"></a><!-- doxytag: member="asio::ssl::stream::impl_" ref="da5cd4bcb34662066a3395c216c8c2b8" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Stream, typename Service = stream_service&lt;&gt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00171.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a> <a class="el" href="a00171.html">asio::ssl::stream</a>&lt; <a class="el" href="a00170.html">Stream</a>, Service &gt;::<a class="el" href="a00171.html#da5cd4bcb34662066a3395c216c8c2b8">impl_</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The underlying native implementation. 
<p>
    </td>
  </tr>
</table>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.4</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
