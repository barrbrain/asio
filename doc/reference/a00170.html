<HTML>
  <HEAD>
    <TITLE>asio Reference: Stream Class Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.4</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.5 -->
<h1>Stream Class Reference</h1><!-- doxytag: class="Stream" --><!-- doxytag: inherits="Async_Read_Stream,Async_Write_Stream,Sync_Read_Stream,Sync_Write_Stream" -->Inherits <a class="el" href="a00110.html">Async_Read_Stream</a>, <a class="el" href="a00111.html">Async_Write_Stream</a>, <a class="el" href="a00175.html">Sync_Read_Stream</a>, and <a class="el" href="a00176.html">Sync_Write_Stream</a>.
<p>
<a href="a00089.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Stream concept. 
<p>
<dl compact><dt><b>Implemented By:</b></dt><dd><a class="el" href="a00120.html">asio::basic_stream_socket</a> <br>
 <a class="el" href="a00123.html">asio::buffered_read_stream</a> <br>
 <a class="el" href="a00125.html">asio::buffered_write_stream</a> <br>
 <a class="el" href="a00124.html">asio::buffered_stream</a> </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html#90d5ffdfbbdd5d67a61516c38215f0d5">lowest_layer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the lowest layer in the stream.  <a href="#90d5ffdfbbdd5d67a61516c38215f0d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The demuxer type for this asynchronous object.  <a href="#a88158c5007f6c3cba0dcaea6724b104"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The demuxer type for this asynchronous object.  <a href="#a88158c5007f6c3cba0dcaea6724b104"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00170.html#90d5ffdfbbdd5d67a61516c38215f0d5">lowest_layer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html#8884a12ca6ca736b3d4cdf885d0b6d07">lowest_layer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#8884a12ca6ca736b3d4cdf885d0b6d07"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00110.html#11212cb2acb4bc1c05205e679cdc0528">async_read</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous read.  <a href="#11212cb2acb4bc1c05205e679cdc0528"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00109.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#6afeb5e9a5b1a4fbbc83e784e9d07a99">demuxer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the demuxer associated with the asynchronous object.  <a href="#6afeb5e9a5b1a4fbbc83e784e9d07a99"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00111.html#b2ca2c762662202865f65a3389789595">async_write</a> (const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write.  <a href="#b2ca2c762662202865f65a3389789595"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00109.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#6afeb5e9a5b1a4fbbc83e784e9d07a99">demuxer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the demuxer associated with the asynchronous object.  <a href="#6afeb5e9a5b1a4fbbc83e784e9d07a99"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00175.html#f50aab50daa68c84d02b06633fc6e621">read</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream.  <a href="#f50aab50daa68c84d02b06633fc6e621"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00175.html#2ad69e98019814679f4e480b26ce27e5">read</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the stream.  <a href="#2ad69e98019814679f4e480b26ce27e5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00175.html#32081c0c9f6f616ccd8ff6ce09c7c7b8">peek</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#32081c0c9f6f616ccd8ff6ce09c7c7b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00175.html#fb658c4ce8b9d216dd4bfb64a292cd90">peek</a> (const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream.  <a href="#fb658c4ce8b9d216dd4bfb64a292cd90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html#a0176623c6cd6d0f41c90bf3f2dfb225">in_avail</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#a0176623c6cd6d0f41c90bf3f2dfb225"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00175.html#50ebac28ba9e853abb18fa6149908c82">in_avail</a> (Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#50ebac28ba9e853abb18fa6149908c82"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00176.html#f96dffab0c878d59c4bf48127471d75b">write</a> (const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the given data on the stream.  <a href="#f96dffab0c878d59c4bf48127471d75b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00176.html#e2891dd0bb45545ef4c4aae3e8434dce">write</a> (const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the given data on the stream.  <a href="#e2891dd0bb45545ef4c4aae3e8434dce"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="90d5ffdfbbdd5d67a61516c38215f0d5"></a><!-- doxytag: member="Stream::lowest_layer_type" ref="90d5ffdfbbdd5d67a61516c38215f0d5" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef implementation_defined <a class="el" href="a00170.html#90d5ffdfbbdd5d67a61516c38215f0d5">Stream::lowest_layer_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type of the lowest layer in the stream. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a88158c5007f6c3cba0dcaea6724b104"></a><!-- doxytag: member="Stream::demuxer_type" ref="a88158c5007f6c3cba0dcaea6724b104" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef implementation_defined <a class="el" href="a00109.html#a88158c5007f6c3cba0dcaea6724b104">Async_Object::demuxer_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The demuxer type for this asynchronous object. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a88158c5007f6c3cba0dcaea6724b104"></a><!-- doxytag: member="Stream::demuxer_type" ref="a88158c5007f6c3cba0dcaea6724b104" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef implementation_defined <a class="el" href="a00109.html#a88158c5007f6c3cba0dcaea6724b104">Async_Object::demuxer_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The demuxer type for this asynchronous object. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8884a12ca6ca736b3d4cdf885d0b6d07"></a><!-- doxytag: member="Stream::lowest_layer" ref="8884a12ca6ca736b3d4cdf885d0b6d07" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00170.html#90d5ffdfbbdd5d67a61516c38215f0d5">lowest_layer_type</a>&amp; Stream::lowest_layer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a reference to the lowest layer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="11212cb2acb4bc1c05205e679cdc0528"></a><!-- doxytag: member="Stream::async_read" ref="11212cb2acb4bc1c05205e679cdc0528" args="(const Mutable_Buffers &amp;buffers, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void Async_Read_Stream::async_read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous read. 
<p>
This function is used to asynchronously read data from the stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> implementation_defined&amp; error, <span class="comment">// Result of operation</span>
   std::size_t bytes_transferred        <span class="comment">// Number of bytes read</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6afeb5e9a5b1a4fbbc83e784e9d07a99"></a><!-- doxytag: member="Stream::demuxer" ref="6afeb5e9a5b1a4fbbc83e784e9d07a99" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00109.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a>&amp; Async_Object::demuxer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the demuxer associated with the asynchronous object. 
<p>
This function may be used to obtain the demuxer object that the object uses to dispatch handlers for asynchronous operations.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the demuxer object that the object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="b2ca2c762662202865f65a3389789595"></a><!-- doxytag: member="Stream::async_write" ref="b2ca2c762662202865f65a3389789595" args="(const Const_Buffers &amp;buffers, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void Async_Write_Stream::async_write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00128.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous write. 
<p>
This function is used to asynchronously write data on the stream. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written to the socket. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> implementation_defined&amp; error, <span class="comment">// Result of operation</span>
   std::size_t bytes_transferred        <span class="comment">// Number of bytes written</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6afeb5e9a5b1a4fbbc83e784e9d07a99"></a><!-- doxytag: member="Stream::demuxer" ref="6afeb5e9a5b1a4fbbc83e784e9d07a99" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00109.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a>&amp; Async_Object::demuxer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the demuxer associated with the asynchronous object. 
<p>
This function may be used to obtain the demuxer object that the object uses to dispatch handlers for asynchronous operations.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the demuxer object that the object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f50aab50daa68c84d02b06633fc6e621"></a><!-- doxytag: member="Stream::read" ref="f50aab50daa68c84d02b06633fc6e621" args="(const Mutable_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t Sync_Read_Stream::read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>implementation_defined</em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2ad69e98019814679f4e480b26ce27e5"></a><!-- doxytag: member="Stream::read" ref="2ad69e98019814679f4e480b26ce27e5" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t Sync_Read_Stream::read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from the stream. 
<p>
This function is used to read data from the stream. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> implementation_defined&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="32081c0c9f6f616ccd8ff6ce09c7c7b8"></a><!-- doxytag: member="Stream::peek" ref="32081c0c9f6f616ccd8ff6ce09c7c7b8" args="(const Mutable_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t Sync_Read_Stream::peek           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>implementation_defined</em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fb658c4ce8b9d216dd4bfb64a292cd90"></a><!-- doxytag: member="Stream::peek" ref="fb658c4ce8b9d216dd4bfb64a292cd90" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t Sync_Read_Stream::peek           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the incoming data on the stream. 
<p>
This function is used to peek at the incoming data on the stream, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> implementation_defined&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0176623c6cd6d0f41c90bf3f2dfb225"></a><!-- doxytag: member="Stream::in_avail" ref="a0176623c6cd6d0f41c90bf3f2dfb225" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">std::size_t Sync_Read_Stream::in_avail           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the amount of data that may be read without blocking. 
<p>
The function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>implementation_defined</em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="50ebac28ba9e853abb18fa6149908c82"></a><!-- doxytag: member="Stream::in_avail" ref="50ebac28ba9e853abb18fa6149908c82" args="(Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t Sync_Read_Stream::in_avail           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Error_Handler&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>error_handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the amount of data that may be read without blocking. 
<p>
The function is used to determine the amount of data, in bytes, that may be read from the stream without blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> implementation_defined&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f96dffab0c878d59c4bf48127471d75b"></a><!-- doxytag: member="Stream::write" ref="f96dffab0c878d59c4bf48127471d75b" args="(const Const_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t Sync_Write_Stream::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00128.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the given data on the stream. 
<p>
This function is used to write data on the stream. The function call will block until some or all of the data has been written successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written or 0 if the stream was closed cleanly.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>implementation_specified</em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e2891dd0bb45545ef4c4aae3e8434dce"></a><!-- doxytag: member="Stream::write" ref="e2891dd0bb45545ef4c4aae3e8434dce" args="(const Const_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t Sync_Write_Stream::write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00128.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inherited]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write the given data on the stream. 
<p>
This function is used to write data on the stream. The function call will block until some or all of the data has been written successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>The data to be written.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> implementation_defined&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written or 0 if the stream was closed cleanly. </dd></dl>
    </td>
  </tr>
</table>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.4</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
