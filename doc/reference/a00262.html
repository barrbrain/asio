<HTML>
  <HEAD>
    <TITLE>asio Reference: asio Namespace Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1>asio Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The asio namespace defines all user-accessible classes and templates. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">basic_datagram_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides datagram-oriented socket functionality.  <a href="a00105.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">basic_deadline_timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides waitable timer functionality.  <a href="a00106.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">basic_io_object</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for all I/O objects.  <a href="a00108.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">basic_resolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides endpoint resolution functionality.  <a href="a00109.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">basic_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides socket functionality.  <a href="a00113.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">basic_socket_acceptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides the ability to accept new connections.  <a href="a00114.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">basic_socket_iostream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iostream interface for a socket.  <a href="a00115.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">basic_socketbuf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iostream streambuf for a socket.  <a href="a00116.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">basic_strand</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides serialised handler execution.  <a href="a00117.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">basic_stream_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides stream-oriented socket functionality.  <a href="a00118.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">basic_streambuf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Automatically resizable buffer class based on std::streambuf.  <a href="a00119.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">mutable_buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds a buffer that can be modified.  <a href="a00148.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html">mutable_buffer_container_1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adapts a single modifiable buffer so that it meets the requirements of the <a class="el" href="a00150.html">Mutable_Buffers</a> concept.  <a href="a00149.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">const_buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds a buffer that cannot be modified.  <a href="a00125.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">const_buffer_container_1</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adapts a single non-modifiable buffer so that it meets the requirements of the <a class="el" href="a00127.html">Const_Buffers</a> concept.  <a href="a00126.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">buffered_read_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the read-related operations of a stream.  <a href="a00122.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">buffered_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the read- and write-related operations of a stream.  <a href="a00123.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">buffered_write_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the write-related operations of a stream.  <a href="a00124.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">datagram_socket_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a datagram socket.  <a href="a00131.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">deadline_timer_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a timer.  <a href="a00132.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The error class is used to encapsulate system error codes.  <a href="a00135.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">io_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides core I/O functionality.  <a href="a00140.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">service_already_exists</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when trying to add a duplicate service to an <a class="el" href="a00140.html">io_service</a>.  <a href="a00154.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">invalid_service_owner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown when trying to add a service object to an <a class="el" href="a00140.html">io_service</a> where the service has a different owner.  <a href="a00138.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00145.html">is_read_buffered</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00145.html">is_read_buffered</a> class is a traits class that may be used to determine whether a stream type supports buffering of read data.  <a href="a00145.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">is_write_buffered</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00146.html">is_write_buffered</a> class is a traits class that may be used to determine whether a stream type supports buffering of written data.  <a href="a00146.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">resolver_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a resolver.  <a href="a00153.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">socket_acceptor_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a socket acceptor.  <a href="a00156.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">socket_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00157.html">socket_base</a> class is used as a base for the <a class="el" href="a00118.html">basic_stream_socket</a> and <a class="el" href="a00105.html">basic_datagram_socket</a> class templates so that we have a common place to define the shutdown_type and enum.  <a href="a00157.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">strand_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a strand.  <a href="a00159.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html">stream_socket_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a stream socket.  <a href="a00164.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">system_exception</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00167.html">system_exception</a> class is used to represent system conditions that prevent the library from operating correctly.  <a href="a00167.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html">thread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple abstraction for starting threads.  <a href="a00169.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">time_traits&lt; boost::posix_time::ptime &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time traits specialised for posix_time.  <a href="a00170.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00266.html">placeholders</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00266.html">asio::placeholders</a> namespace defines argument placeholders for use with <a class="el" href="boost_bind.html">boost::bind</a>. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html">ip</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00264.html">asio::ip</a> namespace defines the classes associated with IP. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">ssl</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00268.html">asio::ssl</a> namespace defines templates and classes for SSL. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00106.html">basic_deadline_timer</a>&lt;<br>
 boost::posix_time::ptime &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#9c1e57628983c6b9c45e9204228109b7">deadline_timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of timer.  <a href="#9c1e57628983c6b9c45e9204228109b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00117.html">basic_strand</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#6b7ed9dbdc34fb690ffd6a01ef015c22">strand</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of strand.  <a href="#6b7ed9dbdc34fb690ffd6a01ef015c22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00119.html">basic_streambuf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#6a7ba348943527312eeace3492bf32ee">streambuf</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of <a class="el" href="a00119.html">basic_streambuf</a>.  <a href="#6a7ba348943527312eeace3492bf32ee"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html#ga5592a9ee32b5c753466edc0af005edb">buffer</a> (const <a class="el" href="a00148.html">mutable_buffer</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="a00270.html#ga5592a9ee32b5c753466edc0af005edb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html#g1a09b624727bb0b04289f223c5f10e81">buffer</a> (const <a class="el" href="a00148.html">mutable_buffer</a> &amp;b, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="a00270.html#g1a09b624727bb0b04289f223c5f10e81"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html#g90ce7b6e19f581a733d106c31d5c1868">buffer</a> (const <a class="el" href="a00125.html">const_buffer</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="a00270.html#g90ce7b6e19f581a733d106c31d5c1868"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html#g88617790f9916380137f772bbbb753db">buffer</a> (const <a class="el" href="a00125.html">const_buffer</a> &amp;b, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="a00270.html#g88617790f9916380137f772bbbb753db"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html#g9de0d8a97029987b6fc1b8fda66717b7">buffer</a> (void *data, std::size_t size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <a href="a00270.html#g9de0d8a97029987b6fc1b8fda66717b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html#g3fab8e6179c30a71252ff6cd09d65c38">buffer</a> (const void *data, std::size_t size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <a href="a00270.html#g3fab8e6179c30a71252ff6cd09d65c38"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g51effca9997ed41a2c1b9b3463bdbd58">buffer</a> (Pod_Type(&amp;data)[N])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="a00270.html#g51effca9997ed41a2c1b9b3463bdbd58"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#gacf0b5cde83d330866e168ce336efa87">buffer</a> (Pod_Type(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="a00270.html#gacf0b5cde83d330866e168ce336efa87"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g6825130cb7ca690ed9cf316442bec8d5">buffer</a> (const Pod_Type(&amp;data)[N])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00270.html#g6825130cb7ca690ed9cf316442bec8d5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#ge48fb9d9896305367e34bcc3c92c81d0">buffer</a> (const Pod_Type(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00270.html#ge48fb9d9896305367e34bcc3c92c81d0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#gea387affe46cd0138cf093c073dc9f96">buffer</a> (boost::array&lt; Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="a00270.html#gea387affe46cd0138cf093c073dc9f96"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g1e25e36e4ed122c9821abbe4a7627d54">buffer</a> (boost::array&lt; Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="a00270.html#g1e25e36e4ed122c9821abbe4a7627d54"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g0c2be549dfac5c2fffa455c6aceb0215">buffer</a> (boost::array&lt; const Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00270.html#g0c2be549dfac5c2fffa455c6aceb0215"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g406033d9875a6d902e5b297d1abc9865">buffer</a> (boost::array&lt; const Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00270.html#g406033d9875a6d902e5b297d1abc9865"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#gc6d168bb93ae64d6769a5dcee5bea06f">buffer</a> (const boost::array&lt; Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00270.html#gc6d168bb93ae64d6769a5dcee5bea06f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#gd4476295b0e3056ce9709895aa095924">buffer</a> (const boost::array&lt; Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00270.html#gd4476295b0e3056ce9709895aa095924"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g6f4cb01d3bdc1dbcd1ebcad0b3ad3432">buffer</a> (std::vector&lt; Pod_Type, Allocator &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="a00270.html#g6f4cb01d3bdc1dbcd1ebcad0b3ad3432"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00149.html">mutable_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g12cf2143079d59746eccf48faa0670f7">buffer</a> (std::vector&lt; Pod_Type, Allocator &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="a00270.html#g12cf2143079d59746eccf48faa0670f7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g21659e112b60adc9595c5a3b5ae6514b">buffer</a> (const std::vector&lt; Pod_Type, Allocator &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="a00270.html#g21659e112b60adc9595c5a3b5ae6514b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00270.html#g1d04901f7b2c62ee9c030b1a24012438">buffer</a> (const std::vector&lt; Pod_Type, Allocator &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="a00270.html#g1d04901f7b2c62ee9c030b1a24012438"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html#g69ce7de2aeed6db7ec64a9512ee31631">buffer</a> (const std::string &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="a00270.html#g69ce7de2aeed6db7ec64a9512ee31631"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer_container_1</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html#gdd18e0b50cc1cf92d2d6d2fc01fe8f04">buffer</a> (const std::string &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="a00270.html#gdd18e0b50cc1cf92d2d6d2fc01fe8f04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unspecified&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00271.html#g750bf6e293973be0ed8e2c7a085457f7">transfer_all</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a completion condition function object that indicates that a read or write operation should continue until all of the data has been transferred, or until an error occurs.  <a href="a00271.html#g750bf6e293973be0ed8e2c7a085457f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unspecified&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00271.html#gdba1ed43445276e2b563a59663ca26cd">transfer_at_least</a> (std::size_t minimum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a completion condition function object that indicates that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs.  <a href="a00271.html#gdba1ed43445276e2b563a59663ca26cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unspecified&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html#g5323342b09947e6236f60a4b227fdc31">ignore_error</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a function object that always ignores the error.  <a href="a00272.html#g5323342b09947e6236f60a4b227fdc31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unspecified&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html#g17eebda462da83c5c2143f2fd77a840a">throw_error</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a function object that always throws the error.  <a href="a00272.html#g17eebda462da83c5c2143f2fd77a840a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Target&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">unspecified&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00272.html#g3acdd36b40ce607c82b0ad32ad1502e8">assign_error</a> (Target &amp;target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a function object that assigns the error to a variable.  <a href="a00272.html#g3acdd36b40ce607c82b0ad32ad1502e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#7c5db840bb5527dcd8ee36274c28bb69">asio_handler_allocate</a> (std::size_t size,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default allocation function for handlers.  <a href="#7c5db840bb5527dcd8ee36274c28bb69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#1316007445a73023bc5603a69c97d9b7">asio_handler_deallocate</a> (void *pointer, std::size_t size,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default deallocation function for handlers.  <a href="#1316007445a73023bc5603a69c97d9b7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97">read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Completion_Condition&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#g5a66d11d5f37678b0709988bd073f7ee">read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Completion_Condition completion_condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="a00273.html#g5a66d11d5f37678b0709988bd073f7ee"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Completion_Condition, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#g3dab7d992a5157f5cb01f6194445428d">read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Completion_Condition completion_condition, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="a00273.html#g3dab7d992a5157f5cb01f6194445428d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#gd164d73ad6260d5c818538bbc5c350d2">read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="a00273.html#gd164d73ad6260d5c818538bbc5c350d2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator, typename Completion_Condition&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#gb3ab298e5acd32a06f1f9b4aea0a23fb">read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="a00273.html#gb3ab298e5acd32a06f1f9b4aea0a23fb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator, typename Completion_Condition, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#geff3e9835551cdbd1ad2a517e4bc2929">read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="a00273.html#geff3e9835551cdbd1ad2a517e4bc2929"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#ge727276ea9c106232f7cf81a43537b0d">async_read</a> (<a class="el" href="a00102.html">Async_Read_Stream</a> &amp;s, const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="a00274.html#ge727276ea9c106232f7cf81a43537b0d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Mutable_Buffers, typename Completion_Condition, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g42e587142f16da4428d57de92d352adf">async_read</a> (<a class="el" href="a00102.html">Async_Read_Stream</a> &amp;s, const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Completion_Condition completion_condition, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="a00274.html#g42e587142f16da4428d57de92d352adf"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Allocator, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g810ac88c568318f549bfaa53b068d98c">async_read</a> (<a class="el" href="a00102.html">Async_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="a00274.html#g810ac88c568318f549bfaa53b068d98c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Allocator, typename Completion_Condition, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00274.html#g78d1cac4b6c939ba6ff31da46e6c20d5">async_read</a> (<a class="el" href="a00102.html">Async_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="a00274.html#g78d1cac4b6c939ba6ff31da46e6c20d5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00275.html#g6c91d7ddc5b690a4d7a878723bd79a97">read_until</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a delimiter is encountered.  <a href="a00275.html#g6c91d7ddc5b690a4d7a878723bd79a97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00275.html#ga5d38d62df12b2404712bb38be08fe14">read_until</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a delimiter is encountered.  <a href="a00275.html#ga5d38d62df12b2404712bb38be08fe14"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00275.html#g1ad1e2b12c321b30826b67a92572b430">read_until</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a regular expression is located.  <a href="a00275.html#g1ad1e2b12c321b30826b67a92572b430"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00275.html#g6d020f4615f95350c0d2fe46b440c51e">read_until</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a regular expression is located.  <a href="a00275.html#g6d020f4615f95350c0d2fe46b440c51e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Allocator, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#ga8436a772555e39eadd00fcaaa851d27">async_read_until</a> (<a class="el" href="a00102.html">Async_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until a delimiter is encountered.  <a href="a00276.html#ga8436a772555e39eadd00fcaaa851d27"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Allocator, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g0d3e0e921716e4bee8cd9aa386a4d116">async_read_until</a> (<a class="el" href="a00102.html">Async_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until a regular expression is located.  <a href="a00276.html#g0d3e0e921716e4bee8cd9aa386a4d116"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g90a4f96d2ddfc1da8ec7edf9790394cb">write</a> (<a class="el" href="a00166.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00127.html">Const_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="a00277.html#g90a4f96d2ddfc1da8ec7edf9790394cb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers, typename Completion_Condition&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#gaed39a891eeea98f91b2dfa155af8206">write</a> (<a class="el" href="a00166.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00127.html">Const_Buffers</a> &amp;buffers, Completion_Condition completion_condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="a00277.html#gaed39a891eeea98f91b2dfa155af8206"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers, typename Completion_Condition, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g72f8e357bc20a6936e021a7d089ec6c2">write</a> (<a class="el" href="a00166.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00127.html">Const_Buffers</a> &amp;buffers, Completion_Condition completion_condition, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="a00277.html#g72f8e357bc20a6936e021a7d089ec6c2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g15d9e545634a60483d3de47ec0b05486">write</a> (<a class="el" href="a00166.html">Sync_Write_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="a00277.html#g15d9e545634a60483d3de47ec0b05486"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Allocator, typename Completion_Condition&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g2a7fcbacb9c1ea096de033c7ce915f03">write</a> (<a class="el" href="a00166.html">Sync_Write_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="a00277.html#g2a7fcbacb9c1ea096de033c7ce915f03"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Allocator, typename Completion_Condition, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#ge6841b6683cb356da9eb09568d7ef4f1">write</a> (<a class="el" href="a00166.html">Sync_Write_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="a00277.html#ge6841b6683cb356da9eb09568d7ef4f1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Write_Stream, typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#gc4e9ca3dfebb088adbf61cdf102eb250">async_write</a> (<a class="el" href="a00103.html">Async_Write_Stream</a> &amp;s, const <a class="el" href="a00127.html">Const_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to write of all of the supplied data to a stream.  <a href="a00278.html#gc4e9ca3dfebb088adbf61cdf102eb250"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Write_Stream, typename Const_Buffers, typename Completion_Condition, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#g445b2f12354859f7efb4e353586affd0">async_write</a> (<a class="el" href="a00103.html">Async_Write_Stream</a> &amp;s, const <a class="el" href="a00127.html">Const_Buffers</a> &amp;buffers, Completion_Condition completion_condition, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="a00278.html#g445b2f12354859f7efb4e353586affd0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Write_Stream, typename Allocator, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#gd63487da9dd1b2b0419592f464820ba3">async_write</a> (<a class="el" href="a00103.html">Async_Write_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="a00278.html#gd63487da9dd1b2b0419592f464820ba3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Write_Stream, typename Allocator, typename Completion_Condition, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#g9ed9b42f57c97dec36175100b142f06f">async_write</a> (<a class="el" href="a00103.html">Async_Write_Stream</a> &amp;s, <a class="el" href="a00119.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="a00278.html#g9ed9b42f57c97dec36175100b142f06f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Service&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Service &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#95ed96d24826e96bab95fcda922350eb">use_service</a> (<a class="el" href="a00140.html">io_service</a> &amp;ios)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Service&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#7da4c01c3d80911286f2b49a848bf287">add_service</a> (<a class="el" href="a00140.html">io_service</a> &amp;ios, Service *svc)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Service&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#5ec72ed6d5f9d4b70920a52affeef069">has_service</a> (<a class="el" href="a00140.html">io_service</a> &amp;ios)</td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="9c1e57628983c6b9c45e9204228109b7"></a><!-- doxytag: member="asio::deadline_timer" ref="9c1e57628983c6b9c45e9204228109b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00106.html">basic_deadline_timer</a>&lt;boost::posix_time::ptime&gt; <a class="el" href="a00106.html">asio::deadline_timer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Typedef for the typical usage of timer. 
<p>

</div>
</div><p>
<a class="anchor" name="6b7ed9dbdc34fb690ffd6a01ef015c22"></a><!-- doxytag: member="asio::strand" ref="6b7ed9dbdc34fb690ffd6a01ef015c22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00117.html">basic_strand</a> <a class="el" href="a00117.html">asio::strand</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Typedef for the typical usage of strand. 
<p>

</div>
</div><p>
<a class="anchor" name="6a7ba348943527312eeace3492bf32ee"></a><!-- doxytag: member="asio::streambuf" ref="6a7ba348943527312eeace3492bf32ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00119.html">basic_streambuf</a> <a class="el" href="a00119.html">asio::streambuf</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Typedef for the typical usage of <a class="el" href="a00119.html">basic_streambuf</a>. 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="7c5db840bb5527dcd8ee36274c28bb69"></a><!-- doxytag: member="asio::asio_handler_allocate" ref="7c5db840bb5527dcd8ee36274c28bb69" args="(std::size_t size,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* asio::asio_handler_allocate           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default allocation function for handlers. 
<p>
Asynchronous operations may need to allocate temporary objects. Since asynchronous operations have a handler function object, these temporary objects can be said to be associated with the handler.<p>
Implement asio_handler_allocate and asio_handler_deallocate for your own handlers to provide custom allocation for these temporary objects.<p>
This default implementation is simply: <div class="fragment"><pre class="fragment"> return ::operator new(bytes);
</pre></div><p>
<dl compact><dt><b>Note:</b></dt><dd>All temporary objects associated with a handler will be deallocated before the upcall to the handler is performed. This allows the same memory to be reused for a subsequent asynchronous operation initiated by the handler.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keyword">class </span>my_handler;

 <span class="keywordtype">void</span>* <a class="code" href="a00262.html#7c5db840bb5527dcd8ee36274c28bb69">asio_handler_allocate</a>(std::size_t size, my_handler* context)
 {
   return ::operator new(size);
 }

 <span class="keywordtype">void</span> <a class="code" href="a00262.html#1316007445a73023bc5603a69c97d9b7">asio_handler_deallocate</a>(<span class="keywordtype">void</span>* pointer, std::size_t size,
     my_handler* context)
 {
   ::operator <span class="keyword">delete</span>(pointer);
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1316007445a73023bc5603a69c97d9b7"></a><!-- doxytag: member="asio::asio_handler_deallocate" ref="1316007445a73023bc5603a69c97d9b7" args="(void *pointer, std::size_t size,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asio::asio_handler_deallocate           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default deallocation function for handlers. 
<p>
Implement asio_handler_allocate and asio_handler_deallocate for your own handlers to provide custom allocation for the associated temporary objects.<p>
This default implementation is simply: <div class="fragment"><pre class="fragment"> ::operator <span class="keyword">delete</span>(pointer);
</pre></div><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="a00262.html#7c5db840bb5527dcd8ee36274c28bb69">asio_handler_allocate</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="95ed96d24826e96bab95fcda922350eb"></a><!-- doxytag: member="asio::use_service" ref="95ed96d24826e96bab95fcda922350eb" args="(io_service &amp;ios)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Service&amp; asio::use_service           </td>
          <td>(</td>
          <td class="paramtype">io_service &amp;&nbsp;</td>
          <td class="paramname"> <em>ios</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="a00140.html">io_service</a> will create a new instance of the service.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ios</em>&nbsp;</td><td>The <a class="el" href="a00140.html">io_service</a> object that owns the service.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7da4c01c3d80911286f2b49a848bf287"></a><!-- doxytag: member="asio::add_service" ref="7da4c01c3d80911286f2b49a848bf287" args="(io_service &amp;ios, Service *svc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::add_service           </td>
          <td>(</td>
          <td class="paramtype">io_service &amp;&nbsp;</td>
          <td class="paramname"> <em>ios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Service *&nbsp;</td>
          <td class="paramname"> <em>svc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to add a service to the <a class="el" href="a00140.html">io_service</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ios</em>&nbsp;</td><td>The <a class="el" href="a00140.html">io_service</a> object that owns the service.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>svc</em>&nbsp;</td><td>The service object. On success, ownership of the service object is transferred to the <a class="el" href="a00140.html">io_service</a>. When the <a class="el" href="a00140.html">io_service</a> object is destroyed, it will destroy the service object by performing: <div class="fragment"><pre class="fragment"> <span class="keyword">delete</span> static_cast&lt;io_service::service*&gt;(svc) 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00154.html">asio::service_already_exists</a></em>&nbsp;</td><td>Thrown if a service of the given type is already present in the <a class="el" href="a00140.html">io_service</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00138.html">asio::invalid_service_owner</a></em>&nbsp;</td><td>Thrown if the service's owning <a class="el" href="a00140.html">io_service</a> is not the <a class="el" href="a00140.html">io_service</a> object specified by the ios parameter. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="5ec72ed6d5f9d4b70920a52affeef069"></a><!-- doxytag: member="asio::has_service" ref="5ec72ed6d5f9d4b70920a52affeef069" args="(io_service &amp;ios)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool asio::has_service           </td>
          <td>(</td>
          <td class="paramtype">io_service &amp;&nbsp;</td>
          <td class="paramname"> <em>ios</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is used to determine whether the <a class="el" href="a00140.html">io_service</a> contains a service object corresponding to the given service type.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ios</em>&nbsp;</td><td>The <a class="el" href="a00140.html">io_service</a> object that owns the service.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A boolean indicating whether the <a class="el" href="a00140.html">io_service</a> contains the service. </dd></dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
