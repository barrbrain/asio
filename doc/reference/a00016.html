<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::basic_socket_streambuf&lt; Protocol, StreamSocketService &gt; Class Template Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc1</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.5.1 -->
<div class="nav">
<a class="el" href="a00125.html">asio</a>::<a class="el" href="a00016.html">basic_socket_streambuf</a></div>
<h1>asio::basic_socket_streambuf&lt; Protocol, StreamSocketService &gt; Class Template Reference</h1><!-- doxytag: class="asio::basic_socket_streambuf" --><!-- doxytag: inherits="asio::basic_socket&lt; Protocol, StreamSocketService &gt;" -->Inherits <a class="el" href="a00013.html">asio::basic_socket&lt; Protocol, StreamSocketService &gt;</a>.
<p>
Inheritance diagram for asio::basic_socket_streambuf&lt; Protocol, StreamSocketService &gt;:<p><center><img src="a00157.png" border="0" usemap="#a00158" alt="Inheritance graph"></center>
<map name="a00158">
<area href="a00013.html" shape="rect" coords="338,344,805,370" alt="">
<area href="a00008.html" shape="rect" coords="8,176,418,202" alt="">
<area doxygen="external.doxytags:" href="noncopyable.html" shape="rect" coords="374,8,500,34" alt="">
<area href="a00008.html" shape="rect" coords="256,85,618,112" alt="">
<area href="a00008.html" shape="rect" coords="442,176,792,202" alt="">
<area href="a00045.html" shape="rect" coords="816,176,986,202" alt="">
<area href="a00013.html" shape="rect" coords="413,253,821,280" alt="">
</map>
<a href="a00159.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Protocol, typename StreamSocketService = stream_socket_service&lt;Protocol&gt;&gt;<br>
 class asio::basic_socket_streambuf&lt; Protocol, StreamSocketService &gt;</h3>

Iostream streambuf for a socket. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol::endpoint&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The endpoint type.  <a href="#11c216e83e3cdb430922f3dd47315ab6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef StreamSocketService::native_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The native representation of a socket.  <a href="#c56ef6e34a007f65869a0eb1a0b96334"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Protocol&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The protocol type.  <a href="#5890addc84762c67f2b3f1723428721d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00013.html">basic_socket</a>&lt; Protocol,<br>
 StreamSocketService &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#7e749e9f9d470ab881564bd549473d2f">lowest_layer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="a00013.html">basic_socket</a> is always the lowest layer.  <a href="#7e749e9f9d470ab881564bd549473d2f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef StreamSocketService&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#ee6c059b568e190966f1307cc21a264d">service_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the service that will be used to provide I/O operations.  <a href="#ee6c059b568e190966f1307cc21a264d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef service_type::implementation_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#36e6f136c8c1249242e81597c34d8d29">implementation_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying implementation type of I/O object.  <a href="#36e6f136c8c1249242e81597c34d8d29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b">shutdown_receive</a> =  implementation_defined, 
<br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62">shutdown_send</a> =  implementation_defined, 
<br>
&nbsp;&nbsp;<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd">shutdown_both</a> =  implementation_defined
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Different ways a socket may be shutdown.  <a href="a00045.html#915e52ff147efd296350bba81f795c37">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">message_flags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitmask type for flags that can be passed to send and receive operations.  <a href="#c3cf77465dfedfe1979b5415cf32cc94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">broadcast</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to permit sending of broadcast messages.  <a href="#ee34d723e630ad0cc0b745ca5f6dc2ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">debug</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to enable socket-level debugging.  <a href="#d2c3c8844bdf08f6f74fae000d6d7217"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">do_not_route</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to prevent routing, use local interfaces only.  <a href="#4220b1b3fd7ca674d8adedb742d71680"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">keep_alive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to send keep-alives.  <a href="#493d09a6a851ec400a30e8f22adb9d74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">send_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send buffer size of a socket.  <a href="#8869a31e4367e9b62c08609dc89591b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">send_low_watermark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send low watermark.  <a href="#bff502237f6a2e248e68483e9ca6a0d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">receive_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive buffer size of a socket.  <a href="#d79401946636f3e91c1cc66436d1f975"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">receive_low_watermark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive low watermark.  <a href="#f487bc8987ef57e2c7469b40bba591a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">reuse_address</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to allow the socket to be bound to an address that is already in use.  <a href="#66ab5649a23766107c5da2a04993d8dc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">linger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to specify whether the socket lingers on close if unsent data is present.  <a href="#308e86dd1ee896dd26c07abf7e6ff1b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">enable_connection_aborted</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to report aborted connections on accept.  <a href="#9ef00aa2ca23006e9868f2ea46223aea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">non_blocking_io</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO control command to set the blocking mode of the socket.  <a href="#28512bf41a5983383e0f5968c6e0580d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef implementation_defined&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">bytes_readable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO control command to get the amount of data that can be read without blocking.  <a href="#bbde8e590fbb98dfa1685b9d435cb5dc"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#df6bb7f645f8d86612034c958f1f310b">basic_socket_streambuf</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="a00016.html">basic_socket_streambuf</a> without establishing a connection.  <a href="#df6bb7f645f8d86612034c958f1f310b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#6d670112a43382f31af936898033de85">~basic_socket_streambuf</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor flushes buffered data.  <a href="#6d670112a43382f31af936898033de85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00016.html">basic_socket_streambuf</a>&lt; Protocol,<br>
 StreamSocketService &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#c930d319e4a857ba503b4b135c287766">connect</a> (const <a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> &amp;endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Establish a connection.  <a href="#c930d319e4a857ba503b4b135c287766"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, ... , typename TN&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00016.html">basic_socket_streambuf</a>&lt; Protocol,<br>
 StreamSocketService &gt; *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00016.html#9da58feca85f098610a324963764e2b7">connect</a> (T1 t1,..., TN tn)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Establish a connection.  <a href="#9da58feca85f098610a324963764e2b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00016.html">basic_socket_streambuf</a>&lt; Protocol,<br>
 StreamSocketService &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html#b20151b479df75a311c727e64bb4fc1a">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the connection.  <a href="#b20151b479df75a311c727e64bb4fc1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html">lowest_layer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#cd1a03601cf874d77169f9294e6ebad4">lowest_layer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#cd1a03601cf874d77169f9294e6ebad4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#ddde141b21499e7918c5a93c3cbab1d1">open</a> (const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;protocol=<a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a>())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="#ddde141b21499e7918c5a93c3cbab1d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#9cd7189fb57ad92321affbae2e7bcd01">open</a> (const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;protocol, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="#9cd7189fb57ad92321affbae2e7bcd01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#452fbce78dff7c03c9906daa27d4163b">assign</a> (const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;protocol, const <a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a> &amp;native_socket)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="#452fbce78dff7c03c9906daa27d4163b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#21d132e623b0f1b9eb6af15e60e9aef4">assign</a> (const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;protocol, const <a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a> &amp;native_socket, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="#21d132e623b0f1b9eb6af15e60e9aef4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#d18a1f2f159d0d99aa088df9e58d1cfc">is_open</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the socket is open.  <a href="#d18a1f2f159d0d99aa088df9e58d1cfc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#3fa404892b34feff1f8e013ab7c3e7ee">close</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the socket.  <a href="#3fa404892b34feff1f8e013ab7c3e7ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#9e65e3e73aa11b017d355d902e9b6ddc">native</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the native socket representation.  <a href="#9e65e3e73aa11b017d355d902e9b6ddc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#8c93c7f90a9c2b44e1bedfa8f2fe63c8">cancel</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="#8c93c7f90a9c2b44e1bedfa8f2fe63c8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#1128f1e16ef26eb7fa9328548a2a08e9">cancel</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="#1128f1e16ef26eb7fa9328548a2a08e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#11fefda4db8247c58ada119040daedbe">at_mark</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="#11fefda4db8247c58ada119040daedbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#2fb2030562128667c88fe5f8cf613aa3">at_mark</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="#2fb2030562128667c88fe5f8cf613aa3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#1464a056487487ba19ac2a7ce633ffac">available</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="#1464a056487487ba19ac2a7ce633ffac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#f32340508e7c17e124418ebd1f48a0e4">available</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="#f32340508e7c17e124418ebd1f48a0e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#29f2660dcb63871f6ac50e5be2545194">bind</a> (const <a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> &amp;endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="#29f2660dcb63871f6ac50e5be2545194"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#7b65419efd4f773417c53221070d5a59">bind</a> (const <a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> &amp;endpoint, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="#7b65419efd4f773417c53221070d5a59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#9f590780830e8f00925fd07ebaa9e71b">connect</a> (const <a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> &amp;peer_endpoint, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="#9f590780830e8f00925fd07ebaa9e71b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#13862c86b40404249dc2ad54dbb81271">async_connect</a> (const <a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> &amp;peer_endpoint, ConnectHandler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous connect.  <a href="#13862c86b40404249dc2ad54dbb81271"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#f040b3c66c466f4184b690bb6904a3f3">set_option</a> (const SettableSocketOption &amp;option)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option on the socket.  <a href="#f040b3c66c466f4184b690bb6904a3f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#e42c5d5d6779b68fa068032814a969da">set_option</a> (const SettableSocketOption &amp;option, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option on the socket.  <a href="#e42c5d5d6779b68fa068032814a969da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#88d39aad400fa707d816639402d013b8">get_option</a> (GettableSocketOption &amp;option) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an option from the socket.  <a href="#88d39aad400fa707d816639402d013b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#8c40f85557f13e0e946a9b0395f9c313">get_option</a> (GettableSocketOption &amp;option, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an option from the socket.  <a href="#8c40f85557f13e0e946a9b0395f9c313"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#4fb5d33d2ebee7fc119c3060ab258cde">io_control</a> (IoControlCommand &amp;command)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="#4fb5d33d2ebee7fc119c3060ab258cde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#6fa2182e4e122c5e1a1a5c960ef41180">io_control</a> (IoControlCommand &amp;command, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="#6fa2182e4e122c5e1a1a5c960ef41180"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#efb7bdafc26eb3dd3b1a8c0559947754">local_endpoint</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="#efb7bdafc26eb3dd3b1a8c0559947754"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#2bec75bc112611561d8f13db299d72af">local_endpoint</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="#2bec75bc112611561d8f13db299d72af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#a190ca5477b3dcee0d9c9d97a427897a">remote_endpoint</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="#a190ca5477b3dcee0d9c9d97a427897a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#61cc239a1078a1a62589a2abedea8b76">remote_endpoint</a> (<a class="el" href="a00030.html">asio::error_code</a> &amp;ec) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="#61cc239a1078a1a62589a2abedea8b76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#f8b410b0be483ff3a9c03d67f754f02c">shutdown</a> (<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a> what)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="#f8b410b0be483ff3a9c03d67f754f02c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00030.html">asio::error_code</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html#7f07b5990a61e483ab24862912e695ae">shutdown</a> (<a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a> what, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="#7f07b5990a61e483ab24862912e695ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00032.html">asio::io_service</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html#e5208e056c92fa6130114d023a5bd8b0">io_service</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the <a class="el" href="a00032.html">io_service</a> associated with the object.  <a href="#e5208e056c92fa6130114d023a5bd8b0"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#356e1bd7da0353e5472028cdec742ed0">message_peek</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at incoming data without removing it from the input queue.  <a href="#356e1bd7da0353e5472028cdec742ed0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#b9f08ba445b7ce09ece5ac7beaa6e7c9">message_out_of_band</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process out-of-band data.  <a href="#b9f08ba445b7ce09ece5ac7beaa6e7c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#e27428a48d1a7113a95ea205b1e17978">message_do_not_route</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify that the data should not be subject to routing.  <a href="#e27428a48d1a7113a95ea205b1e17978"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">max_connections</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum length of the queue of pending incoming connections.  <a href="#85ee2a3ce0ec68ac8c026884c5bd3098"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="11c216e83e3cdb430922f3dd47315ab6"></a><!-- doxytag: member="asio::basic_socket_streambuf::endpoint_type" ref="11c216e83e3cdb430922f3dd47315ab6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename StreamSocketService = stream_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="a00016.html">asio::basic_socket_streambuf</a>&lt; Protocol, StreamSocketService &gt;::<a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The endpoint type. 
<p>

<p>
Reimplemented from <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">asio::basic_socket&lt; Protocol, StreamSocketService &gt;</a>.
</div>
</div><p>
<a class="anchor" name="c56ef6e34a007f65869a0eb1a0b96334"></a><!-- doxytag: member="asio::basic_socket_streambuf::native_type" ref="c56ef6e34a007f65869a0eb1a0b96334" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef StreamSocketService ::<a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::<a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The native representation of a socket. 
<p>

<p>
Reimplemented in <a class="el" href="a00017.html#a0969d4a0dc15031c1c47b8dfeed7c59">asio::basic_stream_socket&lt; Protocol, StreamSocketService &gt;</a>.
</div>
</div><p>
<a class="anchor" name="5890addc84762c67f2b3f1723428721d"></a><!-- doxytag: member="asio::basic_socket_streambuf::protocol_type" ref="5890addc84762c67f2b3f1723428721d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol  <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::<a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The protocol type. 
<p>

<p>
Reimplemented in <a class="el" href="a00017.html#50b36dfd32d1cca507415b41ab7274d9">asio::basic_stream_socket&lt; Protocol, StreamSocketService &gt;</a>.
</div>
</div><p>
<a class="anchor" name="7e749e9f9d470ab881564bd549473d2f"></a><!-- doxytag: member="asio::basic_socket_streambuf::lowest_layer_type" ref="7e749e9f9d470ab881564bd549473d2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00013.html">basic_socket</a>&lt;Protocol , StreamSocketService &gt; <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::<a class="el" href="a00013.html">lowest_layer_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A <a class="el" href="a00013.html">basic_socket</a> is always the lowest layer. 
<p>

</div>
</div><p>
<a class="anchor" name="ee6c059b568e190966f1307cc21a264d"></a><!-- doxytag: member="asio::basic_socket_streambuf::service_type" ref="ee6c059b568e190966f1307cc21a264d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef StreamSocketService  <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; StreamSocketService  &gt;::<a class="el" href="a00008.html#ee6c059b568e190966f1307cc21a264d">service_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of the service that will be used to provide I/O operations. 
<p>

</div>
</div><p>
<a class="anchor" name="36e6f136c8c1249242e81597c34d8d29"></a><!-- doxytag: member="asio::basic_socket_streambuf::implementation_type" ref="36e6f136c8c1249242e81597c34d8d29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef service_type::implementation_type <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; StreamSocketService  &gt;::<a class="el" href="a00008.html#36e6f136c8c1249242e81597c34d8d29">implementation_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The underlying implementation type of I/O object. 
<p>

</div>
</div><p>
<a class="anchor" name="c3cf77465dfedfe1979b5415cf32cc94"></a><!-- doxytag: member="asio::basic_socket_streambuf::message_flags" ref="c3cf77465dfedfe1979b5415cf32cc94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="a00045.html#c3cf77465dfedfe1979b5415cf32cc94">asio::socket_base::message_flags</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bitmask type for flags that can be passed to send and receive operations. 
<p>

</div>
</div><p>
<a class="anchor" name="ee34d723e630ad0cc0b745ca5f6dc2ba"></a><!-- doxytag: member="asio::basic_socket_streambuf::broadcast" ref="ee34d723e630ad0cc0b745ca5f6dc2ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to permit sending of broadcast messages. 
<p>
Implements the SOL_SOCKET/SO_BROADCAST socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2c3c8844bdf08f6f74fae000d6d7217"></a><!-- doxytag: member="asio::basic_socket_streambuf::debug" ref="d2c3c8844bdf08f6f74fae000d6d7217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to enable socket-level debugging. 
<p>
Implements the SOL_SOCKET/SO_DEBUG socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4220b1b3fd7ca674d8adedb742d71680"></a><!-- doxytag: member="asio::basic_socket_streambuf::do_not_route" ref="4220b1b3fd7ca674d8adedb742d71680" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to prevent routing, use local interfaces only. 
<p>
Implements the SOL_SOCKET/SO_DONTROUTE socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00005.html">asio::ip::udp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="493d09a6a851ec400a30e8f22adb9d74"></a><!-- doxytag: member="asio::basic_socket_streambuf::keep_alive" ref="493d09a6a851ec400a30e8f22adb9d74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to send keep-alives. 
<p>
Implements the SOL_SOCKET/SO_KEEPALIVE socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8869a31e4367e9b62c08609dc89591b2"></a><!-- doxytag: member="asio::basic_socket_streambuf::send_buffer_size" ref="8869a31e4367e9b62c08609dc89591b2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the send buffer size of a socket. 
<p>
Implements the SOL_SOCKET/SO_SNDBUF socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> option(8192);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bff502237f6a2e248e68483e9ca6a0d2"></a><!-- doxytag: member="asio::basic_socket_streambuf::send_low_watermark" ref="bff502237f6a2e248e68483e9ca6a0d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the send low watermark. 
<p>
Implements the SOL_SOCKET/SO_SNDLOWAT socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> option(1024);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d79401946636f3e91c1cc66436d1f975"></a><!-- doxytag: member="asio::basic_socket_streambuf::receive_buffer_size" ref="d79401946636f3e91c1cc66436d1f975" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the receive buffer size of a socket. 
<p>
Implements the SOL_SOCKET/SO_RCVBUF socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> option(8192);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f487bc8987ef57e2c7469b40bba591a3"></a><!-- doxytag: member="asio::basic_socket_streambuf::receive_low_watermark" ref="f487bc8987ef57e2c7469b40bba591a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option for the receive low watermark. 
<p>
Implements the SOL_SOCKET/SO_RCVLOWAT socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> option(1024);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> option;
 socket.get_option(option);
 <span class="keywordtype">int</span> size = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66ab5649a23766107c5da2a04993d8dc"></a><!-- doxytag: member="asio::basic_socket_streambuf::reuse_address" ref="66ab5649a23766107c5da2a04993d8dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to allow the socket to be bound to an address that is already in use. 
<p>
Implements the SOL_SOCKET/SO_REUSEADDR socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> option(<span class="keyword">true</span>);
 acceptor.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> option;
 acceptor.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="308e86dd1ee896dd26c07abf7e6ff1b5"></a><!-- doxytag: member="asio::basic_socket_streambuf::linger" ref="308e86dd1ee896dd26c07abf7e6ff1b5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to specify whether the socket lingers on close if unsent data is present. 
<p>
Implements the SOL_SOCKET/SO_LINGER socket option.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> option(<span class="keyword">true</span>, 30);
 socket.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.enabled();
 <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> timeout = option.timeout();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Linger_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ef00aa2ca23006e9868f2ea46223aea"></a><!-- doxytag: member="asio::basic_socket_streambuf::enable_connection_aborted" ref="9ef00aa2ca23006e9868f2ea46223aea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Socket option to report aborted connections on accept. 
<p>
Implements a custom socket option that determines whether or not an accept operation is permitted to fail with <a class="el" href="a00029.html#9bf2f12d5c023d03e276df42b9572d16">asio::error::connection_aborted</a>. By default the option is false.<p>
<dl class="user" compact><dt><b>Examples</b></dt><dd>Setting the option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a> option(<span class="keyword">true</span>);
 acceptor.set_option(option);
</pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Getting the current option value: <div class="fragment"><pre class="fragment"> <a class="code" href="a00014.html">asio::ip::tcp::acceptor</a> acceptor(io_service); 
 ...
 <a class="code" href="a00045.html#9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a> option;
 acceptor.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.value();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28512bf41a5983383e0f5968c6e0580d"></a><!-- doxytag: member="asio::basic_socket_streambuf::non_blocking_io" ref="28512bf41a5983383e0f5968c6e0580d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IO control command to set the blocking mode of the socket. 
<p>
Implements the FIONBIO IO control command.<p>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a> command(<span class="keyword">true</span>);
 socket.io_control(command);
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>IO_Control_Command, Boolean_IO_Control_Command. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bbde8e590fbb98dfa1685b9d435cb5dc"></a><!-- doxytag: member="asio::basic_socket_streambuf::bytes_readable" ref="bbde8e590fbb98dfa1685b9d435cb5dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
IO control command to get the amount of data that can be read without blocking. 
<p>
Implements the FIONREAD IO control command.<p>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service); 
 ...
 <a class="code" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a> command(<span class="keyword">true</span>);
 socket.io_control(command);
 std::size_t bytes_readable = command.get();
</pre></div></dd></dl>
<dl class="user" compact><dt><b>Concepts:</b></dt><dd>IO_Control_Command, Size_IO_Control_Command. </dd></dl>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="915e52ff147efd296350bba81f795c37"></a><!-- doxytag: member="asio::basic_socket_streambuf::shutdown_type" ref="915e52ff147efd296350bba81f795c37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">asio::socket_base::shutdown_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Different ways a socket may be shutdown. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b"></a><!-- doxytag: member="shutdown_receive" ref="915e52ff147efd296350bba81f795c37cbfe078d69142138f3162984ba6a1b9b" args="" -->shutdown_receive</em>&nbsp;</td><td>
Shutdown the receive side of the socket. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62"></a><!-- doxytag: member="shutdown_send" ref="915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62" args="" -->shutdown_send</em>&nbsp;</td><td>
Shutdown the send side of the socket. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd"></a><!-- doxytag: member="shutdown_both" ref="915e52ff147efd296350bba81f795c3766b86f5f0b2524bc7652dc9c7c82c0fd" args="" -->shutdown_both</em>&nbsp;</td><td>
Shutdown both send and receive on the socket. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="df6bb7f645f8d86612034c958f1f310b"></a><!-- doxytag: member="asio::basic_socket_streambuf::basic_socket_streambuf" ref="df6bb7f645f8d86612034c958f1f310b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename StreamSocketService = stream_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html">asio::basic_socket_streambuf</a>&lt; Protocol, StreamSocketService &gt;::<a class="el" href="a00016.html">basic_socket_streambuf</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a <a class="el" href="a00016.html">basic_socket_streambuf</a> without establishing a connection. 
<p>

</div>
</div><p>
<a class="anchor" name="6d670112a43382f31af936898033de85"></a><!-- doxytag: member="asio::basic_socket_streambuf::~basic_socket_streambuf" ref="6d670112a43382f31af936898033de85" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename StreamSocketService = stream_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00016.html">asio::basic_socket_streambuf</a>&lt; Protocol, StreamSocketService &gt;::~<a class="el" href="a00016.html">basic_socket_streambuf</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor flushes buffered data. 
<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="c930d319e4a857ba503b4b135c287766"></a><!-- doxytag: member="asio::basic_socket_streambuf::connect" ref="c930d319e4a857ba503b4b135c287766" args="(const endpoint_type &amp;endpoint)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename StreamSocketService = stream_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html">basic_socket_streambuf</a>&lt;Protocol, StreamSocketService&gt;* <a class="el" href="a00016.html">asio::basic_socket_streambuf</a>&lt; Protocol, StreamSocketService &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Establish a connection. 
<p>
This function establishes a connection to the specified endpoint.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>this</code> if a connection was successfully established, a null pointer otherwise. </dd></dl>

<p>
Reimplemented from <a class="el" href="a00013.html#c3c66c10841897d56e75799e81d7f319">asio::basic_socket&lt; Protocol, StreamSocketService &gt;</a>.
</div>
</div><p>
<a class="anchor" name="9da58feca85f098610a324963764e2b7"></a><!-- doxytag: member="asio::basic_socket_streambuf::connect" ref="9da58feca85f098610a324963764e2b7" args="(T1 t1,..., TN tn)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename StreamSocketService = stream_socket_service&lt;Protocol&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename T1, ... , typename TN&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html">basic_socket_streambuf</a>&lt;Protocol, StreamSocketService&gt;* <a class="el" href="a00016.html">asio::basic_socket_streambuf</a>&lt; Protocol, StreamSocketService &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">T1&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TN&nbsp;</td>
          <td class="paramname"> <em>tn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Establish a connection. 
<p>
This function automatically establishes a connection based on the supplied resolver query parameters. The arguments are used to construct a resolver query object.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>this</code> if a connection was successfully established, a null pointer otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b20151b479df75a311c727e64bb4fc1a"></a><!-- doxytag: member="asio::basic_socket_streambuf::close" ref="b20151b479df75a311c727e64bb4fc1a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol, typename StreamSocketService = stream_socket_service&lt;Protocol&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html">basic_socket_streambuf</a>&lt;Protocol, StreamSocketService&gt;* <a class="el" href="a00016.html">asio::basic_socket_streambuf</a>&lt; Protocol, StreamSocketService &gt;::close           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the connection. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><code>this</code> if a connection was successfully established, a null pointer otherwise. </dd></dl>

<p>
Reimplemented from <a class="el" href="a00013.html#ecb8346a5bc290e394a055b7d9164c0f">asio::basic_socket&lt; Protocol, StreamSocketService &gt;</a>.
</div>
</div><p>
<a class="anchor" name="cd1a03601cf874d77169f9294e6ebad4"></a><!-- doxytag: member="asio::basic_socket_streambuf::lowest_layer" ref="cd1a03601cf874d77169f9294e6ebad4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">lowest_layer_type</a>&amp; <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::lowest_layer           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a reference to the lowest layer. 
<p>
This function returns a reference to the lowest layer in a stack of layers. Since a <a class="el" href="a00013.html">basic_socket</a> cannot contain any further layers, it simply returns a reference to itself.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ddde141b21499e7918c5a93c3cbab1d1"></a><!-- doxytag: member="asio::basic_socket_streambuf::open" ref="ddde141b21499e7918c5a93c3cbab1d1" args="(const protocol_type &amp;protocol=protocol_type())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::open           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em> = <code><a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a>()</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the socket using the specified protocol. 
<p>
This function opens the socket so that it will use the specified protocol.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 socket.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9cd7189fb57ad92321affbae2e7bcd01"></a><!-- doxytag: member="asio::basic_socket_streambuf::open" ref="9cd7189fb57ad92321affbae2e7bcd01" args="(const protocol_type &amp;protocol, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::open           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Open the socket using the specified protocol. 
<p>
This function opens the socket so that it will use the specified protocol.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="452fbce78dff7c03c9906daa27d4163b"></a><!-- doxytag: member="asio::basic_socket_streambuf::assign" ref="452fbce78dff7c03c9906daa27d4163b" args="(const protocol_type &amp;protocol, const native_type &amp;native_socket)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>native_socket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign an existing native socket to the socket. 
<p>

</div>
</div><p>
<a class="anchor" name="21d132e623b0f1b9eb6af15e60e9aef4"></a><!-- doxytag: member="asio::basic_socket_streambuf::assign" ref="21d132e623b0f1b9eb6af15e60e9aef4" args="(const protocol_type &amp;protocol, const native_type &amp;native_socket, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::assign           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#5890addc84762c67f2b3f1723428721d">protocol_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign an existing native socket to the socket. 
<p>

</div>
</div><p>
<a class="anchor" name="d18a1f2f159d0d99aa088df9e58d1cfc"></a><!-- doxytag: member="asio::basic_socket_streambuf::is_open" ref="d18a1f2f159d0d99aa088df9e58d1cfc" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::is_open           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the socket is open. 
<p>

</div>
</div><p>
<a class="anchor" name="3fa404892b34feff1f8e013ab7c3e7ee"></a><!-- doxytag: member="asio::basic_socket_streambuf::close" ref="3fa404892b34feff1f8e013ab7c3e7ee" args="(asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::close           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the socket. 
<p>
This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.close(ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9e65e3e73aa11b017d355d902e9b6ddc"></a><!-- doxytag: member="asio::basic_socket_streambuf::native" ref="9e65e3e73aa11b017d355d902e9b6ddc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html#c56ef6e34a007f65869a0eb1a0b96334">native_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::native           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the native socket representation. 
<p>
This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. 
</div>
</div><p>
<a class="anchor" name="8c93c7f90a9c2b44e1bedfa8f2fe63c8"></a><!-- doxytag: member="asio::basic_socket_streambuf::cancel" ref="8c93c7f90a9c2b44e1bedfa8f2fe63c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::cancel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel all asynchronous operations associated with the socket. 
<p>
This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1128f1e16ef26eb7fa9328548a2a08e9"></a><!-- doxytag: member="asio::basic_socket_streambuf::cancel" ref="1128f1e16ef26eb7fa9328548a2a08e9" args="(asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::cancel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel all asynchronous operations associated with the socket. 
<p>
This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="a00029.html#cdda0b4f0d154256091c0837bc142019">asio::error::operation_aborted</a> error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="11fefda4db8247c58ada119040daedbe"></a><!-- doxytag: member="asio::basic_socket_streambuf::at_mark" ref="11fefda4db8247c58ada119040daedbe" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::at_mark           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the socket is at the out-of-band data mark. 
<p>
This function is used to check whether the socket input is currently positioned at the out-of-band data mark.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A bool indicating whether the socket is at the out-of-band data mark.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2fb2030562128667c88fe5f8cf613aa3"></a><!-- doxytag: member="asio::basic_socket_streambuf::at_mark" ref="2fb2030562128667c88fe5f8cf613aa3" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::at_mark           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine whether the socket is at the out-of-band data mark. 
<p>
This function is used to check whether the socket input is currently positioned at the out-of-band data mark.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A bool indicating whether the socket is at the out-of-band data mark. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1464a056487487ba19ac2a7ce633ffac"></a><!-- doxytag: member="asio::basic_socket_streambuf::available" ref="1464a056487487ba19ac2a7ce633ffac" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::available           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the number of bytes available for reading. 
<p>
This function is used to determine the number of bytes that may be read without blocking.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f32340508e7c17e124418ebd1f48a0e4"></a><!-- doxytag: member="asio::basic_socket_streambuf::available" ref="f32340508e7c17e124418ebd1f48a0e4" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::available           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determine the number of bytes available for reading. 
<p>
This function is used to determine the number of bytes that may be read without blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29f2660dcb63871f6ac50e5be2545194"></a><!-- doxytag: member="asio::basic_socket_streambuf::bind" ref="29f2660dcb63871f6ac50e5be2545194" args="(const endpoint_type &amp;endpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::bind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind the socket to the given local endpoint. 
<p>
This function binds the socket to the specified endpoint on the local machine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 socket.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
 socket.bind(<a class="code" href="a00007.html">asio::ip::tcp::endpoint</a>(
       <a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), 12345));
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b65419efd4f773417c53221070d5a59"></a><!-- doxytag: member="asio::basic_socket_streambuf::bind" ref="7b65419efd4f773417c53221070d5a59" args="(const endpoint_type &amp;endpoint, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::bind           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bind the socket to the given local endpoint. 
<p>
This function binds the socket to the specified endpoint on the local machine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 socket.open(<a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.bind(<a class="code" href="a00007.html">asio::ip::tcp::endpoint</a>(
       <a class="code" href="a00051.html#5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), 12345), ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f590780830e8f00925fd07ebaa9e71b"></a><!-- doxytag: member="asio::basic_socket_streambuf::connect" ref="9f590780830e8f00925fd07ebaa9e71b" args="(const endpoint_type &amp;peer_endpoint, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::connect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect the socket to the specified endpoint. 
<p>
This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.<p>
The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is returned to the closed state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>The remote endpoint to which the socket will be connected.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint(
     <a class="code" href="a00001.html#d67f1bd21015fea425f0bd305425ad8e">asio::ip::address::from_string</a>(<span class="stringliteral">"1.2.3.4"</span>), 12345);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.connect(endpoint, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="13862c86b40404249dc2ad54dbb81271"></a><!-- doxytag: member="asio::basic_socket_streambuf::async_connect" ref="13862c86b40404249dc2ad54dbb81271" args="(const endpoint_type &amp;peer_endpoint, ConnectHandler handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::async_connect           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00013.html#6b2ba27d020bb24356c691f19f8d2829">endpoint_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectHandler&nbsp;</td>
          <td class="paramname"> <em>handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start an asynchronous connect. 
<p>
This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.<p>
The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is returned to the closed state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="a00032.html#aa2e00c84c9d3a13672cf39fbf981a30">asio::io_service::post()</a>.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> connect_handler(<span class="keyword">const</span> <a class="code" href="a00030.html">asio::error_code</a>&amp; error)
 {
   <span class="keywordflow">if</span> (!error)
   {
     <span class="comment">// Connect succeeded.</span>
   }
 }

 ...

 <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint(
     <a class="code" href="a00001.html#d67f1bd21015fea425f0bd305425ad8e">asio::ip::address::from_string</a>(<span class="stringliteral">"1.2.3.4"</span>), 12345);
 socket.async_connect(endpoint, connect_handler);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f040b3c66c466f4184b690bb6904a3f3"></a><!-- doxytag: member="asio::basic_socket_streambuf::set_option" ref="f040b3c66c466f4184b690bb6904a3f3" args="(const SettableSocketOption &amp;option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::set_option           </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an option on the socket. 
<p>
This function is used to set an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The new option value to be set on the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>SettableSocketOption <br>
 <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> <br>
 <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> <br>
 <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> <br>
 <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> <br>
 <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> <br>
 <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <br>
 <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> <br>
 <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> <br>
 <a class="el" href="a00128.html#b9ef02d2f76ab2a904ad0008aa9b9afc">asio::ip::multicast::join_group</a> <br>
 <a class="el" href="a00128.html#6dfad4ffefcbddd1be19c1518ab4f8eb">asio::ip::multicast::leave_group</a> <br>
 <a class="el" href="a00128.html#a0a6359db040928c26ec5f66ded5cb58">asio::ip::multicast::enable_loopback</a> <br>
 <a class="el" href="a00128.html#ecc5b43cb6820baa08f008400b0dbef6">asio::ip::multicast::outbound_interface</a> <br>
 <a class="el" href="a00128.html#9054deaca4a61e75e872292d9ba98e97">asio::ip::multicast::hops</a> <br>
 <a class="el" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a> option(<span class="keyword">true</span>);
 socket.set_option(option);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e42c5d5d6779b68fa068032814a969da"></a><!-- doxytag: member="asio::basic_socket_streambuf::set_option" ref="e42c5d5d6779b68fa068032814a969da" args="(const SettableSocketOption &amp;option, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::set_option           </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set an option on the socket. 
<p>
This function is used to set an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The new option value to be set on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>SettableSocketOption <br>
 <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> <br>
 <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> <br>
 <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> <br>
 <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> <br>
 <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> <br>
 <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <br>
 <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> <br>
 <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> <br>
 <a class="el" href="a00128.html#b9ef02d2f76ab2a904ad0008aa9b9afc">asio::ip::multicast::join_group</a> <br>
 <a class="el" href="a00128.html#6dfad4ffefcbddd1be19c1518ab4f8eb">asio::ip::multicast::leave_group</a> <br>
 <a class="el" href="a00128.html#a0a6359db040928c26ec5f66ded5cb58">asio::ip::multicast::enable_loopback</a> <br>
 <a class="el" href="a00128.html#ecc5b43cb6820baa08f008400b0dbef6">asio::ip::multicast::outbound_interface</a> <br>
 <a class="el" href="a00128.html#9054deaca4a61e75e872292d9ba98e97">asio::ip::multicast::hops</a> <br>
 <a class="el" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a> option(<span class="keyword">true</span>);
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.set_option(option, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="88d39aad400fa707d816639402d013b8"></a><!-- doxytag: member="asio::basic_socket_streambuf::get_option" ref="88d39aad400fa707d816639402d013b8" args="(GettableSocketOption &amp;option) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::get_option           </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an option from the socket. 
<p>
This function is used to get the current value of an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The option value to be obtained from the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>GettableSocketOption <br>
 <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> <br>
 <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> <br>
 <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> <br>
 <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> <br>
 <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> <br>
 <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <br>
 <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> <br>
 <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> <br>
 <a class="el" href="a00128.html#b9ef02d2f76ab2a904ad0008aa9b9afc">asio::ip::multicast::join_group</a> <br>
 <a class="el" href="a00128.html#6dfad4ffefcbddd1be19c1518ab4f8eb">asio::ip::multicast::leave_group</a> <br>
 <a class="el" href="a00128.html#a0a6359db040928c26ec5f66ded5cb58">asio::ip::multicast::enable_loopback</a> <br>
 <a class="el" href="a00128.html#ecc5b43cb6820baa08f008400b0dbef6">asio::ip::multicast::outbound_interface</a> <br>
 <a class="el" href="a00128.html#9054deaca4a61e75e872292d9ba98e97">asio::ip::multicast::hops</a> <br>
 <a class="el" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::ip::tcp::socket::keep_alive</a> option;
 socket.get_option(option);
 <span class="keywordtype">bool</span> is_set = option.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c40f85557f13e0e946a9b0395f9c313"></a><!-- doxytag: member="asio::basic_socket_streambuf::get_option" ref="8c40f85557f13e0e946a9b0395f9c313" args="(GettableSocketOption &amp;option, asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::get_option           </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an option from the socket. 
<p>
This function is used to get the current value of an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The option value to be obtained from the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>GettableSocketOption <br>
 <a class="el" href="a00045.html#ee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a> <br>
 <a class="el" href="a00045.html#4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a> <br>
 <a class="el" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a> <br>
 <a class="el" href="a00045.html#308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a> <br>
 <a class="el" href="a00045.html#d79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a> <br>
 <a class="el" href="a00045.html#f487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a> <br>
 <a class="el" href="a00045.html#66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a> <br>
 <a class="el" href="a00045.html#8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a> <br>
 <a class="el" href="a00045.html#bff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a> <br>
 <a class="el" href="a00128.html#b9ef02d2f76ab2a904ad0008aa9b9afc">asio::ip::multicast::join_group</a> <br>
 <a class="el" href="a00128.html#6dfad4ffefcbddd1be19c1518ab4f8eb">asio::ip::multicast::leave_group</a> <br>
 <a class="el" href="a00128.html#a0a6359db040928c26ec5f66ded5cb58">asio::ip::multicast::enable_loopback</a> <br>
 <a class="el" href="a00128.html#ecc5b43cb6820baa08f008400b0dbef6">asio::ip::multicast::outbound_interface</a> <br>
 <a class="el" href="a00128.html#9054deaca4a61e75e872292d9ba98e97">asio::ip::multicast::hops</a> <br>
 <a class="el" href="a00051.html#60c895aff305a8e2f6b1e9fbdb6f90a7">asio::ip::tcp::no_delay</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00045.html#493d09a6a851ec400a30e8f22adb9d74">asio::ip::tcp::socket::keep_alive</a> option;
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.get_option(option, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
 <span class="keywordtype">bool</span> is_set = option.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4fb5d33d2ebee7fc119c3060ab258cde"></a><!-- doxytag: member="asio::basic_socket_streambuf::io_control" ref="4fb5d33d2ebee7fc119c3060ab258cde" args="(IoControlCommand &amp;command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::io_control           </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform an IO control command on the socket. 
<p>
This function is used to execute an IO control command on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>The IO control command to be performed on the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>IoControlCommand <br>
 <a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a> <br>
 <a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the number of bytes ready to read: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::ip::tcp::socket::bytes_readable</a> command;
 socket.io_control(command);
 std::size_t bytes_readable = command.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6fa2182e4e122c5e1a1a5c960ef41180"></a><!-- doxytag: member="asio::basic_socket_streambuf::io_control" ref="6fa2182e4e122c5e1a1a5c960ef41180" args="(IoControlCommand &amp;command, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::io_control           </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform an IO control command on the socket. 
<p>
This function is used to execute an IO control command on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>The IO control command to be performed on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>IoControlCommand <br>
 <a class="el" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a> <br>
 <a class="el" href="a00045.html#28512bf41a5983383e0f5968c6e0580d">asio::socket_base::non_blocking_io</a></dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Getting the number of bytes ready to read: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00045.html#bbde8e590fbb98dfa1685b9d435cb5dc">asio::ip::tcp::socket::bytes_readable</a> command;
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.io_control(command, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
 std::size_t bytes_readable = command.get();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="efb7bdafc26eb3dd3b1a8c0559947754"></a><!-- doxytag: member="asio::basic_socket_streambuf::local_endpoint" ref="efb7bdafc26eb3dd3b1a8c0559947754" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::local_endpoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the local endpoint of the socket. 
<p>
This function is used to obtain the locally bound endpoint of the socket.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the local endpoint of the socket.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = socket.local_endpoint();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2bec75bc112611561d8f13db299d72af"></a><!-- doxytag: member="asio::basic_socket_streambuf::local_endpoint" ref="2bec75bc112611561d8f13db299d72af" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::local_endpoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the local endpoint of the socket. 
<p>
This function is used to obtain the locally bound endpoint of the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = socket.local_endpoint(ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a190ca5477b3dcee0d9c9d97a427897a"></a><!-- doxytag: member="asio::basic_socket_streambuf::remote_endpoint" ref="a190ca5477b3dcee0d9c9d97a427897a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::remote_endpoint           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the remote endpoint of the socket. 
<p>
This function is used to obtain the remote endpoint of the socket.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the remote endpoint of the socket.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = socket.remote_endpoint();
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="61cc239a1078a1a62589a2abedea8b76"></a><!-- doxytag: member="asio::basic_socket_streambuf::remote_endpoint" ref="61cc239a1078a1a62589a2abedea8b76" args="(asio::error_code &amp;ec) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00016.html#11c216e83e3cdb430922f3dd47315ab6">endpoint_type</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::remote_endpoint           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the remote endpoint of the socket. 
<p>
This function is used to obtain the remote endpoint of the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="user" compact><dt><b>Example</b></dt><dd><div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 <a class="code" href="a00007.html">asio::ip::tcp::endpoint</a> endpoint = socket.remote_endpoint(ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8b410b0be483ff3a9c03d67f754f02c"></a><!-- doxytag: member="asio::basic_socket_streambuf::shutdown" ref="f8b410b0be483ff3a9c03d67f754f02c" args="(shutdown_type what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::shutdown           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a>&nbsp;</td>
          <td class="paramname"> <em>what</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable sends or receives on the socket. 
<p>
This function is used to disable send operations, receive operations, or both.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>what</em>&nbsp;</td><td>Determines what types of operation will no longer be allowed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Shutting down the send side of the socket: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 socket.shutdown(<a class="code" href="a00045.html#915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62">asio::ip::tcp::socket::shutdown_send</a>);
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="7f07b5990a61e483ab24862912e695ae"></a><!-- doxytag: member="asio::basic_socket_streambuf::shutdown" ref="7f07b5990a61e483ab24862912e695ae" args="(shutdown_type what, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00030.html">asio::error_code</a> <a class="el" href="a00013.html">asio::basic_socket</a>&lt; Protocol , StreamSocketService  &gt;::shutdown           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00045.html#915e52ff147efd296350bba81f795c37">shutdown_type</a>&nbsp;</td>
          <td class="paramname"> <em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable sends or receives on the socket. 
<p>
This function is used to disable send operations, receive operations, or both.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>what</em>&nbsp;</td><td>Determines what types of operation will no longer be allowed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>Shutting down the send side of the socket: <div class="fragment"><pre class="fragment"> <a class="code" href="a00017.html">asio::ip::tcp::socket</a> socket(io_service);
 ...
 <a class="code" href="a00030.html">asio::error_code</a> ec;
 socket.shutdown(<a class="code" href="a00045.html#915e52ff147efd296350bba81f795c37042d0121d26acaa45a86e0db3cb8aa62">asio::ip::tcp::socket::shutdown_send</a>, ec);
 <span class="keywordflow">if</span> (ec)
 {
   <span class="comment">// An error occurred.</span>
 }
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5208e056c92fa6130114d023a5bd8b0"></a><!-- doxytag: member="asio::basic_socket_streambuf::io_service" ref="e5208e056c92fa6130114d023a5bd8b0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00032.html">asio::io_service</a>&amp; <a class="el" href="a00008.html">asio::basic_io_object</a>&lt; StreamSocketService  &gt;::<a class="el" href="a00032.html">io_service</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the <a class="el" href="a00032.html">io_service</a> associated with the object. 
<p>
This function may be used to obtain the <a class="el" href="a00032.html">io_service</a> object that the I/O object uses to dispatch handlers for asynchronous operations.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the <a class="el" href="a00032.html">io_service</a> object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="356e1bd7da0353e5472028cdec742ed0"></a><!-- doxytag: member="asio::basic_socket_streambuf::message_peek" ref="356e1bd7da0353e5472028cdec742ed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#356e1bd7da0353e5472028cdec742ed0">asio::socket_base::message_peek</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Peek at incoming data without removing it from the input queue. 
<p>

</div>
</div><p>
<a class="anchor" name="b9f08ba445b7ce09ece5ac7beaa6e7c9"></a><!-- doxytag: member="asio::basic_socket_streambuf::message_out_of_band" ref="b9f08ba445b7ce09ece5ac7beaa6e7c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#b9f08ba445b7ce09ece5ac7beaa6e7c9">asio::socket_base::message_out_of_band</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process out-of-band data. 
<p>

</div>
</div><p>
<a class="anchor" name="e27428a48d1a7113a95ea205b1e17978"></a><!-- doxytag: member="asio::basic_socket_streambuf::message_do_not_route" ref="e27428a48d1a7113a95ea205b1e17978" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#e27428a48d1a7113a95ea205b1e17978">asio::socket_base::message_do_not_route</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify that the data should not be subject to routing. 
<p>

</div>
</div><p>
<a class="anchor" name="85ee2a3ce0ec68ac8c026884c5bd3098"></a><!-- doxytag: member="asio::basic_socket_streambuf::max_connections" ref="85ee2a3ce0ec68ac8c026884c5bd3098" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="a00045.html#85ee2a3ce0ec68ac8c026884c5bd3098">asio::socket_base::max_connections</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The maximum length of the queue of pending incoming connections. 
<p>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc1</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
