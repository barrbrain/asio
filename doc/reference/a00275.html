<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::read_until</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1>asio::read_until</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00275.html#g6c91d7ddc5b690a4d7a878723bd79a97">asio::read_until</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a delimiter is encountered.  <a href="#g6c91d7ddc5b690a4d7a878723bd79a97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00275.html#ga5d38d62df12b2404712bb38be08fe14">asio::read_until</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a delimiter is encountered.  <a href="#ga5d38d62df12b2404712bb38be08fe14"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00275.html#g1ad1e2b12c321b30826b67a92572b430">asio::read_until</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a regular expression is located.  <a href="#g1ad1e2b12c321b30826b67a92572b430"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00275.html#g6d020f4615f95350c0d2fe46b440c51e">asio::read_until</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, <a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a regular expression is located.  <a href="#g6d020f4615f95350c0d2fe46b440c51e"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g6c91d7ddc5b690a4d7a878723bd79a97"></a><!-- doxytag: member="asio::read_until" ref="g6c91d7ddc5b690a4d7a878723bd79a97" args="(Sync_Read_Stream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, char delim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a delimiter is encountered. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:<p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter character.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Example:</b></dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><pre class="fragment"> <a class="code" href="a00119.html">asio::streambuf</a> b;
 <a class="code" href="a00275.html#g6c91d7ddc5b690a4d7a878723bd79a97">asio::read_until</a>(s, b, <span class="charliteral">'\n'</span>);
 std::istream is(&amp;b);
 std::string line;
 std::getline(is, line); 
</pre></div></dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This overload is equivalent to calling: <div class="fragment"><pre class="fragment"> <a class="code" href="a00275.html#g6c91d7ddc5b690a4d7a878723bd79a97">asio::read_until</a>(
     s, b, delim,
     <a class="code" href="a00272.html#g17eebda462da83c5c2143f2fd77a840a">asio::throw_error</a>()); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga5d38d62df12b2404712bb38be08fe14"></a><!-- doxytag: member="asio::read_until" ref="ga5d38d62df12b2404712bb38be08fe14" args="(Sync_Read_Stream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, char delim, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Allocator, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a delimiter is encountered. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:<p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>A handler to be called when the operation completes, to indicate whether or not an error has occurred. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div> The error handler is only called if the completion_condition indicates that the operation is complete.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred and the error handler did not throw an exception. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1ad1e2b12c321b30826b67a92572b430"></a><!-- doxytag: member="asio::read_until" ref="g1ad1e2b12c321b30826b67a92572b430" args="(Sync_Read_Stream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a regular expression is located. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:<p>
<ul>
<li>A substring of the streambuf's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The regular expression.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the substring that matches the regular expression.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Example:</b></dt><dd>To read data into a streambuf until a CR-LF sequence is encountered: <div class="fragment"><pre class="fragment"> <a class="code" href="a00119.html">asio::streambuf</a> b;
 <a class="code" href="a00275.html#g6c91d7ddc5b690a4d7a878723bd79a97">asio::read_until</a>(s, b, boost::regex(<span class="stringliteral">"\r\n"</span>));
 std::istream is(&amp;b);
 std::string line;
 std::getline(is, line); 
</pre></div></dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This overload is equivalent to calling: <div class="fragment"><pre class="fragment"> <a class="code" href="a00275.html#g6c91d7ddc5b690a4d7a878723bd79a97">asio::read_until</a>(
     s, b, expr,
     <a class="code" href="a00272.html#g17eebda462da83c5c2143f2fd77a840a">asio::throw_error</a>()); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6d020f4615f95350c0d2fe46b440c51e"></a><!-- doxytag: member="asio::read_until" ref="g6d020f4615f95350c0d2fe46b440c51e" args="(Sync_Read_Stream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Allocator, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00119.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a regular expression is located. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:<p>
<ul>
<li>A substring of the streambuf's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The regular expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>A handler to be called when the operation completes, to indicate whether or not an error has occurred. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div> The error handler is only called if the completion_condition indicates that the operation is complete.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the substring that matches the regular expression. </dd></dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
