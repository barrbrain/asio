<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::basic_stream_socket&lt; Service &gt; Class Template Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.5</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.5 -->
<div class="nav">
<a class="el" href="a00219.html">asio</a>::<a class="el" href="a00095.html">basic_stream_socket</a></div>
<h1>asio::basic_stream_socket&lt; Service &gt; Class Template Reference</h1><!-- doxytag: class="asio::basic_stream_socket" --><!-- doxytag: inherits="asio::socket_base" -->Inherits <a class="el" href="a00130.html">asio::socket_base</a>.
<p>
<a href="a00007.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename Service&gt;<br>
 class asio::basic_stream_socket&lt; Service &gt;</h3>

Provides stream-oriented socket functionality. 
<p>
The <a class="el" href="a00095.html">basic_stream_socket</a> class template provides asynchronous and blocking stream-oriented socket functionality.<p>
Most applications will use the <a class="el" href="a00219.html#35902bc440f0b9cf5f2fbb1c10b1cfeb">asio::stream_socket</a> typedef.<p>
<dl compact><dt><b>Thread Safety:</b></dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br>
 <em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl compact><dt><b>Concepts:</b></dt><dd><a class="el" href="a00084.html">Async_Object</a>, <a class="el" href="a00085.html">Async_Read_Stream</a>, <a class="el" href="a00086.html">Async_Write_Stream</a>, <a class="el" href="a00112.html">Error_Source</a>, <a class="el" href="a00133.html">Stream</a>, <a class="el" href="a00137.html">Sync_Read_Stream</a>, <a class="el" href="a00138.html">Sync_Write_Stream</a>. </dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef Service&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#f43697a993f56955e3f9e353b3b1f210">service_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the service that will be used to provide socket operations.  <a href="#f43697a993f56955e3f9e353b3b1f210"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef service_type::impl_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The native implementation type of the stream socket.  <a href="#0ac43ba128daec432ece8d7eaecacbcb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef service_type::demuxer_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The demuxer type for this asynchronous type.  <a href="#a88158c5007f6c3cba0dcaea6724b104"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00111.html">asio::error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#c5f3c3898da36dd0f20b2865b9a08d58">error_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type used for reporting errors.  <a href="#c5f3c3898da36dd0f20b2865b9a08d58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00095.html">basic_stream_socket</a>&lt;<br>
 <a class="el" href="a00095.html#f43697a993f56955e3f9e353b3b1f210">service_type</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#90d5ffdfbbdd5d67a61516c38215f0d5">lowest_layer_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="a00095.html">basic_stream_socket</a> is always the lowest layer.  <a href="#90d5ffdfbbdd5d67a61516c38215f0d5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bitmask type for flags that can be passed to send and receive operations.  <a href="#5005237c9bc0680caa074f86dc5bd4ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00096.html">asio::socket_option::boolean</a>&lt;<br>
 SOL_SOCKET, SO_BROADCAST &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#b605ea609b9dfcf295cfd5a7803dcd37">broadcast</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to permit sending of broadcast messages.  <a href="#b605ea609b9dfcf295cfd5a7803dcd37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00096.html">asio::socket_option::boolean</a>&lt;<br>
 SOL_SOCKET, SO_DONTROUTE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#b94d1ddef890d21dc22b18d5c057bbd6">do_not_route</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to prevent routing, use local interfaces only.  <a href="#b94d1ddef890d21dc22b18d5c057bbd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00096.html">asio::socket_option::boolean</a>&lt;<br>
 SOL_SOCKET, SO_KEEPALIVE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#c0a7c9828caaec18a9ab9f562e953150">keep_alive</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to send keep-alives.  <a href="#c0a7c9828caaec18a9ab9f562e953150"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt;<br>
 SOL_SOCKET, SO_SNDBUF &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#c3ebf387cc010bd9d4256e50d3292e30">send_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send buffer size of a socket.  <a href="#c3ebf387cc010bd9d4256e50d3292e30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt;<br>
 SOL_SOCKET, SO_SNDLOWAT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#cf957205b885530a48e4460b4bdfc536">send_low_watermark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send low watermark.  <a href="#cf957205b885530a48e4460b4bdfc536"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt;<br>
 SOL_SOCKET, SO_SNDTIMEO &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#acada9ea0284da2d535105b61d2fcb3b">send_timeout</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the send timeout.  <a href="#acada9ea0284da2d535105b61d2fcb3b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt;<br>
 SOL_SOCKET, SO_RCVBUF &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#b578ab43a774596234f01edbe419df3e">receive_buffer_size</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive buffer size of a socket.  <a href="#b578ab43a774596234f01edbe419df3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt;<br>
 SOL_SOCKET, SO_RCVLOWAT &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#2251906d54ac2e7d3df110c30858f9f5">receive_low_watermark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive low watermark.  <a href="#2251906d54ac2e7d3df110c30858f9f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt;<br>
 SOL_SOCKET, SO_RCVTIMEO &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#0dad5ad50804721d2a87cfd6cfcfc63c">receive_timeout</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option for the receive timeout.  <a href="#0dad5ad50804721d2a87cfd6cfcfc63c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00096.html">asio::socket_option::boolean</a>&lt;<br>
 SOL_SOCKET, SO_REUSEADDR &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#94da173a167c88145c8f22588b9ced1f">reuse_address</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to allow the socket to be bound to an address that is already in use.  <a href="#94da173a167c88145c8f22588b9ced1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00119.html">asio::socket_option::linger</a>&lt;<br>
 SOL_SOCKET, SO_LINGER &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#fa1711bb276806d1f1808dbb0e31018a">linger</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket option to specify whether the socket lingers on close if unsent data is present.  <a href="#fa1711bb276806d1f1808dbb0e31018a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00097.html">asio::io_control::boolean</a>&lt;<br>
 FIONBIO &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#78796344ad58e63b051a02fbe7c8da54">non_blocking_io</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO control command to set the blocking mode of the socket.  <a href="#78796344ad58e63b051a02fbe7c8da54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00128.html">asio::io_control::size</a>&lt;<br>
 FIONREAD &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#be88b9d5650b935f42ccf96e4f8de1fc">bytes_readable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IO control command to get the amount of data that can be read without blocking.  <a href="#be88b9d5650b935f42ccf96e4f8de1fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#ae57e95fb7aa1cae74f96d2b3b409eb2">shutdown_type</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00130.html#ae57e95fb7aa1cae74f96d2b3b409eb2957f460d7cfc302f4e66e4c471013bb0">shutdown_receive</a> =  implementation_defined, 
<br>
&nbsp;&nbsp;<a class="el" href="a00130.html#ae57e95fb7aa1cae74f96d2b3b409eb22aa8a1bd70b0fa2eb5032c845eb52339">shutdown_send</a> =  implementation_defined, 
<br>
&nbsp;&nbsp;<a class="el" href="a00130.html#ae57e95fb7aa1cae74f96d2b3b409eb241d0ecfe5cd3447b5a1cbe5d9dba31c2">shutdown_both</a> =  implementation_defined
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Different ways a socket may be shutdown.  <a href="a00130.html#ae57e95fb7aa1cae74f96d2b3b409eb2">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#eb3a5be9a9a69994628dc432cb1ddc03">basic_stream_socket</a> (<a class="el" href="a00095.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a> &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a <a class="el" href="a00095.html">basic_stream_socket</a> without opening it.  <a href="#eb3a5be9a9a69994628dc432cb1ddc03"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#28fe366d17a3c189caf8a8fe4aa7b70a">~basic_stream_socket</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#28fe366d17a3c189caf8a8fe4aa7b70a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00095.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#6afeb5e9a5b1a4fbbc83e784e9d07a99">demuxer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the demuxer associated with the asynchronous object.  <a href="#6afeb5e9a5b1a4fbbc83e784e9d07a99"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Protocol&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#505c58eba726382793eb94154992176b">open</a> (const <a class="el" href="a00124.html">Protocol</a> &amp;protocol)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="#505c58eba726382793eb94154992176b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Protocol, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#e14451e36964daf524e870720ddc980c">open</a> (const <a class="el" href="a00124.html">Protocol</a> &amp;protocol, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="#e14451e36964daf524e870720ddc980c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#188bb2749480028e2c32415766917412">close</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the socket.  <a href="#188bb2749480028e2c32415766917412"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#35dfe506779d151366482c6b3288f69e">close</a> (Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the socket.  <a href="#35dfe506779d151366482c6b3288f69e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00095.html">lowest_layer_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#8884a12ca6ca736b3d4cdf885d0b6d07">lowest_layer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#8884a12ca6ca736b3d4cdf885d0b6d07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00095.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#01610c26789d1c8c6c2ff679f386caf5">impl</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying implementation in the native type.  <a href="#01610c26789d1c8c6c2ff679f386caf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#622730afd0fa4c8a6f39b44b2060891c">set_impl</a> (<a class="el" href="a00095.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a> new_impl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the underlying implementation in the native type.  <a href="#622730afd0fa4c8a6f39b44b2060891c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#78f382490c894769552ae737bbed9cf2">bind</a> (const <a class="el" href="a00110.html">Endpoint</a> &amp;endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="#78f382490c894769552ae737bbed9cf2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#cba4d9ba65b105cbc122ae909cb44959">bind</a> (const <a class="el" href="a00110.html">Endpoint</a> &amp;endpoint, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="#cba4d9ba65b105cbc122ae909cb44959"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#8503f2990d44015edc1fd0e850b1bfff">connect</a> (const <a class="el" href="a00110.html">Endpoint</a> &amp;peer_endpoint)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect a stream socket to the specified endpoint.  <a href="#8503f2990d44015edc1fd0e850b1bfff"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#3fb8ec82326e325cee0f1d87dc7b41ec">connect</a> (const <a class="el" href="a00110.html">Endpoint</a> &amp;peer_endpoint, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect a stream socket to the specified endpoint.  <a href="#3fb8ec82326e325cee0f1d87dc7b41ec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#5210bdedd38ca6d0f3ca9759492c5a34">async_connect</a> (const <a class="el" href="a00110.html">Endpoint</a> &amp;peer_endpoint, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous connect.  <a href="#5210bdedd38ca6d0f3ca9759492c5a34"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Socket_Option&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#2e77c109c8d971ea916523adb760e2f9">set_option</a> (const <a class="el" href="a00131.html">Socket_Option</a> &amp;option)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option on the socket.  <a href="#2e77c109c8d971ea916523adb760e2f9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Socket_Option, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#953721d1a593724bc8690810d6ce38d5">set_option</a> (const <a class="el" href="a00131.html">Socket_Option</a> &amp;option, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an option on the socket.  <a href="#953721d1a593724bc8690810d6ce38d5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Socket_Option&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#05e9ec92faab743aced323f65a15977c">get_option</a> (<a class="el" href="a00131.html">Socket_Option</a> &amp;option) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an option from the socket.  <a href="#05e9ec92faab743aced323f65a15977c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Socket_Option, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#9a91665ff9490200bef473110583182d">get_option</a> (<a class="el" href="a00131.html">Socket_Option</a> &amp;option, Error_Handler error_handler) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an option from the socket.  <a href="#9a91665ff9490200bef473110583182d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IO_Control_Command&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#27c10cde363ba53c2b785153c27d0a9b">io_control</a> (<a class="el" href="a00116.html">IO_Control_Command</a> &amp;command)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="#27c10cde363ba53c2b785153c27d0a9b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename IO_Control_Command, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#45dd8239cb28a5e12305824356164580">io_control</a> (<a class="el" href="a00116.html">IO_Control_Command</a> &amp;command, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="#45dd8239cb28a5e12305824356164580"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#1b95d811d6556ff072fa47e5abcddfec">get_local_endpoint</a> (<a class="el" href="a00110.html">Endpoint</a> &amp;endpoint) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="#1b95d811d6556ff072fa47e5abcddfec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#40b55207bb02e31b3f7f50c0d8f5e6ba">get_local_endpoint</a> (<a class="el" href="a00110.html">Endpoint</a> &amp;endpoint, Error_Handler error_handler) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="#40b55207bb02e31b3f7f50c0d8f5e6ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#d2c517b9bea8f1d870d1c0a87aba30a0">get_remote_endpoint</a> (<a class="el" href="a00110.html">Endpoint</a> &amp;endpoint) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="#d2c517b9bea8f1d870d1c0a87aba30a0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Endpoint, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#a52e59226cff9b6aabe3f775eed18f39">get_remote_endpoint</a> (<a class="el" href="a00110.html">Endpoint</a> &amp;endpoint, Error_Handler error_handler) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="#a52e59226cff9b6aabe3f775eed18f39"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#efc008db049d9352749418bf1affb5a1">shutdown</a> (<a class="el" href="a00130.html#ae57e95fb7aa1cae74f96d2b3b409eb2">shutdown_type</a> what)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="#efc008db049d9352749418bf1affb5a1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#8dd44816b3aec4e0cf30abae2a59509c">send</a> (const <a class="el" href="a00103.html">Const_Buffers</a> &amp;buffers, <a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a> flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send some data on the socket.  <a href="#8dd44816b3aec4e0cf30abae2a59509c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#1a9a30ee4fc0e02ac57164fb09bf594e">send</a> (const <a class="el" href="a00103.html">Const_Buffers</a> &amp;buffers, <a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a> flags, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send some data on the socket.  <a href="#1a9a30ee4fc0e02ac57164fb09bf594e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#5e3111f0799b61680aabc1580573a0e0">async_send</a> (const <a class="el" href="a00103.html">Const_Buffers</a> &amp;buffers, <a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a> flags, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous send.  <a href="#5e3111f0799b61680aabc1580573a0e0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#85082496f237751f6ff842743a176e6e">receive</a> (const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;buffers, <a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a> flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive some data on the socket.  <a href="#85082496f237751f6ff842743a176e6e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#c914f507fa0b0833acd2a57d31ecec4e">receive</a> (const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;buffers, <a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a> flags, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive some data on a connected socket.  <a href="#c914f507fa0b0833acd2a57d31ecec4e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#352331bdd2186cfed18a4521e6cd9240">async_receive</a> (const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;buffers, <a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a> flags, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous receive.  <a href="#352331bdd2186cfed18a4521e6cd9240"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#9b9d0ef2c9545cb8ce28f669b9718111">write_some</a> (const <a class="el" href="a00103.html">Const_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some data to the socket.  <a href="#9b9d0ef2c9545cb8ce28f669b9718111"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#86cfd317cc108760d3e44d86ce5c7855">write_some</a> (const <a class="el" href="a00103.html">Const_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some data to the socket.  <a href="#86cfd317cc108760d3e44d86ce5c7855"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#43c6343f4d33e17a9ac1608fc39cead9">async_write_some</a> (const <a class="el" href="a00103.html">Const_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write.  <a href="#43c6343f4d33e17a9ac1608fc39cead9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#c5426439e74aa97a33b3d33d0d41e974">read_some</a> (const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the socket.  <a href="#c5426439e74aa97a33b3d33d0d41e974"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#ffabb5156efc14f90272113c1f6de373">read_some</a> (const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from the socket.  <a href="#ffabb5156efc14f90272113c1f6de373"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#3ffc513f3d8eb5e9d3be6a94ad518c57">async_read_some</a> (const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous read.  <a href="#3ffc513f3d8eb5e9d3be6a94ad518c57"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#32081c0c9f6f616ccd8ff6ce09c7c7b8">peek</a> (const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream socket.  <a href="#32081c0c9f6f616ccd8ff6ce09c7c7b8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#fb658c4ce8b9d216dd4bfb64a292cd90">peek</a> (const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at the incoming data on the stream socket.  <a href="#fb658c4ce8b9d216dd4bfb64a292cd90"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#a0176623c6cd6d0f41c90bf3f2dfb225">in_avail</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#a0176623c6cd6d0f41c90bf3f2dfb225"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00095.html#50ebac28ba9e853abb18fa6149908c82">in_avail</a> (Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine the amount of data that may be read without blocking.  <a href="#50ebac28ba9e853abb18fa6149908c82"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#777de2a765515bb0731c566aeb3f1a43">message_peek</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Peek at incoming data without removing it from the input queue.  <a href="#777de2a765515bb0731c566aeb3f1a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#9acffef91e2ea49b433089355a3e1cb5">message_out_of_band</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process out-of-band data.  <a href="#9acffef91e2ea49b433089355a3e1cb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html#264c9a83c18b653d91e16d321e90be32">message_do_not_route</a> = implementation_defined</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specify that the data should not be subject to routing.  <a href="#264c9a83c18b653d91e16d321e90be32"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00095.html#f43697a993f56955e3f9e353b3b1f210">service_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#4cfc8ad513bc76523d5348a71d320972">service_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The backend service implementation.  <a href="#4cfc8ad513bc76523d5348a71d320972"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00095.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html#da5cd4bcb34662066a3395c216c8c2b8">impl_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The underlying native implementation.  <a href="#da5cd4bcb34662066a3395c216c8c2b8"></a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="f43697a993f56955e3f9e353b3b1f210"></a><!-- doxytag: member="asio::basic_stream_socket::service_type" ref="f43697a993f56955e3f9e353b3b1f210" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef Service <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00095.html#f43697a993f56955e3f9e353b3b1f210">service_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type of the service that will be used to provide socket operations. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="0ac43ba128daec432ece8d7eaecacbcb"></a><!-- doxytag: member="asio::basic_stream_socket::impl_type" ref="0ac43ba128daec432ece8d7eaecacbcb" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef service_type::impl_type <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00095.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The native implementation type of the stream socket. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a88158c5007f6c3cba0dcaea6724b104"></a><!-- doxytag: member="asio::basic_stream_socket::demuxer_type" ref="a88158c5007f6c3cba0dcaea6724b104" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef service_type::demuxer_type <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00095.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The demuxer type for this asynchronous type. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="c5f3c3898da36dd0f20b2865b9a08d58"></a><!-- doxytag: member="asio::basic_stream_socket::error_type" ref="c5f3c3898da36dd0f20b2865b9a08d58" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00111.html">asio::error</a> <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00111.html">error_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The type used for reporting errors. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="90d5ffdfbbdd5d67a61516c38215f0d5"></a><!-- doxytag: member="asio::basic_stream_socket::lowest_layer_type" ref="90d5ffdfbbdd5d67a61516c38215f0d5" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00095.html">basic_stream_socket</a>&lt;<a class="el" href="a00095.html#f43697a993f56955e3f9e353b3b1f210">service_type</a>&gt; <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00095.html">lowest_layer_type</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A <a class="el" href="a00095.html">basic_stream_socket</a> is always the lowest layer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="5005237c9bc0680caa074f86dc5bd4ae"></a><!-- doxytag: member="asio::basic_stream_socket::message_flags" ref="5005237c9bc0680caa074f86dc5bd4ae" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef int <a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">asio::socket_base::message_flags</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bitmask type for flags that can be passed to send and receive operations. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b605ea609b9dfcf295cfd5a7803dcd37"></a><!-- doxytag: member="asio::basic_stream_socket::broadcast" ref="b605ea609b9dfcf295cfd5a7803dcd37" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00096.html">asio::socket_option::boolean</a>&lt; SOL_SOCKET, SO_BROADCAST&gt; <a class="el" href="a00096.html">asio::socket_base::broadcast</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option to permit sending of broadcast messages. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b94d1ddef890d21dc22b18d5c057bbd6"></a><!-- doxytag: member="asio::basic_stream_socket::do_not_route" ref="b94d1ddef890d21dc22b18d5c057bbd6" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00096.html">asio::socket_option::boolean</a>&lt; SOL_SOCKET, SO_DONTROUTE&gt; <a class="el" href="a00096.html">asio::socket_base::do_not_route</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option to prevent routing, use local interfaces only. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="c0a7c9828caaec18a9ab9f562e953150"></a><!-- doxytag: member="asio::basic_stream_socket::keep_alive" ref="c0a7c9828caaec18a9ab9f562e953150" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00096.html">asio::socket_option::boolean</a>&lt; SOL_SOCKET, SO_KEEPALIVE&gt; <a class="el" href="a00096.html">asio::socket_base::keep_alive</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option to send keep-alives. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="c3ebf387cc010bd9d4256e50d3292e30"></a><!-- doxytag: member="asio::basic_stream_socket::send_buffer_size" ref="c3ebf387cc010bd9d4256e50d3292e30" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt; SOL_SOCKET, SO_SNDBUF&gt; <a class="el" href="a00115.html">asio::socket_base::send_buffer_size</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option for the send buffer size of a socket. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="cf957205b885530a48e4460b4bdfc536"></a><!-- doxytag: member="asio::basic_stream_socket::send_low_watermark" ref="cf957205b885530a48e4460b4bdfc536" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt; SOL_SOCKET, SO_SNDLOWAT&gt; <a class="el" href="a00115.html">asio::socket_base::send_low_watermark</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option for the send low watermark. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="acada9ea0284da2d535105b61d2fcb3b"></a><!-- doxytag: member="asio::basic_stream_socket::send_timeout" ref="acada9ea0284da2d535105b61d2fcb3b" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt; SOL_SOCKET, SO_SNDTIMEO&gt; <a class="el" href="a00115.html">asio::socket_base::send_timeout</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option for the send timeout. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="b578ab43a774596234f01edbe419df3e"></a><!-- doxytag: member="asio::basic_stream_socket::receive_buffer_size" ref="b578ab43a774596234f01edbe419df3e" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt; SOL_SOCKET, SO_RCVBUF&gt; <a class="el" href="a00115.html">asio::socket_base::receive_buffer_size</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option for the receive buffer size of a socket. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="2251906d54ac2e7d3df110c30858f9f5"></a><!-- doxytag: member="asio::basic_stream_socket::receive_low_watermark" ref="2251906d54ac2e7d3df110c30858f9f5" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt; SOL_SOCKET, SO_RCVLOWAT&gt; <a class="el" href="a00115.html">asio::socket_base::receive_low_watermark</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option for the receive low watermark. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="0dad5ad50804721d2a87cfd6cfcfc63c"></a><!-- doxytag: member="asio::basic_stream_socket::receive_timeout" ref="0dad5ad50804721d2a87cfd6cfcfc63c" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00115.html">asio::socket_option::integer</a>&lt; SOL_SOCKET, SO_RCVTIMEO&gt; <a class="el" href="a00115.html">asio::socket_base::receive_timeout</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option for the receive timeout. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="94da173a167c88145c8f22588b9ced1f"></a><!-- doxytag: member="asio::basic_stream_socket::reuse_address" ref="94da173a167c88145c8f22588b9ced1f" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00096.html">asio::socket_option::boolean</a>&lt; SOL_SOCKET, SO_REUSEADDR&gt; <a class="el" href="a00096.html">asio::socket_base::reuse_address</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option to allow the socket to be bound to an address that is already in use. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="fa1711bb276806d1f1808dbb0e31018a"></a><!-- doxytag: member="asio::basic_stream_socket::linger" ref="fa1711bb276806d1f1808dbb0e31018a" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00119.html">asio::socket_option::linger</a>&lt; SOL_SOCKET, SO_LINGER&gt; <a class="el" href="a00119.html">asio::socket_base::linger</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Socket option to specify whether the socket lingers on close if unsent data is present. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="78796344ad58e63b051a02fbe7c8da54"></a><!-- doxytag: member="asio::basic_stream_socket::non_blocking_io" ref="78796344ad58e63b051a02fbe7c8da54" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00097.html">asio::io_control::boolean</a>&lt;FIONBIO&gt; <a class="el" href="a00097.html">asio::socket_base::non_blocking_io</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
IO control command to set the blocking mode of the socket. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="be88b9d5650b935f42ccf96e4f8de1fc"></a><!-- doxytag: member="asio::basic_stream_socket::bytes_readable" ref="be88b9d5650b935f42ccf96e4f8de1fc" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00128.html">asio::io_control::size</a>&lt;FIONREAD&gt; <a class="el" href="a00128.html">asio::socket_base::bytes_readable</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
IO control command to get the amount of data that can be read without blocking. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="ae57e95fb7aa1cae74f96d2b3b409eb2"></a><!-- doxytag: member="asio::basic_stream_socket::shutdown_type" ref="ae57e95fb7aa1cae74f96d2b3b409eb2" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="a00130.html#ae57e95fb7aa1cae74f96d2b3b409eb2">asio::socket_base::shutdown_type</a><code> [inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Different ways a socket may be shutdown. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ae57e95fb7aa1cae74f96d2b3b409eb2957f460d7cfc302f4e66e4c471013bb0"></a><!-- doxytag: member="shutdown_receive" ref="ae57e95fb7aa1cae74f96d2b3b409eb2957f460d7cfc302f4e66e4c471013bb0" args="" -->shutdown_receive</em>&nbsp;</td><td>
Shutdown the receive side of the socket. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ae57e95fb7aa1cae74f96d2b3b409eb22aa8a1bd70b0fa2eb5032c845eb52339"></a><!-- doxytag: member="shutdown_send" ref="ae57e95fb7aa1cae74f96d2b3b409eb22aa8a1bd70b0fa2eb5032c845eb52339" args="" -->shutdown_send</em>&nbsp;</td><td>
Shutdown the send side of the socket. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ae57e95fb7aa1cae74f96d2b3b409eb241d0ecfe5cd3447b5a1cbe5d9dba31c2"></a><!-- doxytag: member="shutdown_both" ref="ae57e95fb7aa1cae74f96d2b3b409eb241d0ecfe5cd3447b5a1cbe5d9dba31c2" args="" -->shutdown_both</em>&nbsp;</td><td>
Shutdown both send and receive on the socket. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="eb3a5be9a9a69994628dc432cb1ddc03"></a><!-- doxytag: member="asio::basic_stream_socket::basic_stream_socket" ref="eb3a5be9a9a69994628dc432cb1ddc03" args="(demuxer_type &amp;d)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00095.html">basic_stream_socket</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>d</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [explicit]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a <a class="el" href="a00095.html">basic_stream_socket</a> without opening it. 
<p>
This constructor creates a stream socket without connecting it to a remote peer. The socket needs to be connected or accepted before data can be sent or received on it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>The demuxer object that the stream socket will use to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="28fe366d17a3c189caf8a8fe4aa7b70a"></a><!-- doxytag: member="asio::basic_stream_socket::~basic_stream_socket" ref="28fe366d17a3c189caf8a8fe4aa7b70a" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::~<a class="el" href="a00095.html">basic_stream_socket</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="6afeb5e9a5b1a4fbbc83e784e9d07a99"></a><!-- doxytag: member="asio::basic_stream_socket::demuxer" ref="6afeb5e9a5b1a4fbbc83e784e9d07a99" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html#a88158c5007f6c3cba0dcaea6724b104">demuxer_type</a>&amp; <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00090.html">demuxer</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the demuxer associated with the asynchronous object. 
<p>
This function may be used to obtain the demuxer object that the stream socket uses to dispatch handlers for asynchronous operations.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the demuxer object that stream socket will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="505c58eba726382793eb94154992176b"></a><!-- doxytag: member="asio::basic_stream_socket::open" ref="505c58eba726382793eb94154992176b" args="(const Protocol &amp;protocol)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Protocol&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::open           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00124.html">Protocol</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>protocol</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open the socket using the specified protocol. 
<p>
This function opens the stream socket so that it will use the specified protocol.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying which protocol is to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e14451e36964daf524e870720ddc980c"></a><!-- doxytag: member="asio::basic_stream_socket::open" ref="e14451e36964daf524e870720ddc980c" args="(const Protocol &amp;protocol, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Protocol, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::open           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00124.html">Protocol</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Open the socket using the specified protocol. 
<p>
This function opens the stream socket so that it will use the specified protocol.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>protocol</em>&nbsp;</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="188bb2749480028e2c32415766917412"></a><!-- doxytag: member="asio::basic_stream_socket::close" ref="188bb2749480028e2c32415766917412" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::close           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close the socket. 
<p>
This function is used to close the stream socket. Any asynchronous send or receive operations will be cancelled immediately.<p>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="35dfe506779d151366482c6b3288f69e"></a><!-- doxytag: member="asio::basic_stream_socket::close" ref="35dfe506779d151366482c6b3288f69e" args="(Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::close           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Error_Handler&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>error_handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close the socket. 
<p>
This function is used to close the stream socket. Any asynchronous send or receive operations will be cancelled immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8884a12ca6ca736b3d4cdf885d0b6d07"></a><!-- doxytag: member="asio::basic_stream_socket::lowest_layer" ref="8884a12ca6ca736b3d4cdf885d0b6d07" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html">lowest_layer_type</a>&amp; <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::lowest_layer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a reference to the lowest layer. 
<p>
This function returns a reference to the lowest layer in a stack of stream layers. Since a <a class="el" href="a00095.html">basic_stream_socket</a> cannot contain any further stream layers, it simply returns a reference to itself.<p>
<dl compact><dt><b>Returns:</b></dt><dd>A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="01610c26789d1c8c6c2ff679f386caf5"></a><!-- doxytag: member="asio::basic_stream_socket::impl" ref="01610c26789d1c8c6c2ff679f386caf5" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a> <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::impl           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the underlying implementation in the native type. 
<p>
This function may be used to obtain the underlying implementation of the stream socket. This is intended to allow access to native socket functionality that is not otherwise provided.     </td>
  </tr>
</table>
<a class="anchor" name="622730afd0fa4c8a6f39b44b2060891c"></a><!-- doxytag: member="asio::basic_stream_socket::set_impl" ref="622730afd0fa4c8a6f39b44b2060891c" args="(impl_type new_impl)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::set_impl           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>new_impl</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the underlying implementation in the native type. 
<p>
This function is used by the acceptor implementation to set the underlying implementation associated with the stream socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_impl</em>&nbsp;</td><td>The new underlying socket implementation. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="78f382490c894769552ae737bbed9cf2"></a><!-- doxytag: member="asio::basic_stream_socket::bind" ref="78f382490c894769552ae737bbed9cf2" args="(const Endpoint &amp;endpoint)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::bind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>endpoint</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind the socket to the given local endpoint. 
<p>
This function binds the stream socket to the specified endpoint on the local machine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the stream socket will be bound.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="cba4d9ba65b105cbc122ae909cb44959"></a><!-- doxytag: member="asio::basic_stream_socket::bind" ref="cba4d9ba65b105cbc122ae909cb44959" args="(const Endpoint &amp;endpoint, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::bind           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind the socket to the given local endpoint. 
<p>
This function binds the stream socket to the specified endpoint on the local machine.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint on the local machine to which the stream socket will be bound.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8503f2990d44015edc1fd0e850b1bfff"></a><!-- doxytag: member="asio::basic_stream_socket::connect" ref="8503f2990d44015edc1fd0e850b1bfff" args="(const Endpoint &amp;peer_endpoint)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::connect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>peer_endpoint</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connect a stream socket to the specified endpoint. 
<p>
This function is used to connect a stream socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>The remote endpoint to which the socket will be connected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3fb8ec82326e325cee0f1d87dc7b41ec"></a><!-- doxytag: member="asio::basic_stream_socket::connect" ref="3fb8ec82326e325cee0f1d87dc7b41ec" args="(const Endpoint &amp;peer_endpoint, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::connect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connect a stream socket to the specified endpoint. 
<p>
This function is used to connect a stream socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>The remote endpoint to which the socket will be connected.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5210bdedd38ca6d0f3ca9759492c5a34"></a><!-- doxytag: member="asio::basic_stream_socket::async_connect" ref="5210bdedd38ca6d0f3ca9759492c5a34" args="(const Endpoint &amp;peer_endpoint, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::async_connect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous connect. 
<p>
This function is used to asynchronously connect a stream socket to the specified remote endpoint. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>peer_endpoint</em>&nbsp;</td><td>The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the connection operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2e77c109c8d971ea916523adb760e2f9"></a><!-- doxytag: member="asio::basic_stream_socket::set_option" ref="2e77c109c8d971ea916523adb760e2f9" args="(const Socket_Option &amp;option)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Socket_Option&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::set_option           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00131.html">Socket_Option</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>option</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set an option on the socket. 
<p>
This function is used to set an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The new option value to be set on the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="953721d1a593724bc8690810d6ce38d5"></a><!-- doxytag: member="asio::basic_stream_socket::set_option" ref="953721d1a593724bc8690810d6ce38d5" args="(const Socket_Option &amp;option, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Socket_Option, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::set_option           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00131.html">Socket_Option</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set an option on the socket. 
<p>
This function is used to set an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The new option value to be set on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="05e9ec92faab743aced323f65a15977c"></a><!-- doxytag: member="asio::basic_stream_socket::get_option" ref="05e9ec92faab743aced323f65a15977c" args="(Socket_Option &amp;option) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Socket_Option&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::get_option           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00131.html">Socket_Option</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>option</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an option from the socket. 
<p>
This function is used to get the current value of an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The option value to be obtained from the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9a91665ff9490200bef473110583182d"></a><!-- doxytag: member="asio::basic_stream_socket::get_option" ref="9a91665ff9490200bef473110583182d" args="(Socket_Option &amp;option, Error_Handler error_handler) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Socket_Option, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::get_option           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00131.html">Socket_Option</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get an option from the socket. 
<p>
This function is used to get the current value of an option on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>option</em>&nbsp;</td><td>The option value to be obtained from the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="27c10cde363ba53c2b785153c27d0a9b"></a><!-- doxytag: member="asio::basic_stream_socket::io_control" ref="27c10cde363ba53c2b785153c27d0a9b" args="(IO_Control_Command &amp;command)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename IO_Control_Command&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::io_control           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00116.html">IO_Control_Command</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>command</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform an IO control command on the socket. 
<p>
This function is used to execute an IO control command on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>The IO control command to be performed on the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="45dd8239cb28a5e12305824356164580"></a><!-- doxytag: member="asio::basic_stream_socket::io_control" ref="45dd8239cb28a5e12305824356164580" args="(IO_Control_Command &amp;command, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename IO_Control_Command, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::io_control           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00116.html">IO_Control_Command</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>command</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Perform an IO control command on the socket. 
<p>
This function is used to execute an IO control command on the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>The IO control command to be performed on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1b95d811d6556ff072fa47e5abcddfec"></a><!-- doxytag: member="asio::basic_stream_socket::get_local_endpoint" ref="1b95d811d6556ff072fa47e5abcddfec" args="(Endpoint &amp;endpoint) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::get_local_endpoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>endpoint</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the local endpoint of the socket. 
<p>
This function is used to obtain the locally bound endpoint of the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint object that receives the local endpoint of the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="40b55207bb02e31b3f7f50c0d8f5e6ba"></a><!-- doxytag: member="asio::basic_stream_socket::get_local_endpoint" ref="40b55207bb02e31b3f7f50c0d8f5e6ba" args="(Endpoint &amp;endpoint, Error_Handler error_handler) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::get_local_endpoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the local endpoint of the socket. 
<p>
This function is used to obtain the locally bound endpoint of the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint object that receives the local endpoint of the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d2c517b9bea8f1d870d1c0a87aba30a0"></a><!-- doxytag: member="asio::basic_stream_socket::get_remote_endpoint" ref="d2c517b9bea8f1d870d1c0a87aba30a0" args="(Endpoint &amp;endpoint) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::get_remote_endpoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>endpoint</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the remote endpoint of the socket. 
<p>
This function is used to obtain the remote endpoint of the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint object that receives the remote endpoint of the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a52e59226cff9b6aabe3f775eed18f39"></a><!-- doxytag: member="asio::basic_stream_socket::get_remote_endpoint" ref="a52e59226cff9b6aabe3f775eed18f39" args="(Endpoint &amp;endpoint, Error_Handler error_handler) const " --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Endpoint, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::get_remote_endpoint           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00110.html">Endpoint</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the remote endpoint of the socket. 
<p>
This function is used to obtain the remote endpoint of the socket.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>endpoint</em>&nbsp;</td><td>An endpoint object that receives the remote endpoint of the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div> </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="efc008db049d9352749418bf1affb5a1"></a><!-- doxytag: member="asio::basic_stream_socket::shutdown" ref="efc008db049d9352749418bf1affb5a1" args="(shutdown_type what)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::shutdown           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="a00130.html#ae57e95fb7aa1cae74f96d2b3b409eb2">shutdown_type</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>what</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable sends or receives on the socket. 
<p>
This function is used to disable send operations, receive operations, or both.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>what</em>&nbsp;</td><td>Determines what types of operation will no longer be allowed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8dd44816b3aec4e0cf30abae2a59509c"></a><!-- doxytag: member="asio::basic_stream_socket::send" ref="8dd44816b3aec4e0cf30abae2a59509c" args="(const Const_Buffers &amp;buffers, message_flags flags)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00103.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send some data on the socket. 
<p>
This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes sent.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The send operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00235.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To send a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.send(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size), 0);
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1a9a30ee4fc0e02ac57164fb09bf594e"></a><!-- doxytag: member="asio::basic_stream_socket::send" ref="1a9a30ee4fc0e02ac57164fb09bf594e" args="(const Const_Buffers &amp;buffers, message_flags flags, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00103.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send some data on the socket. 
<p>
This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent on the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes sent. Returns 0 if an error occurred and the error handler did not throw an exception.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The send operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00235.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5e3111f0799b61680aabc1580573a0e0"></a><!-- doxytag: member="asio::basic_stream_socket::async_send" ref="5e3111f0799b61680aabc1580573a0e0" args="(const Const_Buffers &amp;buffers, message_flags flags, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::async_send           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00103.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous send. 
<p>
This function is used to asynchronously send data on the stream socket. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be sent on the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the send call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the send operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error,     <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred <span class="comment">// Number of bytes sent.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The send operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00236.html">asio::async_write</a> function if you need to ensure that all data is written before the asynchronous operation completes.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To send a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.async_send(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size), 0, handler);
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on sending multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="85082496f237751f6ff842743a176e6e"></a><!-- doxytag: member="asio::basic_stream_socket::receive" ref="85082496f237751f6ff842743a176e6e" args="(const Mutable_Buffers &amp;buffers, message_flags flags)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::receive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive some data on the socket. 
<p>
This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. An error code of <a class="el" href="a00111.html#230880f3106c258c7c6167e4917484a02e51b1ab42e8a4a67f3445174be5191b">asio::error::eof</a> indicates that the connection was closed by the peer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The receive operation may not receive all of the requested number of bytes. Consider using the <a class="el" href="a00233.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To receive into a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.receive(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size), 0);
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c914f507fa0b0833acd2a57d31ecec4e"></a><!-- doxytag: member="asio::basic_stream_socket::receive" ref="c914f507fa0b0833acd2a57d31ecec4e" args="(const Mutable_Buffers &amp;buffers, message_flags flags, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::receive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive some data on a connected socket. 
<p>
This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes received. Returns 0 if an error occurred and the error handler did not throw an exception.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The receive operation may not receive all of the requested number of bytes. Consider using the <a class="el" href="a00233.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="352331bdd2186cfed18a4521e6cd9240"></a><!-- doxytag: member="asio::basic_stream_socket::async_receive" ref="352331bdd2186cfed18a4521e6cd9240" args="(const Mutable_Buffers &amp;buffers, message_flags flags, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::async_receive           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="a00130.html#5005237c9bc0680caa074f86dc5bd4ae">message_flags</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous receive. 
<p>
This function is used to asynchronously receive data from the stream socket. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be received. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Flags specifying how the receive call is to be made.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the receive operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error,     <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred <span class="comment">// Number of bytes received.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The receive operation may not receive all of the requested number of bytes. Consider using the <a class="el" href="a00234.html">asio::async_read</a> function if you need to ensure that the requested amount of data is received before the asynchronous operation completes.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To receive into a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.async_receive(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size), 0, handler);
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on receiving into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9b9d0ef2c9545cb8ce28f669b9718111"></a><!-- doxytag: member="asio::basic_stream_socket::write_some" ref="9b9d0ef2c9545cb8ce28f669b9718111" args="(const Const_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::write_some           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00103.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write some data to the socket. 
<p>
This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be written to the socket.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. An error code of <a class="el" href="a00111.html#230880f3106c258c7c6167e4917484a02e51b1ab42e8a4a67f3445174be5191b">asio::error::eof</a> indicates that the connection was closed by the peer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00235.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To write a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.write_some(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size));
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="86cfd317cc108760d3e44d86ce5c7855"></a><!-- doxytag: member="asio::basic_stream_socket::write_some" ref="86cfd317cc108760d3e44d86ce5c7855" args="(const Const_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::write_some           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00103.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write some data to the socket. 
<p>
This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be written to the socket.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes written. Returns 0 if an error occurred and the error handler did not throw an exception.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00235.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="43c6343f4d33e17a9ac1608fc39cead9"></a><!-- doxytag: member="asio::basic_stream_socket::async_write_some" ref="43c6343f4d33e17a9ac1608fc39cead9" args="(const Const_Buffers &amp;buffers, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Const_Buffers, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::async_write_some           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00103.html">Const_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous write. 
<p>
This function is used to asynchronously write data to the stream socket. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more data buffers to be written to the socket. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error,     <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred <span class="comment">// Number of bytes written.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The write operation may not transmit all of the data to the peer. Consider using the <a class="el" href="a00236.html">asio::async_write</a> function if you need to ensure that all data is written before the asynchronous operation completes.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To write a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.async_write_some(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size), handler);
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="c5426439e74aa97a33b3d33d0d41e974"></a><!-- doxytag: member="asio::basic_stream_socket::read_some" ref="c5426439e74aa97a33b3d33d0d41e974" args="(const Mutable_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::read_some           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from the socket. 
<p>
This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. An error code of <a class="el" href="a00111.html#230880f3106c258c7c6167e4917484a02e51b1ab42e8a4a67f3445174be5191b">asio::error::eof</a> indicates that the connection was closed by the peer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00233.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To read into a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.read_some(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size));
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ffabb5156efc14f90272113c1f6de373"></a><!-- doxytag: member="asio::basic_stream_socket::read_some" ref="ffabb5156efc14f90272113c1f6de373" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::read_some           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read some data from the socket. 
<p>
This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read. Returns 0 if an error occurred and the error handler did not throw an exception.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00233.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="3ffc513f3d8eb5e9d3be6a94ad518c57"></a><!-- doxytag: member="asio::basic_stream_socket::async_read_some" ref="3ffc513f3d8eb5e9d3be6a94ad518c57" args="(const Mutable_Buffers &amp;buffers, Handler handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::async_read_some           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start an asynchronous read. 
<p>
This function is used to asynchronously read data from the stream socket. The function call always returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error,     <span class="comment">// Result of operation.</span>
   std::size_t bytes_transferred <span class="comment">// Number of bytes read.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The read operation may not read all of the requested number of bytes. Consider using the <a class="el" href="a00234.html">asio::async_read</a> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.</dd></dl>
<dl compact><dt><b>Example:</b></dt><dd>To read into a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.async_read_some(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size), handler);
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="32081c0c9f6f616ccd8ff6ce09c7c7b8"></a><!-- doxytag: member="asio::basic_stream_socket::peek" ref="32081c0c9f6f616ccd8ff6ce09c7c7b8" args="(const Mutable_Buffers &amp;buffers)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::peek           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>buffers</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the incoming data on the stream socket. 
<p>
This function is used to peek at the incoming data on the stream socket, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Example:</b></dt><dd>To peek using a single data buffer use the <a class="el" href="a00230.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> socket.peek(<a class="code" href="a00230.html#g4116dae636ddf3b9b8a3d09372098eb0">asio::buffer</a>(data, size)); 
</pre></div> See the <a class="el" href="a00230.html">asio::buffer</a> documentation for information on using multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fb658c4ce8b9d216dd4bfb64a292cd90"></a><!-- doxytag: member="asio::basic_stream_socket::peek" ref="fb658c4ce8b9d216dd4bfb64a292cd90" args="(const Mutable_Buffers &amp;buffers, Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Mutable_Buffers, typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::peek           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="a00123.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error_Handler&nbsp;</td>
          <td class="mdname" nowrap> <em>error_handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at the incoming data on the stream socket. 
<p>
This function is used to peek at the incoming data on the stream socket, without removing it from the input queue. The function call will block until data has been read successfully or an error occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read. Returns 0 if an error occurred and the error handler did not throw an exception. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0176623c6cd6d0f41c90bf3f2dfb225"></a><!-- doxytag: member="asio::basic_stream_socket::in_avail" ref="a0176623c6cd6d0f41c90bf3f2dfb225" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::in_avail           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the amount of data that may be read without blocking. 
<p>
This function is used to determine the amount of data, in bytes, that may be read from the stream socket without blocking.<p>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00111.html">asio::error</a></em>&nbsp;</td><td>Thrown on failure. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="50ebac28ba9e853abb18fa6149908c82"></a><!-- doxytag: member="asio::basic_stream_socket::in_avail" ref="50ebac28ba9e853abb18fa6149908c82" args="(Error_Handler error_handler)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Error_Handler&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">std::size_t <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::in_avail           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Error_Handler&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>error_handler</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Determine the amount of data that may be read without blocking. 
<p>
This function is used to determine the amount of data, in bytes, that may be read from the stream socket without blocking.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>The handler to be called when an error occurs. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00111.html">asio::error</a>&amp; error <span class="comment">// Result of operation</span>
 ); 
</pre></div></td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of data that can be read without blocking. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="4cfc8ad513bc76523d5348a71d320972"></a><!-- doxytag: member="asio::basic_stream_socket::service_" ref="4cfc8ad513bc76523d5348a71d320972" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html#f43697a993f56955e3f9e353b3b1f210">service_type</a>&amp; <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00095.html#4cfc8ad513bc76523d5348a71d320972">service_</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The backend service implementation. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="da5cd4bcb34662066a3395c216c8c2b8"></a><!-- doxytag: member="asio::basic_stream_socket::impl_" ref="da5cd4bcb34662066a3395c216c8c2b8" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;typename Service&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00095.html#0ac43ba128daec432ece8d7eaecacbcb">impl_type</a> <a class="el" href="a00095.html">asio::basic_stream_socket</a>&lt; Service &gt;::<a class="el" href="a00095.html#da5cd4bcb34662066a3395c216c8c2b8">impl_</a><code> [private]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The underlying native implementation. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="777de2a765515bb0731c566aeb3f1a43"></a><!-- doxytag: member="asio::basic_stream_socket::message_peek" ref="777de2a765515bb0731c566aeb3f1a43" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const int <a class="el" href="a00130.html#777de2a765515bb0731c566aeb3f1a43">asio::socket_base::message_peek</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Peek at incoming data without removing it from the input queue. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="9acffef91e2ea49b433089355a3e1cb5"></a><!-- doxytag: member="asio::basic_stream_socket::message_out_of_band" ref="9acffef91e2ea49b433089355a3e1cb5" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const int <a class="el" href="a00130.html#9acffef91e2ea49b433089355a3e1cb5">asio::socket_base::message_out_of_band</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Process out-of-band data. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="264c9a83c18b653d91e16d321e90be32"></a><!-- doxytag: member="asio::basic_stream_socket::message_do_not_route" ref="264c9a83c18b653d91e16d321e90be32" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">const int <a class="el" href="a00130.html#264c9a83c18b653d91e16d321e90be32">asio::socket_base::message_do_not_route</a> = implementation_defined<code> [static, inherited]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Specify that the data should not be subject to routing. 
<p>
    </td>
  </tr>
</table>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.5</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
