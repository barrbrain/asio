<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::read_until</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.5.1 -->
<h1>asio::read_until</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#g031fe6f23722b75486bf0b7f3fb83eef">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a delimiter is encountered.  <a href="#g031fe6f23722b75486bf0b7f3fb83eef"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#g25ba10423afb52633c7514cce66f8ec7">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a delimiter is encountered.  <a href="#g25ba10423afb52633c7514cce66f8ec7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#g3e883cf22e2d26a669c5126981fd8372">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const std::string &amp;delim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a delimiter is encountered.  <a href="#g3e883cf22e2d26a669c5126981fd8372"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gfb18b86b158e3a18cf09aea7b01ac3fb">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const std::string &amp;delim, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a delimiter is encountered.  <a href="#gfb18b86b158e3a18cf09aea7b01ac3fb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#g3cfc390f406fde48135832ce02ff38f7">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a regular expression is located.  <a href="#g3cfc390f406fde48135832ce02ff38f7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename SyncReadStream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00138.html#gec49f5ddcd3824428032cddf432a7cbe">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, <a class="el" href="a00030.html">asio::error_code</a> &amp;ec)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read data into a streambuf until a regular expression is located.  <a href="#gec49f5ddcd3824428032cddf432a7cbe"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g031fe6f23722b75486bf0b7f3fb83eef"></a><!-- doxytag: member="asio::read_until" ref="g031fe6f23722b75486bf0b7f3fb83eef" args="(SyncReadStream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, char delim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a delimiter is encountered. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:<p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter character.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><pre class="fragment"> <a class="code" href="a00018.html">asio::streambuf</a> b;
 <a class="code" href="a00138.html#g031fe6f23722b75486bf0b7f3fb83eef">asio::read_until</a>(s, b, <span class="charliteral">'\n'</span>);
 std::istream is(&amp;b);
 std::string line;
 std::getline(is, line); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g25ba10423afb52633c7514cce66f8ec7"></a><!-- doxytag: member="asio::read_until" ref="g25ba10423afb52633c7514cce66f8ec7" args="(SyncReadStream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, char delim, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a delimiter is encountered. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:<p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter character.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3e883cf22e2d26a669c5126981fd8372"></a><!-- doxytag: member="asio::read_until" ref="g3e883cf22e2d26a669c5126981fd8372" args="(SyncReadStream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, const std::string &amp;delim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>delim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a delimiter is encountered. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:<p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter string.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><pre class="fragment"> <a class="code" href="a00018.html">asio::streambuf</a> b;
 <a class="code" href="a00138.html#g031fe6f23722b75486bf0b7f3fb83eef">asio::read_until</a>(s, b, <span class="stringliteral">"\r\n"</span>);
 std::istream is(&amp;b);
 std::string line;
 std::getline(is, line); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gfb18b86b158e3a18cf09aea7b01ac3fb"></a><!-- doxytag: member="asio::read_until" ref="gfb18b86b158e3a18cf09aea7b01ac3fb" args="(SyncReadStream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, const std::string &amp;delim, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a delimiter is encountered. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:<p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delim</em>&nbsp;</td><td>The delimiter string.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3cfc390f406fde48135832ce02ff38f7"></a><!-- doxytag: member="asio::read_until" ref="g3cfc390f406fde48135832ce02ff38f7" args="(SyncReadStream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a regular expression is located. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:<p>
<ul>
<li>A substring of the streambuf's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The regular expression.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the substring that matches the regular expression.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00050.html">asio::system_error</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Example</b></dt><dd>To read data into a streambuf until a CR-LF sequence is encountered: <div class="fragment"><pre class="fragment"> <a class="code" href="a00018.html">asio::streambuf</a> b;
 <a class="code" href="a00138.html#g031fe6f23722b75486bf0b7f3fb83eef">asio::read_until</a>(s, b, boost::regex(<span class="stringliteral">"\r\n"</span>));
 std::istream is(&amp;b);
 std::string line;
 std::getline(is, line); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gec49f5ddcd3824428032cddf432a7cbe"></a><!-- doxytag: member="asio::read_until" ref="gec49f5ddcd3824428032cddf432a7cbe" args="(SyncReadStream &amp;s, asio::basic_streambuf&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, asio::error_code &amp;ec)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until           </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00030.html">asio::error_code</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>ec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read data into a streambuf until a regular expression is located. 
<p>
This function is used to read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:<p>
<ul>
<li>A substring of the streambuf's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>The regular expression.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ec</em>&nbsp;</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes in the streambuf's get area up to and including the substring that matches the regular expression. Returns 0 if an error occurred. </dd></dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.8rc3</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
