<HTML>
  <HEAD>
    <TITLE>asio Reference: asio Namespace Reference</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.4</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.5 -->
<h1>asio Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The asio namespace defines all user-accessible classes and templates. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">basic_datagram_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides datagram-oriented socket functionality.  <a href="a00113.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">basic_deadline_timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides waitable timer functionality.  <a href="a00114.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">basic_demuxer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides core event demultiplexing functionality.  <a href="a00115.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">basic_locking_dispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides serialised handler execution.  <a href="a00118.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">basic_socket_acceptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides the ability to accept new connections.  <a href="a00119.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">basic_stream_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides stream-oriented socket functionality.  <a href="a00120.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">mutable_buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds a buffer that can be modified.  <a href="a00156.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">const_buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds a buffer that cannot be modified.  <a href="a00126.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">buffered_read_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the read-related operations of a stream.  <a href="a00123.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">buffered_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the read- and write-related operations of a stream.  <a href="a00124.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">buffered_write_stream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds buffering to the write-related operations of a stream.  <a href="a00125.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">const_buffers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds a list of buffers that cannot be modified.  <a href="a00127.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00158.html">mutable_buffers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds a list of buffers that can be modified.  <a href="a00158.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">consuming_buffers</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A proxy for a sub-range in a list of buffers.  <a href="a00129.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">datagram_socket_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a datagram socket.  <a href="a00132.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">deadline_timer_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a timer.  <a href="a00133.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">default_error_handler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default error handler. Always throws the error as an exception.  <a href="a00134.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">demuxer_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a demuxer.  <a href="a00135.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00163.html">service_factory&lt; demuxer_service&lt; Allocator &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialisation of <a class="el" href="a00162.html">service_factory</a> to allow an allocator to be specified.  <a href="a00163.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The error class is used to encapsulate system error codes.  <a href="a00138.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">error_placeholder_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used to indicate a placeholder for the actual error value.  <a href="a00139.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">expression</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The expression class template is used to allow expressions in an error handler template to be distinguished for the purposes of overloading the || and &amp;&amp; operators.  <a href="a00142.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">value_eq_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to compare the error for equality with a given value.  <a href="a00185.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">value_neq_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to compare the error for inequality with a given value.  <a href="a00186.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">expr_or_expr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to perform logical or on two expressions.  <a href="a00141.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">expr_and_expr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to perform logical and on two expressions.  <a href="a00140.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">throw_error_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to always throw an error.  <a href="a00181.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">throw_error_if_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to throw an error if an expression is true.  <a href="a00180.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">set_error_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to always set a variable to the error.  <a href="a00165.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html">set_error_if_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to set a variable to the error if an expression is true.  <a href="a00164.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">log_error_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to always log an error to a stream.  <a href="a00155.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">log_error_if_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to log an error to a stream if an expression is true.  <a href="a00154.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">ignore_error_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class to always ignore an error.  <a href="a00147.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">ignore_error_if_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class template to ignore an error if an expression is true.  <a href="a00146.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">fixed_buffer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00143.html">fixed_buffer</a> class template can be used as a byte buffer.  <a href="a00143.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00150.html">is_read_buffered</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00150.html">is_read_buffered</a> class is a traits class that may be used to determine whether a stream type supports buffering of read data.  <a href="a00150.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">is_write_buffered</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00151.html">is_write_buffered</a> class is a traits class that may be used to determine whether a stream type supports buffering of written data.  <a href="a00151.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">locking_dispatcher_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a locking dispatcher.  <a href="a00153.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">null_error_handler</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The null error handler. Always ignores the error.  <a href="a00159.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">service_factory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class may be specialised to provide custom service creation.  <a href="a00162.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">socket_acceptor_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a socket acceptor.  <a href="a00167.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">socket_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00168.html">socket_base</a> class is used as a base for the <a class="el" href="a00120.html">basic_stream_socket</a> and <a class="el" href="a00113.html">basic_datagram_socket</a> class templates so that we have a common place to define the shutdown_type and enum.  <a href="a00168.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">stream_socket_service</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default service implementation for a stream socket.  <a href="a00174.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00179.html">thread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple abstraction for starting threads.  <a href="a00179.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">time_traits&lt; boost::posix_time::ptime &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Time traits specialised for posix_time.  <a href="a00182.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">io_control</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The asio::io_control namespace defines IO control helper templates. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">placeholders</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The asio::placeholders namespace defines argument placeholders for use with <a class="el" href="boost_bind.html">boost::bind</a>. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00274.html">socket_option</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The asio::socket_option namespace defines socket options helper templates. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">ipv4</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The asio namespace defines the classes associated with IP version 4. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html">ssl</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The asio::ssl namespace defines templates and classes for SSL. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00113.html">basic_datagram_socket</a>&lt;<br>
 <a class="el" href="a00132.html">datagram_socket_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#215e8e0f020fae339fbe58ccd74e0cba">datagram_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of datagram_socket.  <a href="#215e8e0f020fae339fbe58ccd74e0cba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00114.html">basic_deadline_timer</a>&lt;<br>
 <a class="el" href="a00133.html">deadline_timer_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#e6447142de4630fb97081cdf737aca0e">deadline_timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of timer.  <a href="#e6447142de4630fb97081cdf737aca0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00115.html">basic_demuxer</a>&lt; <a class="el" href="a00135.html">demuxer_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#67d5317ccbb1bb5e0076e27a2b73c9b7">demuxer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for typical usage of demuxer.  <a href="#67d5317ccbb1bb5e0076e27a2b73c9b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00118.html">basic_locking_dispatcher</a>&lt;<br>
 <a class="el" href="a00153.html">locking_dispatcher_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#9c633b8597ccfeecf1b0b783db650966">locking_dispatcher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of locking_dispatcher.  <a href="#9c633b8597ccfeecf1b0b783db650966"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00119.html">basic_socket_acceptor</a>&lt;<br>
 <a class="el" href="a00167.html">socket_acceptor_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#c99e62531a20918bd6a7808a1b1950b5">socket_acceptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of socket_acceptor.  <a href="#c99e62531a20918bd6a7808a1b1950b5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="a00120.html">basic_stream_socket</a>&lt;<br>
 <a class="el" href="a00174.html">stream_socket_service</a>&lt;&gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#35902bc440f0b9cf5f2fbb1c10b1cfeb">stream_socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for the typical usage of stream_socket.  <a href="#35902bc440f0b9cf5f2fbb1c10b1cfeb"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#594973ab40aa5538aa57102b87abfc0c">operator+</a> (const <a class="el" href="a00156.html">mutable_buffer</a> &amp;b, std::size_t start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that is offset from the start of another.  <a href="#594973ab40aa5538aa57102b87abfc0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#5986f9841d471e39dc84fdaf85f937ac">operator+</a> (std::size_t start, const <a class="el" href="a00156.html">mutable_buffer</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that is offset from the start of another.  <a href="#5986f9841d471e39dc84fdaf85f937ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#4d2e2bb0932f60873e67b014aef3a333">operator+</a> (const <a class="el" href="a00126.html">const_buffer</a> &amp;b, std::size_t start)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that is offset from the start of another.  <a href="#4d2e2bb0932f60873e67b014aef3a333"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#90a44aa92ad1e865bc2a9104b581867c">operator+</a> (std::size_t start, const <a class="el" href="a00126.html">const_buffer</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that is offset from the start of another.  <a href="#90a44aa92ad1e865bc2a9104b581867c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#g4116dae636ddf3b9b8a3d09372098eb0">buffer</a> (const <a class="el" href="a00156.html">mutable_buffer</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="a00276.html#g4116dae636ddf3b9b8a3d09372098eb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#gc4248d69fa653851123779ea4e00263c">buffer</a> (const <a class="el" href="a00156.html">mutable_buffer</a> &amp;b, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="a00276.html#gc4248d69fa653851123779ea4e00263c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#g746b3196158209dbca3202069b4699ce">buffer</a> (const <a class="el" href="a00126.html">const_buffer</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="a00276.html#g746b3196158209dbca3202069b4699ce"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#ge32a9da6e98365ad49e47ee18c96aa3f">buffer</a> (const <a class="el" href="a00126.html">const_buffer</a> &amp;b, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="a00276.html#ge32a9da6e98365ad49e47ee18c96aa3f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#gd787a24b38548259d7225e9e1236f820">buffer</a> (void *data, std::size_t size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <a href="a00276.html#gd787a24b38548259d7225e9e1236f820"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#g614c457e011ecef22b2925011df658be">buffer</a> (const void *data, std::size_t size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <a href="a00276.html#g614c457e011ecef22b2925011df658be"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#gdbfeb8e402d4b8294b832fd6807b1533">buffer</a> (Pod_Type(&amp;data)[N])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="a00276.html#gdbfeb8e402d4b8294b832fd6807b1533"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g94cb39e7bb116915ec7e05fd02db4f0d">buffer</a> (Pod_Type(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="a00276.html#g94cb39e7bb116915ec7e05fd02db4f0d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#gb5427d733f9ebf1db0c72ae890a9bb88">buffer</a> (const Pod_Type(&amp;data)[N])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00276.html#gb5427d733f9ebf1db0c72ae890a9bb88"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g45d81188e582a464aabb480dc3490794">buffer</a> (const Pod_Type(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00276.html#g45d81188e582a464aabb480dc3490794"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g72016621d0d331d4b27cfbb82d6282f0">buffer</a> (boost::array&lt; Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="a00276.html#g72016621d0d331d4b27cfbb82d6282f0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g714434294a389127691a0ab25f4e3331">buffer</a> (boost::array&lt; Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="a00276.html#g714434294a389127691a0ab25f4e3331"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#ga3f61cfd3ac90ff83a812d5f63bc9d56">buffer</a> (const boost::array&lt; Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00276.html#ga3f61cfd3ac90ff83a812d5f63bc9d56"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#gd13169ab556017d3ba7ad280535be4f2">buffer</a> (const boost::array&lt; Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00276.html#gd13169ab556017d3ba7ad280535be4f2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g5f1caed86259696cb81715d0d890dfc9">buffer</a> (boost::array&lt; const Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00276.html#g5f1caed86259696cb81715d0d890dfc9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g4a658cb670c87132e7ddca3013853bd7">buffer</a> (boost::array&lt; const Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="a00276.html#g4a658cb670c87132e7ddca3013853bd7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#gdb15d0f628838dbe130983e0ef78606a">buffer</a> (std::vector&lt; Pod_Type &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="a00276.html#gdb15d0f628838dbe130983e0ef78606a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00156.html">mutable_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#gf3c40706ab6ee2a4fcbb9fddbe879295">buffer</a> (std::vector&lt; Pod_Type &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="a00276.html#gf3c40706ab6ee2a4fcbb9fddbe879295"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#gfc74cf698767c467634dcba63dabb55f">buffer</a> (const std::vector&lt; Pod_Type &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="a00276.html#gfc74cf698767c467634dcba63dabb55f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g99ae8507d79f894c0d62f32c6e94e4e0">buffer</a> (const std::vector&lt; Pod_Type &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="a00276.html#g99ae8507d79f894c0d62f32c6e94e4e0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g2e25eddc8c22c9429c4d7dd70d060bda">buffer</a> (std::vector&lt; const Pod_Type &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="a00276.html#g2e25eddc8c22c9429c4d7dd70d060bda"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00126.html">const_buffer</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#g3c712adac79e37f0b00f850e4872eab0">buffer</a> (std::vector&lt; const Pod_Type &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="a00276.html#g3c712adac79e37f0b00f850e4872eab0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html#g6972033f869850d9a403f4434c991fe4">buffers</a> (const <a class="el" href="a00126.html">const_buffer</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#g6972033f869850d9a403f4434c991fe4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html#gf5997e185a0bf9018a80ad0e143e5ba5">buffers</a> (const <a class="el" href="a00126.html">const_buffer</a> &amp;b, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#gf5997e185a0bf9018a80ad0e143e5ba5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html#gbea825b5347ecdd564fdba20e7564304">buffers</a> (const <a class="el" href="a00156.html">mutable_buffer</a> &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#gbea825b5347ecdd564fdba20e7564304"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html#gf012a61d9b66e8ecdb044880db684e56">buffers</a> (const <a class="el" href="a00156.html">mutable_buffer</a> &amp;b, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#gf012a61d9b66e8ecdb044880db684e56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html#g864c1bcc3f8463edd39347918c511e79">buffers</a> (const void *data, std::size_t size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#g864c1bcc3f8463edd39347918c511e79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html#g763ba04afb3a2083b2d794211c1e7bc5">buffers</a> (void *data, std::size_t size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#g763ba04afb3a2083b2d794211c1e7bc5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#gd2cbffec28949970d53681d7f66dcfc6">buffers</a> (Pod_Type(&amp;data)[N])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#gd2cbffec28949970d53681d7f66dcfc6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#gab9177c99055f58af2db2e1590521e67">buffers</a> (Pod_Type(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#gab9177c99055f58af2db2e1590521e67"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#gfa8d465873d5dd8b67ebbd27681e335e">buffers</a> (const Pod_Type(&amp;data)[N])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#gfa8d465873d5dd8b67ebbd27681e335e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#gd2e559e99423f8eeac457d59610bdcc5">buffers</a> (const Pod_Type(&amp;data)[N], std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#gd2e559e99423f8eeac457d59610bdcc5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#ge18d1605ad0d042e3a52d0003a315f8e">buffers</a> (boost::array&lt; Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#ge18d1605ad0d042e3a52d0003a315f8e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g3ca36d0ea01c8d734f6b0675ed888330">buffers</a> (boost::array&lt; Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#g3ca36d0ea01c8d734f6b0675ed888330"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#gb2d1ce43ce746e835a972e51e31713dd">buffers</a> (const boost::array&lt; Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#gb2d1ce43ce746e835a972e51e31713dd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#gec6df41c40d501a7e2ca925d63ef117b">buffers</a> (const boost::array&lt; Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#gec6df41c40d501a7e2ca925d63ef117b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g4c6f36855e968fbe510c21ee59715a92">buffers</a> (boost::array&lt; const Pod_Type, N &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#g4c6f36855e968fbe510c21ee59715a92"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type, std::size_t N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g712e6db87686a1f05e80f0e6ac26f49f">buffers</a> (boost::array&lt; const Pod_Type, N &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#g712e6db87686a1f05e80f0e6ac26f49f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g90025ef6990662a7bb81e9324c99fc31">buffers</a> (std::vector&lt; Pod_Type &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#g90025ef6990662a7bb81e9324c99fc31"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00158.html">mutable_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g924809e56e170e6da6f580231f6fb844">buffers</a> (std::vector&lt; Pod_Type &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00158.html">mutable_buffers</a> instance with one element.  <a href="a00277.html#g924809e56e170e6da6f580231f6fb844"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g5823b9d3d49dc04d783e5a4347d44b51">buffers</a> (const std::vector&lt; Pod_Type &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#g5823b9d3d49dc04d783e5a4347d44b51"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g457aad3118110429dd43c5f320c67c0d">buffers</a> (const std::vector&lt; Pod_Type &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#g457aad3118110429dd43c5f320c67c0d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g6129ba87cbacd450fd5ce0288686a942">buffers</a> (std::vector&lt; const Pod_Type &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#g6129ba87cbacd450fd5ce0288686a942"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Pod_Type&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00127.html">const_buffers</a>&lt; 1 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00277.html#g106bd913bf69613d5dc5238c35d6452a">buffers</a> (std::vector&lt; const Pod_Type &gt; &amp;data, std::size_t max_size_in_bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00127.html">const_buffers</a> instance with one element.  <a href="a00277.html#g106bd913bf69613d5dc5238c35d6452a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Expr&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; Expr &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#g7bcf75b07c05c1fedea508873455ba54">make_expression</a> (Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an expression object using template type deduction.  <a href="a00278.html#g7bcf75b07c05c1fedea508873455ba54"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Value&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00185.html">value_eq_error</a>&lt;<br>
 Value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#ga402a26051a47dd04c555c3f94b03a87">operator==</a> (Value value, <a class="el" href="a00139.html">error_placeholder_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the error for equality with a given value.  <a href="a00278.html#ga402a26051a47dd04c555c3f94b03a87"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Value&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00185.html">value_eq_error</a>&lt;<br>
 Value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#gfd768e0ca3d490a7fdc69effdafba8b6">operator==</a> (<a class="el" href="a00139.html">error_placeholder_t</a>, Value value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the error for equality with a given value.  <a href="a00278.html#gfd768e0ca3d490a7fdc69effdafba8b6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Value&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00186.html">value_neq_error</a>&lt;<br>
 Value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#gce110dad415be5ecd2326d1a8d8e22f4">operator!=</a> (Value value, <a class="el" href="a00139.html">error_placeholder_t</a>)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the error for inequality with a given value.  <a href="a00278.html#gce110dad415be5ecd2326d1a8d8e22f4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Value&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00186.html">value_neq_error</a>&lt;<br>
 Value &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#gcd15b086dd84f9298506521b4b91f07b">operator!=</a> (<a class="el" href="a00139.html">error_placeholder_t</a>, Value value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare the error for inequality with a given value.  <a href="a00278.html#gcd15b086dd84f9298506521b4b91f07b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Expr1, typename Expr2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00141.html">expr_or_expr</a>&lt;<br>
 <a class="el" href="a00142.html">expression</a>&lt; Expr1 &gt;, <a class="el" href="a00142.html">expression</a>&lt;<br>
 Expr2 &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#ga4b72cf4a94a8a35b810f92cedceba40">operator||</a> (<a class="el" href="a00142.html">expression</a>&lt; Expr1 &gt; expr1, <a class="el" href="a00142.html">expression</a>&lt; Expr2 &gt; expr2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a logical or on two expressions.  <a href="a00278.html#ga4b72cf4a94a8a35b810f92cedceba40"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Expr1, typename Expr2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00140.html">expr_and_expr</a>&lt;<br>
 <a class="el" href="a00142.html">expression</a>&lt; Expr1 &gt;, <a class="el" href="a00142.html">expression</a>&lt;<br>
 Expr2 &gt; &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#g3e31846e4e663adcf3bb257a3f9de202">operator &amp;&amp;</a> (<a class="el" href="a00142.html">expression</a>&lt; Expr1 &gt; expr1, <a class="el" href="a00142.html">expression</a>&lt; Expr2 &gt; expr2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a logical and on two expressions.  <a href="a00278.html#g3e31846e4e663adcf3bb257a3f9de202"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00181.html">throw_error_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#gbd68421ac96ddcea06f5e2ad8ff0239a">throw_error</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always throw an error.  <a href="a00278.html#gbd68421ac96ddcea06f5e2ad8ff0239a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Expr&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00180.html">throw_error_if_t</a>&lt;<br>
 Expr &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#g71d008a2a50cd5498e0aa239d2140220">throw_error_if</a> (Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Throw an error if an expression is true.  <a href="a00278.html#g71d008a2a50cd5498e0aa239d2140220"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Target&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00165.html">set_error_t</a>&lt; Target &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#gad1ab2d327db212448ef4934c272692b">set_error</a> (Target &amp;target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a variable to the error.  <a href="a00278.html#gad1ab2d327db212448ef4934c272692b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Target, typename Expr&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00164.html">set_error_if_t</a>&lt;<br>
 Target, Expr &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#g928868500c0d415c15c7e6d620984d30">set_error_if</a> (Target &amp;target, Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a variable to the error if an expression is true.  <a href="a00278.html#g928868500c0d415c15c7e6d620984d30"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ostream&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00155.html">log_error_t</a>&lt; Ostream &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#g7116a5a222fa2028ec73b5e444ae1d16">log_error</a> (Ostream &amp;ostream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always log an error to a stream.  <a href="a00278.html#g7116a5a222fa2028ec73b5e444ae1d16"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Ostream, typename Expr&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00154.html">log_error_if_t</a>&lt;<br>
 Ostream, Expr &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#g09e95a724d000cad9a9ae8c2c3bc626c">log_error_if</a> (Ostream &amp;ostream, Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Log an error to a stream if an expression is true.  <a href="a00278.html#g09e95a724d000cad9a9ae8c2c3bc626c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00147.html">ignore_error_t</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00278.html#g9bcebec2b0b4b2a14f4bc7e35df2b8b4">ignore_error</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always ignore an error.  <a href="a00278.html#g9bcebec2b0b4b2a14f4bc7e35df2b8b4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Expr&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00142.html">expression</a>&lt; <a class="el" href="a00146.html">ignore_error_if_t</a>&lt;<br>
 Expr &gt; &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00278.html#ge3c9165fcb23f7c399f0ae544d97b9f5">ignore_error_if</a> (Expr expr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ignore an error if an expression is true.  <a href="a00278.html#ge3c9165fcb23f7c399f0ae544d97b9f5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00279.html#g72bd8dbd6fce706caac7865dd0136853">read</a> (<a class="el" href="a00175.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from a stream.  <a href="a00279.html#g72bd8dbd6fce706caac7865dd0136853"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00279.html#gc25b87a11b73ddfbc26f0bfcf1e058a7">read</a> (<a class="el" href="a00175.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read some data from a stream.  <a href="a00279.html#gc25b87a11b73ddfbc26f0bfcf1e058a7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00280.html#gbd6c383f5d32688101b79112ace65b13">async_read</a> (<a class="el" href="a00110.html">Async_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous read.  <a href="a00280.html#gbd6c383f5d32688101b79112ace65b13"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#g4960651e51196ea1bb3b0621ede932c3">read_n</a> (<a class="el" href="a00175.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, std::size_t *total_bytes_transferred=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="a00281.html#g4960651e51196ea1bb3b0621ede932c3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00281.html#gcf20ccae638587a5ac66be680dd77b1f">read_n</a> (<a class="el" href="a00175.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, std::size_t *total_bytes_transferred, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="a00281.html#gcf20ccae638587a5ac66be680dd77b1f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00282.html#g8e4ed20c71f6628b9feb0715054cd142">async_read_n</a> (<a class="el" href="a00110.html">Async_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous attempt to read a certain amount of data from a stream.  <a href="a00282.html#g8e4ed20c71f6628b9feb0715054cd142"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00283.html#gf4ff5ddce27eab4d8be7e08162c3ddb9">read_at_least_n</a> (<a class="el" href="a00175.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, std::size_t min_length, std::size_t *total_bytes_transferred=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read at least a certain amount of data from a stream before returning.  <a href="a00283.html#gf4ff5ddce27eab4d8be7e08162c3ddb9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00283.html#gead9eea0150619de7982b24dc6f2a6b0">read_at_least_n</a> (<a class="el" href="a00175.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, std::size_t min_length, std::size_t *total_bytes_transferred, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read at least a certain amount of data from a stream before returning.  <a href="a00283.html#gead9eea0150619de7982b24dc6f2a6b0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Read_Stream, typename Mutable_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00284.html#g96b842ea36137334585b8b585d851aa2">async_read_at_least_n</a> (<a class="el" href="a00110.html">Async_Read_Stream</a> &amp;s, const <a class="el" href="a00157.html">Mutable_Buffers</a> &amp;buffers, std::size_t min_length, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous attempt to read at least a certain amount of data from a stream.  <a href="a00284.html#g96b842ea36137334585b8b585d851aa2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#g55e56cbc38c8f440ad297418ebfd563e">write</a> (<a class="el" href="a00176.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some data to a stream.  <a href="a00285.html#g55e56cbc38c8f440ad297418ebfd563e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00285.html#gf40cd9f3884a63daed9e319b8f484c1f">write</a> (<a class="el" href="a00176.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write some data to a stream.  <a href="a00285.html#gf40cd9f3884a63daed9e319b8f484c1f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Write_Stream, typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00286.html#gd7163fe4138ff3d02ff4a394fafae365">async_write</a> (<a class="el" href="a00111.html">Async_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write.  <a href="a00286.html#gd7163fe4138ff3d02ff4a394fafae365"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00287.html#gbe179bb6636a93b5f4538402e64f89a6">write_n</a> (<a class="el" href="a00176.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, std::size_t *total_bytes_transferred=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="a00287.html#gbe179bb6636a93b5f4538402e64f89a6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00287.html#ga06e39d472c6a2227b80e3cb99f0a1ac">write_n</a> (<a class="el" href="a00176.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, std::size_t *total_bytes_transferred, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="a00287.html#ga06e39d472c6a2227b80e3cb99f0a1ac"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Write_Stream, typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00288.html#gf2921160d147610e131c3882a3964f90">async_write_n</a> (<a class="el" href="a00111.html">Async_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write of all of the supplied data to a stream.  <a href="a00288.html#gf2921160d147610e131c3882a3964f90"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00289.html#gc0e3b743d01bf8adcb51ec95ac225409">write_at_least_n</a> (<a class="el" href="a00176.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, std::size_t min_length, std::size_t *total_bytes_transferred=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write at least a certain number of bytes of data to a stream before returning.  <a href="a00289.html#gc0e3b743d01bf8adcb51ec95ac225409"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Write_Stream, typename Const_Buffers, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00289.html#gd6f3850665583e323dc217c0b6601970">write_at_least_n</a> (<a class="el" href="a00176.html">Sync_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, std::size_t min_length, std::size_t *total_bytes_transferred, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write at least a certain number of bytes of data to a stream before returning.  <a href="a00289.html#gd6f3850665583e323dc217c0b6601970"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Async_Write_Stream, typename Const_Buffers, typename Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#g28ac0286a580996c09a42dababc1333b">async_write_at_least_n</a> (<a class="el" href="a00111.html">Async_Write_Stream</a> &amp;s, const <a class="el" href="a00128.html">Const_Buffers</a> &amp;buffers, std::size_t min_length, Handler handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start an asynchronous write of at least a certain number of bytes of data to a stream.  <a href="a00290.html#g28ac0286a580996c09a42dababc1333b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="a00139.html">error_placeholder_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00264.html#3622da74f3802d17a01c14b76bc712cb">the_error</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This variable is used as a placeholder for the error value.  <a href="#3622da74f3802d17a01c14b76bc712cb"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="215e8e0f020fae339fbe58ccd74e0cba"></a><!-- doxytag: member="asio::datagram_socket" ref="215e8e0f020fae339fbe58ccd74e0cba" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00113.html">basic_datagram_socket</a>&lt;<a class="el" href="a00132.html">datagram_socket_service</a>&lt;&gt; &gt; <a class="el" href="a00113.html">asio::datagram_socket</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of datagram_socket. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="e6447142de4630fb97081cdf737aca0e"></a><!-- doxytag: member="asio::deadline_timer" ref="e6447142de4630fb97081cdf737aca0e" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00114.html">basic_deadline_timer</a>&lt;<a class="el" href="a00133.html">deadline_timer_service</a>&lt;&gt; &gt; <a class="el" href="a00114.html">asio::deadline_timer</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of timer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="67d5317ccbb1bb5e0076e27a2b73c9b7"></a><!-- doxytag: member="asio::demuxer" ref="67d5317ccbb1bb5e0076e27a2b73c9b7" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00115.html">basic_demuxer</a>&lt;<a class="el" href="a00135.html">demuxer_service</a>&lt;&gt; &gt; <a class="el" href="a00115.html">asio::demuxer</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for typical usage of demuxer. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="9c633b8597ccfeecf1b0b783db650966"></a><!-- doxytag: member="asio::locking_dispatcher" ref="9c633b8597ccfeecf1b0b783db650966" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00118.html">basic_locking_dispatcher</a>&lt;<a class="el" href="a00153.html">locking_dispatcher_service</a>&lt;&gt; &gt; <a class="el" href="a00118.html">asio::locking_dispatcher</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of locking_dispatcher. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="c99e62531a20918bd6a7808a1b1950b5"></a><!-- doxytag: member="asio::socket_acceptor" ref="c99e62531a20918bd6a7808a1b1950b5" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00119.html">basic_socket_acceptor</a>&lt;<a class="el" href="a00167.html">socket_acceptor_service</a>&lt;&gt; &gt; <a class="el" href="a00119.html">asio::socket_acceptor</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of socket_acceptor. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="35902bc440f0b9cf5f2fbb1c10b1cfeb"></a><!-- doxytag: member="asio::stream_socket" ref="35902bc440f0b9cf5f2fbb1c10b1cfeb" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="a00120.html">basic_stream_socket</a>&lt;<a class="el" href="a00174.html">stream_socket_service</a>&lt;&gt; &gt; <a class="el" href="a00120.html">asio::stream_socket</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Typedef for the typical usage of stream_socket. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="594973ab40aa5538aa57102b87abfc0c"></a><!-- doxytag: member="asio::operator+" ref="594973ab40aa5538aa57102b87abfc0c" args="(const mutable_buffer &amp;b, std::size_t start)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00156.html">mutable_buffer</a> asio::operator+           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const mutable_buffer &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>std::size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new modifiable buffer that is offset from the start of another. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="5986f9841d471e39dc84fdaf85f937ac"></a><!-- doxytag: member="asio::operator+" ref="5986f9841d471e39dc84fdaf85f937ac" args="(std::size_t start, const mutable_buffer &amp;b)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00156.html">mutable_buffer</a> asio::operator+           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const mutable_buffer &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new modifiable buffer that is offset from the start of another. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="4d2e2bb0932f60873e67b014aef3a333"></a><!-- doxytag: member="asio::operator+" ref="4d2e2bb0932f60873e67b014aef3a333" args="(const const_buffer &amp;b, std::size_t start)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00126.html">const_buffer</a> asio::operator+           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const const_buffer &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>std::size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new non-modifiable buffer that is offset from the start of another. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="90a44aa92ad1e865bc2a9104b581867c"></a><!-- doxytag: member="asio::operator+" ref="90a44aa92ad1e865bc2a9104b581867c" args="(std::size_t start, const const_buffer &amp;b)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00126.html">const_buffer</a> asio::operator+           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const const_buffer &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new non-modifiable buffer that is offset from the start of another. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="3622da74f3802d17a01c14b76bc712cb"></a><!-- doxytag: member="asio::the_error" ref="3622da74f3802d17a01c14b76bc712cb" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="a00139.html">error_placeholder_t</a> <a class="el" href="a00264.html#3622da74f3802d17a01c14b76bc712cb">asio::the_error</a><code> [static]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This variable is used as a placeholder for the error value. 
<p>
    </td>
  </tr>
</table>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.4</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
