<HTML>
  <HEAD>
    <TITLE>asio Reference: asio::read</TITLE>
    <LINK HREF="asio.css" REL="stylesheet" TYPE="text/css">
    <LINK HREF="tabs.css" REL="stylesheet" TYPE="text/css">
  </HEAD>
  <BODY BGCOLOR="#FFFFFF">
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>Reference</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="hierarchy.html">Class Hierarchy</A> |
            <A CLASS="qindex" HREF="classes.html">Class Index</A> |
            <A CLASS="qindex" HREF="functions.html">Member Index</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
<!-- Generated by Doxygen 1.4.7 -->
<h1>asio::read</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97">asio::read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="#gdfc1ffb317dbc1ee0a757c1236fcbc97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Completion_Condition&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#g5a66d11d5f37678b0709988bd073f7ee">asio::read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Completion_Condition completion_condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="#g5a66d11d5f37678b0709988bd073f7ee"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Completion_Condition, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#g3dab7d992a5157f5cb01f6194445428d">asio::read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;buffers, Completion_Condition completion_condition, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="#g3dab7d992a5157f5cb01f6194445428d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#gd164d73ad6260d5c818538bbc5c350d2">asio::read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="#gd164d73ad6260d5c818538bbc5c350d2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator, typename Completion_Condition&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#gb3ab298e5acd32a06f1f9b4aea0a23fb">asio::read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="#gb3ab298e5acd32a06f1f9b4aea0a23fb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Sync_Read_Stream, typename Allocator, typename Completion_Condition, typename Error_Handler&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00273.html#geff3e9835551cdbd1ad2a517e4bc2929">asio::read</a> (<a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition, Error_Handler error_handler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="#geff3e9835551cdbd1ad2a517e4bc2929"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gdfc1ffb317dbc1ee0a757c1236fcbc97"></a><!-- doxytag: member="asio::read" ref="gdfc1ffb317dbc1ee0a757c1236fcbc97" args="(Sync_Read_Stream &amp;s, const Mutable_Buffers &amp;buffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Mutable_Buffers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to read a certain amount of data from a stream before returning. 
<p>
This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:<p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes transferred.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Example:</b></dt><dd>To read into a single data buffer use the <a class="el" href="a00270.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97">asio::read</a>(s, <a class="code" href="a00270.html#ga5592a9ee32b5c753466edc0af005edb">asio::buffer</a>(data, size)); 
</pre></div> See the <a class="el" href="a00270.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This overload is equivalent to calling: <div class="fragment"><pre class="fragment"> <a class="code" href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97">asio::read</a>(
     s, buffers,
     <a class="code" href="a00271.html#g750bf6e293973be0ed8e2c7a085457f7">asio::transfer_all</a>(),
     <a class="code" href="a00272.html#g17eebda462da83c5c2143f2fd77a840a">asio::throw_error</a>()); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5a66d11d5f37678b0709988bd073f7ee"></a><!-- doxytag: member="asio::read" ref="g5a66d11d5f37678b0709988bd073f7ee" args="(Sync_Read_Stream &amp;s, const Mutable_Buffers &amp;buffers, Completion_Condition completion_condition)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Completion_Condition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Completion_Condition&nbsp;</td>
          <td class="paramname"> <em>completion_condition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to read a certain amount of data from a stream before returning. 
<p>
This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:<p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns true.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completion_condition</em>&nbsp;</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> completion_condition(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error, <span class="comment">// Result of latest read_some</span>
                                              <span class="comment">// operation.</span>

   std::size_t bytes_transferred              <span class="comment">// Number of bytes transferred</span>
                                              <span class="comment">// so far.</span>
 ); 
</pre></div> A return value of true indicates that the read operation is complete. False indicates that further calls to the stream's read_some function are required.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes transferred.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Example:</b></dt><dd>To read into a single data buffer use the <a class="el" href="a00270.html">asio::buffer</a> function as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97">asio::read</a>(s, <a class="code" href="a00270.html#ga5592a9ee32b5c753466edc0af005edb">asio::buffer</a>(data, size),
     <a class="code" href="a00271.html#gdba1ed43445276e2b563a59663ca26cd">asio::transfer_at_least</a>(32)); 
</pre></div> See the <a class="el" href="a00270.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This overload is equivalent to calling: <div class="fragment"><pre class="fragment"> <a class="code" href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97">asio::read</a>(
     s, buffers, completion_condition,
     <a class="code" href="a00272.html#g17eebda462da83c5c2143f2fd77a840a">asio::throw_error</a>()); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3dab7d992a5157f5cb01f6194445428d"></a><!-- doxytag: member="asio::read" ref="g3dab7d992a5157f5cb01f6194445428d" args="(Sync_Read_Stream &amp;s, const Mutable_Buffers &amp;buffers, Completion_Condition completion_condition, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Mutable_Buffers, typename Completion_Condition, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00150.html">Mutable_Buffers</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Completion_Condition&nbsp;</td>
          <td class="paramname"> <em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to read a certain amount of data from a stream before returning. 
<p>
This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:<p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns true.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffers</em>&nbsp;</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completion_condition</em>&nbsp;</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> completion_condition(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error, <span class="comment">// Result of latest read_some</span>
                                              <span class="comment">// operation.</span>

   std::size_t bytes_transferred              <span class="comment">// Number of bytes transferred</span>
                                              <span class="comment">// so far.</span>
 ); 
</pre></div> A return value of true indicates that the read operation is complete. False indicates that further calls to the stream's read_some function are required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>A handler to be called when the operation completes, to indicate whether or not an error has occurred. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div> The error handler is only called if the completion_condition indicates that the operation is complete.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read. If an error occurs, and the error handler does not throw an exception, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd164d73ad6260d5c818538bbc5c350d2"></a><!-- doxytag: member="asio::read" ref="gd164d73ad6260d5c818538bbc5c350d2" args="(Sync_Read_Stream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_streambuf&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to read a certain amount of data from a stream before returning. 
<p>
This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:<p>
<ul>
<li>An error occurred.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="a00119.html">basic_streambuf</a> object into which the data will be read.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes transferred.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>This overload is equivalent to calling: <div class="fragment"><pre class="fragment"> <a class="code" href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97">asio::read</a>(
     s, b,
     <a class="code" href="a00271.html#g750bf6e293973be0ed8e2c7a085457f7">asio::transfer_all</a>(),
     <a class="code" href="a00272.html#g17eebda462da83c5c2143f2fd77a840a">asio::throw_error</a>()); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb3ab298e5acd32a06f1f9b4aea0a23fb"></a><!-- doxytag: member="asio::read" ref="gb3ab298e5acd32a06f1f9b4aea0a23fb" args="(Sync_Read_Stream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Allocator, typename Completion_Condition&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_streambuf&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Completion_Condition&nbsp;</td>
          <td class="paramname"> <em>completion_condition</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to read a certain amount of data from a stream before returning. 
<p>
This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:<p>
<ul>
<li>The completion_condition function object returns true.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="a00119.html">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completion_condition</em>&nbsp;</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> completion_condition(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error, <span class="comment">// Result of latest read_some</span>
                                              <span class="comment">// operation.</span>

   std::size_t bytes_transferred              <span class="comment">// Number of bytes transferred</span>
                                              <span class="comment">// so far.</span>
 ); 
</pre></div> A return value of true indicates that the read operation is complete. False indicates that further calls to the stream's read_some function are required.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes transferred.</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a></em>&nbsp;</td><td>Thrown on failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>This overload is equivalent to calling: <div class="fragment"><pre class="fragment"> <a class="code" href="a00273.html#gdfc1ffb317dbc1ee0a757c1236fcbc97">asio::read</a>(
     s, b, completion_condition,
     <a class="code" href="a00272.html#g17eebda462da83c5c2143f2fd77a840a">asio::throw_error</a>()); 
</pre></div> </dd></dl>

</div>
</div><p>
<a class="anchor" name="geff3e9835551cdbd1ad2a517e4bc2929"></a><!-- doxytag: member="asio::read" ref="geff3e9835551cdbd1ad2a517e4bc2929" args="(Sync_Read_Stream &amp;s, basic_streambuf&lt; Allocator &gt; &amp;b, Completion_Condition completion_condition, Error_Handler error_handler)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sync_Read_Stream, typename Allocator, typename Completion_Condition, typename Error_Handler&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00165.html">Sync_Read_Stream</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">basic_streambuf&lt; Allocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Completion_Condition&nbsp;</td>
          <td class="paramname"> <em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Error_Handler&nbsp;</td>
          <td class="paramname"> <em>error_handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attempt to read a certain amount of data from a stream before returning. 
<p>
This function is used to read a certain number of bytes of data from a stream. The call will block until one of the following conditions is true:<p>
<ul>
<li>The completion_condition function object returns true.</li>
</ul>
This operation is implemented in terms of one or more calls to the stream's read_some function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>The stream from which the data is to be read. The type must support the <a class="el" href="a00165.html">Sync_Read_Stream</a> concept.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The <a class="el" href="a00119.html">basic_streambuf</a> object into which the data will be read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>completion_condition</em>&nbsp;</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> completion_condition(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error, <span class="comment">// Result of latest read_some</span>
                                              <span class="comment">// operation.</span>

   std::size_t bytes_transferred              <span class="comment">// Number of bytes transferred</span>
                                              <span class="comment">// so far.</span>
 ); 
</pre></div> A return value of true indicates that the read operation is complete. False indicates that further calls to the stream's read_some function are required.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error_handler</em>&nbsp;</td><td>A handler to be called when the operation completes, to indicate whether or not an error has occurred. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> error_handler(
   <span class="keyword">const</span> <a class="code" href="a00136.html#bf315c06b88920b501db82537b15b2a4">Sync_Read_Stream::error_type</a>&amp; error <span class="comment">// Result of operation.</span>
 ); 
</pre></div> The error handler is only called if the completion_condition indicates that the operation is complete.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes read. If an error occurs, and the error handler does not throw an exception, returns the total number of bytes successfully transferred prior to the error. </dd></dl>

</div>
</div><p>
    <DIV CLASS="qindex">
      <TABLE BORDER="0" WIDTH="100%">
        <TR>
          <TD ALIGN="LEFT">
            <B>asio 0.3.7</B>
          </TD>
          <TD ALIGN="RIGHT">
            <A CLASS="qindex" HREF="../index.html">Home</A> |
            <A CLASS="qindex" HREF="../reference/index.html">Reference</A> |
            <A CLASS="qindex" HREF="../tutorial/index.html">Tutorial</A> |
            <A CLASS="qindex" HREF="../examples/index.html">Examples</A> |
            <A CLASS="qindex" HREF="../design/index.html">Design</A>
          </TD>
        </TR>
      </TABLE>
    </DIV>
  </BODY>
</HTML>
